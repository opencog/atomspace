//
// Script for automatic "Atom type" generation. For more information,
// consult the `README.md` file in this directory.
//
// Please note: some of the types below are used only via the scheme
// bindings. Thus, just because you can comment some of these out, and
// the code still compiles, that does not mean that these types are
// unused!  Be sure to grep for the CamelCase names, to see if they
// show up elsewhere!
//
// ===========================================================

// Special type designating that no Atom type has been assigned. It is
// equivalent to the bottom type in type theory, see
// https://en.wikipedia.org/wiki/Bottom_type
NOTYPE

// Supertype, equivalent to the top type of type theory. Every specific
// type inherits from this type. See
// https://en.wikipedia.org/wiki/Top_type
TOP_TYPE

// --------------------------------------------------------------
// Values are collections of data that can be associated with Atoms.
// Think of them as decorations that can be hung on an Atom.
VALUE <- TOP_TYPE

VOID_VALUE <- VALUE     // singleton Value holding nothing at all.
BOOL_VALUE <- VALUE     // vector of booleans
FLOAT_VALUE <- VALUE    // vector of floats
STRING_VALUE <- VALUE   // vector of strings
LINK_VALUE <- VALUE     // vector of Values ("link" holding Values)
VALUATION <- VALUE      // (Atom,key,Value) triple

LIST_VALUE <- VALUE     // Deserialization helper Can be combined with above.

// ===========================================================
// Streams aka Futures. Futures deliver a Value when asked.
// Since they can deliver more than one, and it typically changes
// over time, we call them "streams".  They provide wrappers for
// any kind of time-varying data.

// A base class for time-varying floating-point Values.
STREAM_VALUE <- FLOAT_VALUE

// An example of a time-varying Value stream
RANDOM_STREAM <- STREAM_VALUE

// A stream of FloatValues computed by a formula held in the AtomSpace.
// Similar to the FutureStream, except it is specialized for FloatValues.
// Typically computed by one of the FunctionLinks, below.
FORMULA_STREAM <- STREAM_VALUE,LIST_VALUE

// A base class for time-varying Value sequences.
LINK_STREAM_VALUE <- LINK_VALUE

// A thread-safe FIFO queue of Value sequences.
QUEUE_VALUE <- LINK_STREAM_VALUE

// A stream of Values, computed by a function held in the AtomSpace.
// Just like FormulaStream, but for vectors of Values.
FUTURE_STREAM <- LINK_STREAM_VALUE,LIST_VALUE

// ===========================================================
// TruthValues are the subobject classifiers for Atomese; they are used
// to generalize the notion of a subset (in exactly the same way that
// a subobject classifier does so in an arbitrary topos.) In some cases,
// these will be probabilities; in other cases, these are probabilities
// with additional evidence associated to them. In yet other cases,
// these resemble the truth values of "fuzzy logic", and so on.
//
// Many Atoms and operations on Atoms explicitly require TruthValues
// -- for example, PredicateNodes and EvaluationLinks -- and so these
// are vital and centrally important for getting things to work.
//
TRUTH_VALUE                <- FLOAT_VALUE
SIMPLE_TRUTH_VALUE         <- TRUTH_VALUE
COUNT_TRUTH_VALUE          <- TRUTH_VALUE
INDEFINITE_TRUTH_VALUE     <- TRUTH_VALUE
FUZZY_TRUTH_VALUE          <- TRUTH_VALUE
PROBABILISTIC_TRUTH_VALUE  <- TRUTH_VALUE
EVIDENCE_COUNT_TRUTH_VALUE <- TRUTH_VALUE

FORMULA_TRUTH_VALUE        <- SIMPLE_TRUTH_VALUE, FORMULA_STREAM

// ===========================================================
// Base of the Atom hierarchy. Atoms are globally unique; the AtomSpace
// guarantees that uniqueness. They are persistent; the AtomSpace
// provides persistence. They are immutable (unchangeable); links and
// nodes cannot be modified. However, the Values stored on a link/node
// can be changed!
//
// NOTE: ATOM will not have a corresponding python constructor, to
// avoid conflict with the python Atom object.
ATOM <- VALUE

// Frames are experimental: Atoms that are both Nodes and Links,
// having both a name and an outgoing set. Used as a base class for
// AtomSpaces. Currently, no other use.
FRAME <- ATOM

// The AtomSpace is kind of like a Link, kind of like a SetLink, except
// that it is mutable. The contents of the AtomSpace *can* be changed!
ATOM_SPACE <- FRAME

NODE <- ATOM
LINK <- ATOM

CONCEPT_NODE <- NODE
NUMBER_NODE <- NODE

// Basic Links
ORDERED_LINK <- LINK
UNORDERED_LINK <- LINK

// A PredicateNode is the primary subobject classifier of Atomese.
// When a PredicateNode is evaluated in some setting, the result is
// always a TruthValue.  They must return a TV when evaluated.
PREDICATE_NODE <- NODE

// ===========================================================
// Type-safety links.  These are used to enforce type safety at
// Atom creation time.  This is done in the ClassServer, with the
// ClassServer::addValidator() method and the factory which runs the
// validators. viz. std::vector<Validator*> _validator; in that class.
//
// This mechanism is adequate to deal with simple user errors, but
// isn't very strong. Issues include:
//
// *) By doing type-checking at Atom-creation time, this is a kind-of
//    static type-checking, and thus suffers from the typical issues
//    of static type-checking.
// *) Polymorphic outputs are broken.  For example, ValueOfLink
//    can return both numbers, and not-numbers...
// *) It fails to handle "deep types", as there should be some form
//    of ArrowLink associated with each Atom atype.
// *) It fails to handle connector polarities beyond just "input"
//    and "output". That is, there are more ways of connecting things
//    than merely saying "outputs are things that can be plugged into
//    inputs, and their types must match."
//
// So... deficient in many ways, but basically, it works for now, and it
// handles most of the basic cases in a fairly straightforward fashion.

// ValuableLink. Any link type which might be executed, resulting
// in a Value, should inherit from this type.  This is a mixin-type,
// it does nothing by itself, but is used to identify link types that
// are executable - that is, they return Values when they are executed.
VALUABLE_LINK <- LINK

// Evaluatable link. Any link type which might be evaluated, resulting
// in a TruthValue, should inherit from this type.  This is a
// mixin-type, it does nothing by itself, but is used to identify
// link types that are evaluatable - that is, they return TruthValues
// when they are evaluated.
EVALUATABLE_LINK <- VALUABLE_LINK

// Bogus placeholder. Used by Instantiator.cc. At this time, not every
// atom that has an `virtual ValuePtr Atom::execute()` method on it
// can do "the right thing", i.e. $vau it's way through life, and
// instead needs to be helped along the way by Instantiator. This
// link type identifies good links, the ones that can actually run
// correctly.
EXECUTABLE_LINK <- VALUABLE_LINK

// Crisp (scalar-valued) boolean-input link.  This link type forces
// type-checking on it's "inputs" (it's outgoing set): they must be
// EvaluatableLinks.
CRISP_INPUT_LINK <- LINK

// Crisp binary true/false output. Link types that, when evaluated,
// naturally yield a singular true/false value (and not a vector of
// bools)
CRISP_OUTPUT_LINK <- EVALUATABLE_LINK

// Boolean-input link. Accepts BoolValues (vectors of bools).
BOOLEAN_INPUT_LINK <- LINK

// Boolean-output link. Generates BoolValues upon execution.
BOOLEAN_OUTPUT_LINK <- VALUABLE_LINK

// Numeric-input link.  This link type forces type-checking on it's
// "inputs" (it's outgoing set): they must be NumberNodes, or things
// that can evaluate to NumberNodes: viz NumericOutputLinks, or
// numeric values (derived from FloatValue).
NUMERIC_INPUT_LINK <- LINK

// Numeric-output link. Generates either NumberNodes or FloatValues
// upon execution.
NUMERIC_OUTPUT_LINK <- VALUABLE_LINK

// Type-input link.  This link type forces type-checking on it's
// "inputs" (it's outgoing set): they must be types.
TYPE_INPUT_LINK <- LINK

// Type-output link. Generates Types upon execution.
TYPE_OUTPUT_LINK <- VALUABLE_LINK

// Alpha-convertible links are those that may have multiple different
// representations that are alpha-equivalent. This mixin helps checkers
// know whether they have to explicitly check for alpha-equivalence
// (e.g. the storage backends)
ALPHA_CONVERTIBLE_LINK <- LINK

// ===========================================================
// Basic boolean algebra and set-theory-inspired links.

// Base class for sets and for operations that return sets.
COLLECTION_LINK <- LINK

// Plain old list AKA Cartesian product
LIST_LINK <- ORDERED_LINK,COLLECTION_LINK

// Unordered multi-set (Classical Set-Theory set)
SET_LINK <- UNORDERED_LINK,COLLECTION_LINK

// Measure-theoretic (probabilistic) versions of AND_LINK, OR_LINK
// These use probabilistic formulas to compute TruthValues.
// See issue opencog/atomspace#2814 for a discussion.
UNION_LINK <- UNORDERED_LINK,COLLECTION_LINK
INTERSECTION_LINK <- UNORDERED_LINK,COLLECTION_LINK
COMPLEMENT_LINK <- UNORDERED_LINK,COLLECTION_LINK
SET_DIFFERENCE_LINK <- ORDERED_LINK,COLLECTION_LINK

// Set membership. Declaration: individual belongs to set.
// See also the section of relation-links below (including equality,
// etc.) Perhaps the definition of MemberLink and SubsetLink should
// be moved to that section!?
MEMBER_LINK <- ORDERED_LINK

// Indicates a subset relationship.
SUBSET_LINK <- ORDERED_LINK

// ContextLink: Universe of discourse. This behaves like set subtraction
// in that the set of things outside of the context have no bearing on
// the probability.
CONTEXT_LINK <- ORDERED_LINK

// Binary-valued (0/1, T/F) Boolean algebra operations and logical
// constants. These are used by the pattern matcher to compute
// crisp-logic boolean algebra combinations of predicates (that is,
// to implement classical predicate logic.)
//
// The ordered links SequentialAndLink, SequentialOrLink allow
// behavior-tree Sequence and Fallback to be implemented: they guarantee
// sequential execution until the first failure or the first success.
// See also CondLink below, which implements traditional conditional.
//
// XXX FIXME These types are widely and frequently misused in the code
// base: people have used them in places where there is no intent
// whatsoever to actually execute these link types. They're used in
// an entirely declarative fashion. This should be cleaned up, someday.
//
TRUE_LINK <- ORDERED_LINK,CRISP_OUTPUT_LINK
FALSE_LINK <- ORDERED_LINK,CRISP_OUTPUT_LINK
AND_LINK <- UNORDERED_LINK,CRISP_OUTPUT_LINK,CRISP_INPUT_LINK
OR_LINK <- UNORDERED_LINK,CRISP_OUTPUT_LINK,CRISP_INPUT_LINK
NOT_LINK <- UNORDERED_LINK,CRISP_OUTPUT_LINK,CRISP_INPUT_LINK
SEQUENTIAL_AND_LINK <- ORDERED_LINK,CRISP_OUTPUT_LINK // ,CRISP_INPUT_LINK
SEQUENTIAL_OR_LINK <- ORDERED_LINK,CRISP_OUTPUT_LINK,CRISP_INPUT_LINK

// ====================================================================
// Pattern-engine links. These have a special meaning for the pattern
// engine; they are used to specify what is searched for.

// The 'intuitionist logic' version of OR_LINK is 'multiple choice'
// The ChoiceLink states that a choice must be made.  Like a restaurant
// menu, it lists a menu of things: you can pick one (and only one).
// Thus, ChoiceLink is an exclusive choice: you can only choose one of
// the alternatives. The alternatives are just that: alternatives.
// They are not true/false valued; they're simply options on a menu.
// Pick one.  It is an ordered link, in the sense that the first choice
// might be preferable.
//
// The ChoiceLink is NOT semantically equivalent to the OrLink. The
// OrLink of two sets is a set union. The ChoiceLink of two sets is
// "pick one of these two sets but not both". (So its more like
// "disjoint union".)
//
// This is important for the pattern matcher; you use it to say
// "match this graph or this graph or this graph". It is
// crisp-true/false if any of the items on the menu are present.
// Compare to RandomChoiceLink below, which randomly selects one
// entry.
CHOICE_LINK <- ORDERED_LINK,CRISP_OUTPUT_LINK

// Rounding out the above, we have PresentLink, which is the converse
// of AbsentLink, and is dual to ChoiceLink, since it requires that all
// terms are AND'ed together.  Since it does not make sense to ask if
// the same Atom is present more than once, or what order it was in, it
// is an unordered link, and duplicates are eliminated.
//
PRESENT_LINK <- SET_LINK,CRISP_OUTPUT_LINK

// The 'intuitionist logic' version of NOT_LINK is ABSENT_LINK.
// In 'intuitionist logic', the opposite of "true" is not "false",
// the opposite is "don't know".  ABSENT_LINK is the effective
// don't-know link.  Currently, it is used during pattern matching
// to find clauses that may or may not be present: clauses that are
// optionally present.
//
// Just like the PresentLink, it does not make sense to have duplicates
// in the outgoing set, thus they are removed.  The mechanics of the
// PresentLink is used to accomplish this.
ABSENT_LINK <- PRESENT_LINK

// The other adjoint.
// Exists == left adjoint to the pullback functor of a relation.
//           where PresentLink is `Exists` for the pattern matcher.
// ForAll == right adjoint to the pullback functor of a relation.
//           We invent AlwaysLink, since `ForAll` is already taken
//           up by PLN.
// This is used in the pattern matcher, to implement an "always the
// case" condition during matching. It's a kind-of `ForAll`, just like
// Present is a kind-of `ThereExists`.
ALWAYS_LINK <- PRESENT_LINK

// Continuations are used in the Pattern Engine to implement infinite
// recursion. They currently behave like an explicit declaration of tail
// recursion.  (Caution: this may be a misleading name for what this
// link does. I can't think of a better name. TailRecursionLink is not
// quite the right name either, because the recursion need not be at the
// tail.)
CONTINUATION_LINK <- EVALUATABLE_LINK

// ====================================================================
// Basic Graph Theory
//
// An EdgeLink is used to represent labelled graph edges. The intended
// use is to represent graph edges as
//
//      EdgeLink
//         PredicateNode "some edge type" // Or a LexicalNode or BondNode
//         ListLink  // always a pair
//            Atom   // from-vertex
//            Atom   // to-vertex
//
// This is the base class for EvaluationLink, below. It is smaller in
// size, because the C++ EvaluationLink chews up an extra 120 Bytes to
// store free variables (from FreeLink). So Edge is .. the same thing,
// but slightly more RAM-efficient.
EDGE_LINK <- ORDERED_LINK

// ====================================================================
// Connectors and sections.
//
// The generic structure encoded here would be:
//
//     Section
//         Lexical "playing"
//         ConnectorSeq
//             Connector
//                 Lexical "level"
//                 Direction "-"
//             Connector
//                 Lexical "field"
//                 Direction "+"
//
// The above encodes the phrase "level playing field", indicating that
// "playing" connects to "level" on the left, and to "field" on the
// right. In this example, "playing" is the germ; it is at the center
// of the section.
//
// LexicalNode is for anything we keep a table of.
// It inherits from PredicateNode because it is a kind of predicate:
// It can evaluate to true, if something belongs to this lexical entry.
LEXICAL_NODE <- PREDICATE_NODE

// Wild-card node, very useful for counting. Similar to LexicalNode,
// except that it can be "anything" - most importantly, VariableNode.
ANY_NODE <- NODE

// Generic connector. Its a link, because it contains all of the details
// and restrictions required to define the allowable connections that
// can be made. The ability for it to mate to something can be encoded
// in a TruthValue (typically a crisp T/F for type specifications.)
CONNECTOR <- ORDERED_LINK

SEX_NODE <- LEXICAL_NODE            // Connector sexuality (aka "direction")
CONNECTOR_DIR_NODE <- SEX_NODE "ConnectorDir" // Deprecated, use above instead.
BOND_NODE <- LEXICAL_NODE           // A connection type name.
CONNECTOR_SEQ <- ORDERED_LINK       // Conjoined sequence of connectors
CONNECTOR_SET <- UNORDERED_LINK     // Unordered conjunction of connectors
CONNECTOR_CHOICE <- CHOICE_LINK     // Disjoined set of connectors
SECTION <- ORDERED_LINK             // Sheaf section, connector set

// Given a Section, the CrossSection reorganizes it so that one of the
// connectors is now in the center. For the above example, there are two
// CrossSections, one for each Connector. The CrossSection for "level"
// is:
//
//     CrossSectionLink
//         LexicalNode "level"
//         ShapeLink
//             LexicalNode "playing"
//             Connector
//                 AnyNode "$wildcard"
//                 ConnectorDir "-"
//             Connector
//                 Lexical "field"
//                 ConnectorDir "+"
//
// The original germ "playing" is now the head of the shape. The word
// "level" becomes the germ of the CrossSection. The wild-card indicates
// which slot the the germ of the CrossSection came from. Thus, the
// original Section can be obtained from the CrossSection by reinserting
// the new germ into the wild-card.
//
// CrossSections (and Shapes) are useful for computing the similarity
// between vectors of Sections.

// ShapeLink looks like a "labelled" ConnectorSeq (and so a ConnectorSeq
// is an "anonymous" shape.)
SHAPE_LINK <- CONNECTOR_SEQ

// The CrossSection is just a special kind of Section.
CROSS_SECTION <- SECTION

// ----------
// The following Atoms are meant to describe "raw data", before that
// data has been organized with the Connectors and Sections above.
// Unlike the above, they are not rigorously defined; they're only
// for making low-level code more organized and easier to read.
//
// The general idea is this:
// * Items are "things" (words, pictures, sounds) being generated by
//   some data stream.
// * ItemClasses are classifications of Items (words that are nouns,
//   pictures of bicycles and road signs)
// * Tags are names of the data streams (streams of words, pictures)
//
// Note that the difference between a type and a set is blurry; so, in a
// sense Tags and ItemClasses (and sets) are all the "same thing". It's
// just handy to have these around for different kinds of uses in the
// code base.

// An ItemNode is used for any "item" or "thing" that we want to track.
// It's lexical, because, in general, we will be looking it up in some
// table or dictionary. See issue #2901 for discussion.
ITEM_NODE <- LEXICAL_NODE

// An ItemClassNode is a name for a collection of Items. Roughly, a
// collection is a set; this is the name of that set. Set membership
// is denoted with MemberLink so:
//      (MemberLink (ItemNode "foo") (ItemClassNode "all foo things"))
ITEM_CLASS_NODE <- LEXICAL_NODE

// A TagNode is a name for a data stream that is generating Items.
// Data streams are kind-of-like sets, except that they are constantly
// popping out more Items, so they're not static or fixed.
TAG_NODE <- LEXICAL_NODE

// A TagLink is a link between a TagNode and the Item being tagged.
// The "natural" convention is to make the Tag first, the Item second,
// and so the order of the arguments is reversed from a MemberLink.
TAG_LINK <- ORDERED_LINK // <- MEMBER_LINK

// ====================================================================
// Predicate-logic/lambda-calc/model-theory style links and nodes.
// These embody some of the common and recurring themes from predicate
// logic, model theory, term rewriting and lambda calculus. There is
// no strict correspondence, however, as there is no formal unification
// of these theories -- its just a leveraging of common themes.
//
// These are used to implement the pattern matcher, and everything built
// from the pattern matcher, including the query system and the rule
// engine. In that sense, their definitions are "strict", else the
// pattern matcher will fail.

// A Variable.  Use Lambda's to hide these. Use types to type them.
VARIABLE_NODE <- ANY_NODE

// A list of variables or variable declarations.
VARIABLE_LIST <- CONNECTOR_SEQ

// A set (thus unordered) of variables or variable declarations. This
// is convenient when combined with a scope link where the order of
// variables is irrelevant to the semantics of the scope, like a
// BindLink.
VARIABLE_SET <- CONNECTOR_SET

// A non-greedy globbing variable; matches one or more Atoms in a
// sequence. All this really does is to name a variable, such that
// the default type cnstructor for it will accept multiple matches.
GLOB_NODE <- VARIABLE_NODE

// Everything under a QuoteLink is interpreted literally. Variable
// substitution (beta-reduction) is not performed into quoted variables.
QUOTE_LINK <- ORDERED_LINK

// The QuoteLink is actually a quasi-quote. The UnquoteLink undoes the
// quoting.  Defined to work kind-of like in lisp/scheme. (XXX TODO,
// we currently do not check to make sure that each Unquote has a Quote
// above it. We should ...)
UNQUOTE_LINK <- ORDERED_LINK

// Like QuoteLink but only affects the direct child, not its
// descendants. It has the same effect as wrapping the child with a
// QuoteLink and each Atom of the its outgoing set with an UnquoteLink.
LOCAL_QUOTE_LINK <- ORDERED_LINK

// Everything under a DontExecLink is not executed. This is typically
// used during pattern matching, to halt infinite recursion, when the
// matched pattern is itself executable. Vaguely like QuoteLink, but
// instead of blocking beta-reduction, it blocks execution.
DONT_EXEC_LINK <- ORDERED_LINK

// Substitution - replace first arg by second arg. Used in JoinLink.
// Could be used in PatternLink too.
REPLACEMENT_LINK <- ORDERED_LINK

// A FreeLink is any kind of link that might have free variables in it.
// The FreeLink exists for one purpose: to make visible/explicit all of
// free variables in the link. The primary user is the pattern matcher.
// That is, envision the FreeLink as being at the top of a tree, and
// somewhere in that tree, there might be VariableNodes.  The C++ class
// for this link records the names of those variables, in order of
// traversal.  The goal here is to simply know these variables, so that,
// at the time of evaluation or execution, they are easily located.
//
// The variables are necessarily free: they do NOT have type
// declarations or restrictions associated with them.  This is in sharp
// contrast to ScopeLink, which binds variables by scoping them, and
// then forcing type restrictions to them.
//
// FreeLinks may be open or closed; they are closed terms if they
// have no free variables in them.
//
FREE_LINK <- ORDERED_LINK

// This is an interesting one. It is a link that must never be grounded!
// It must contain at least one VariableNode somewhere within it; that
// is, it must be an "open sentence" and never a "closed sentence".
// (as it would be called, using the terminology of predicate logic;
// See Wikipedia for a formal definition).
//
// Attempting to insert a DeleteLink holding a fully grounded term
// (holding a closed sentence) will instead cause the the term to be
// deleted from the AtomSpace, thus the name.  This is meant to be used
// with the pattern matcher, so that if it discovers a grounding, the
// grounded term is deleted.
//
// Implementation Note: The DeleteLink cannot inherit from FunctionLink
// because that would cause all variables to be bound, i.e. to become
// a closed sentence; thus it inherits from FreeLink.
//
DELETE_LINK <- FREE_LINK

// Only one "closed" UniqueLink may exist (in the AtomSpace), for a
// fixed first Atom of the Link.  Useful for defining state.  Additional
// "open" links may exist; "open" links are defined as links that
// contain free variables (see Wikipedia definition of "open term",
// "closed term").  Kind of like DeleteLink, but allows one instead of
// zero closed terms.
UNIQUE_LINK <- FREE_LINK

// Inserting a StateLink into the AtomSpace causes the previous
// state to be removed from the AtomSpace. Uniqueness applies only to
// closed terms; thus, StateLinks with variables in the defintion can
// be created for search patterns.
STATE_LINK <- UNIQUE_LINK

// Uniquely naming things, tagging things. Attempting to insert a
// second definition into the AtomSpace will throw an exception.
// Restricted to DefinedProcedure, DefinedSchema, etc.
DEFINE_LINK <- UNIQUE_LINK

// Unqiue, exclusive relationships. Attempting to insert a second relation
// into the AtomSpace will silently fail, and the original relation is
// returned. No error is thrown. Allows first-come-first-serve atomic
// mutex relationships to be placed in the AtomSpace. These cannot be
// hidden by Frames. Applies only to closed terms; thus, GrantLinks with
// variables in the defintion can be created for search patterns.
GRANT_LINK <- UNIQUE_LINK

// The ScopeLink is used to identify an open term, i.e. a link
// containing VariableNodes within it, and binding those variables.
// In the process, it can also force type restrictions on them.
// The ScopeLink does not have to bind all variables that occur in it's
// body; those that are not bound remain free.
//
// The ScopeLink differs from the FreeLink in that the FreeLink
// necessarily lists ALL the (free) variables within it; the ScopeLink
// tracks only the bound variables (and not the free ones). The
// FreeLink cannot have type restrictions on the variables; the
// ScopeLink can (and usually does).
//
// This inherits from Section, as its a special case of a lexical
// entry with connector definitions inside of it. Viz, the scope
// body is the lexical entry, and the variable declarations are the
// connector declarations.
SCOPE_LINK <- SECTION,ALPHA_CONVERTIBLE_LINK

// The RewriteLink is a ScopeLink with extra methods that perform
// alpha conversion and beta reduction on the ScopeLink. It is a base
// class for many kinds of Atom types, most of which CANNOT be treated
// as if they were lambdas!  So user beware: although RewriteLink feels
// like LambdaLink ... it isn't.  Not everything is a Lambda.
REWRITE_LINK <- SCOPE_LINK

// The PrenexLink is a RewriteLink that maintains prenex normal form.
// It serves as a base class for the various pattern-matching links,
// since pattern matching only makes sense when the patterns are written
// in prenex normal form.  It also serves as the base class for Lambda,
// since function composition in Atomese only seems to make sense if
// the result is in prenex form. (I can't figure out what it means to
// have a Lambda that is not in prenex form. Or a Pattern that is not
// in prenex form.)
PRENEX_LINK <- REWRITE_LINK

// The LambdaLink is supposed to roughly model the traditional concept
// of a lambda from lambda calculus (or functional programming). It
// is meant to behave just like a lambda-abstraction, and supports the
// standard operations of beta-reduction and alpha-conversion (modulo
// that the AtomSpace enforces alpha-equivalence).  Non-prenex lambdas
// in Atomese don't seem to "make any sense", at least to me, so
// lambda's are forced to be prenex. This is a departure from classical
// lambda calculus.
LAMBDA_LINK <- PRENEX_LINK

// PutLinks perform a beta-reduction when executed; i.e. they get
// beta-reduced when they are executed. PutLinks are the same thing as
// beta-redexes.
PUT_LINK <- PRENEX_LINK

// The JoinLink searches for containing links that satsify the specified
// predicates. This is the AtomSpace version of "join and meet" in a
// partially ordered set. See wikipedia "meet and join".
// The MinimalJoin is the supremum.
// The MaximalJoin is the top.
// The UpperSet is everything in between.
JOIN_LINK <- PRENEX_LINK,EXECUTABLE_LINK
MINIMAL_JOIN_LINK <- JOIN_LINK
UPPER_SET_LINK <- JOIN_LINK
MAXIMAL_JOIN_LINK <- JOIN_LINK

// A proof-theory style "rule". It consists of a variable declaration,
// a collection of "formulas" that are the "presmises" of the rule, and
// one (or more) formulas that are the conclusion of the rule. This is
// a base class that provides ctor-time analyis of the PrenexLink, adds
// a virtual method to get the conclusion(s). It avoids the overhead
// for constructing an actual PatternLink, and so is faster to create.
// It is more appropriate for filtering streams of graphs, and for
// systems like the URE, which are mostly just manipulating rules,
// instead of actually running them (as queries).
RULE_LINK <- PRENEX_LINK,EXECUTABLE_LINK

// Links that can return the components of a RuleLink. They allow a
// rule to be disassembled, in Atomese, and then run through the
// the unifier, to create proof trees.
VARDECL_OF_LINK <- EXECUTABLE_LINK
PREMISE_OF_LINK <- VARDECL_OF_LINK
CONCLUSION_OF_LINK <- VARDECL_OF_LINK

// Pattern definition, pattern grounding/satisfaction.
// The PatternLink implements the base class holding a pattern that
// the query engine will traverse.  Its primary role in life is to
// enable a C++ class that unpacks all the arguments and types, etc.
// into assorted C++ structures. It does not have any semantics in and
// of itself, it just holds machinery and a cache of the pre-compiled
// pattern. This is optimized specifically for use with the query engine
// and is not really appropriate for handling streams.
PATTERN_LINK <- RULE_LINK

// We subdivide patterns into two types: one type returns a TV when it
// is evaluated.  The other type returns a set of Atoms when it is
// executed.  The distinction is made for the benefit of the C++ code,
// so that it can dispatch appropriately, based on the base type.

// Finds all groundings, returns generic Value
SATISFYING_LINK <- PATTERN_LINK,EXECUTABLE_LINK

// The GetLink is almost exactly the same thing as a SatsifyingSetLink,
// except that GetLink is imperative, while SatisfyingSetLink is
// declarative.  Likewise, BindLink is exactly the same thing as an
// ImplicationLink, except that its imperative, not declarative.
// Both return SetLinks holding the results.
// QueryLink is identical to BindLink, except it returns a LinkValue
// holding the result, instead of a SetLink. (Less AtomSpace pollution).
MEET_LINK <- SATISFYING_LINK       // Finds all groundings, returns them
GET_LINK <- MEET_LINK              // Finds all groundings, returns them
QUERY_LINK <- SATISFYING_LINK      // Finds all groundings, substitutes.
BIND_LINK <- QUERY_LINK            // Finds all groundings, substitutes.

// Adjoint to the GetLink. This is "adjoint" in the sense that the roles
// of the pattern and the grounding are reversed: given a grounding, the
// collection of patterns that are grounded by it can be searched-for.
DUAL_LINK <- SATISFYING_LINK

// ==============================================================
// Basic Knowledge-Representation types.
//
// EvaluationLinks record the result of evaluating a predicate.
// That is, given some elements, they indicate whether the predicate is
// true or false (or has some other TruthValue) on those elements.
EVALUATION_LINK <- FREE_LINK,EDGE_LINK,EVALUATABLE_LINK

// ==============================================================
// Types and type constructors. Variables and other Atoms can be
// given types.  The below describe the types.

// A TypeNode holds simple, "atomic" type declarations, such as those
// defined in this file. It cannot hold compound types (deep types),
// because compound types are Atoms, and this is a Node, not a Link,
// and so it cannot hold any Atoms. Use DefinedTypeNode for compound
// types. Its a LexicalNode, whose lexis consists of Atom types.
TYPE_NODE <- BOND_NODE

// Non-strict versions of above. See the wiki.
TYPE_INH_NODE <- TYPE_NODE
TYPE_CO_INH_NODE <- TYPE_NODE

// User-defined type.  This is meant to be used with DefineLink
// to give a name to a type definition; for example, a type definition
// specified with SignatureLink or ArrowLink.
DEFINED_TYPE_NODE <- TYPE_NODE

// Used for type polymorphism.
// Note that the empty type choice corresponds to the bottom type.
// see, https://wiki.opencog.org/w/TypeChoice#Bottom_type
//
// This "should" inherit from TYPE_INPUT_LINK. However, it is currently valid
// to write `(TypeChoice (Type 'ConceptNode) (Predicate "foo"))` and the
// `(Predicate "foo")` causes the type checker to fail. Maybe the spec
// should be changed to only allow
// `(TypeChoice (Type 'ConceptNode) (Signature (Predicate "foo")))` if
// such a "constant" type is wanted. I dunno. Not sure. Changing this
// causes DeepTypeUTest to fail. ... Forcing use of Signature is "more
// correct", but clunkier to the user, so we don't force it.
// TYPE_CHOICE <- CHOICE_LINK,TYPE_OUTPUT_LINK,TYPE_INPUT_LINK
// See https://en.wikipedia.org/wiki/Union_type
TYPE_CHOICE <- CHOICE_LINK,TYPE_OUTPUT_LINK,ALPHA_CONVERTIBLE_LINK

// Type constructor. Forces a set-intersection of all of the type
// definitions (signatures) that it contains. Useful for computing
// type intersections during type unification. Also heavily used for
// specifying a compound of the IntervalLink and a simple type, which
// is used heavily to specify GlobNode types. Inherits from TypeChoice,
// because the C++ class needs to hold all the same members.
// See https://en.wikipedia.org/wiki/Intersection_type
TYPE_INTERSECTION_LINK <- TYPE_CHOICE

// Function-type constructor.  Corresponds to right-arrow of functional
// programming languages, viz. arity-2, first arg is input, 2nd
// arg is output.  It is a ConnectorSeq, since it specifies a pair of
// connectors (the input, and the output).
ARROW_LINK <- CONNECTOR_SEQ,TYPE_OUTPUT_LINK

// Type constructor.
// The SignatureLink implements "deep types", a way for specifying
// the type of an entire graph, and not just some node or link.
// The type specification is "precise", in contrast to the fuzzy
// type specification, below. It is a Connector, as it specifies
// only one connectable thing at a time.
SIGNATURE_LINK <- CONNECTOR,TYPE_OUTPUT_LINK

// Short-hand for above: (SignNode 'BlahLink) is shorthand for
// (SignatureLink (TypeNode 'BlahLink)). This can be used in any
// pattern match that needs a variable region, but does not need
// to know what is matched there. That is, an "un-named variable",
// a variable without a name binding.
SIGN_NODE <- TYPE_NODE

// Signature for a typed link. This is needed for encoding signatures
// involving LinkValue and similar. It also simplifies polymorphsm.
// Thus, for example, the siggnature of
// (LinkValue (FloatValue...) (Concept ...)) cannot be encoded with
// a regular SignatureLink, because the LinkValue blocks this. However,
// it can be encoded as
// (LinkSignature (Type 'LinkValue) (Type 'FloatValue) (Type 'Concept))
LINK_SIGNATURE_LINK <- SIGNATURE_LINK, EXECUTABLE_LINK

// A type binder: it binds a type to a VariableNode. Always arity-2,
// the first position must be a VariableNode, the second must be a type.
// Note that this is always scoped, i.e. used in lambdas and places
// where variables are not free. Thus, unlike TypedAtomLink, this is
// never globally unique.
//
// The inherits from Connector, as it is a special case...
// The variable name is not lexical -- its a wild-card.
TYPED_VARIABLE_LINK <- CONNECTOR,ALPHA_CONVERTIBLE_LINK

// A type binder for non-variable Atoms. It binds a type to an Atom
// at a "global" level.  Always arity-2, the first position cannot be
// any Atom except for a VariableNode, the second must be a type.
// A given Atom can only ever have just one type, thus, this is unique.
TYPED_ATOM_LINK <- UNIQUE_LINK

// An arity-2 link, used for specifying numeric intervals, that is,
// the lower and upper bounds of some range. Currently used for
// specifying GlobNode counts. However, now that NumberNodes are
// vectors, this isn't really needed, although it is convenient.
INTERVAL_LINK <- ORDERED_LINK

// ====================================================================
// Synchronization primitive, used to mark stages of a processing
// pipeline; used as a fence or guard barrier, make sure that earlier
// stages have completed processing before later ones start.
// Basically, hypergraphs may be attached to the anchor, with a
// ListLink, to indicate that they are either done, or awaiting
// processing.
ANCHOR_NODE <- NODE

// ====================================================================
// Relations. A "relation" is a subset of a Cartesian product, or more
// generally, something that can have a subobject classifier. Examples
// include "relations" from model theory, and "relations" from
// "relational algebra" (e.g. SQL).
//
// Relations always have an associated subobject classifier. For naive
// set theory, this is the indicator function, having values of
// true/false, indicating set membership. For Atomese, the subject
// classifier is explicitly always a TRUTH_VALUE.

// A generic catch-all equality-relation link. No particular semantics
// is assigned to this, other than that it relates things that
// are "similar" in some way.
SIMILARITY_LINK <- UNORDERED_LINK

// A VirtualLink is equivalent to an EvaluationLink, with a
// GroundedPredicateNode in it, except that the GPN is "built in".
// So, for example, GreaterThanLink is equivalent to an EvaluationLink
// with a GroundedPredicateNode "c++:greater_than". The built-in
// evaluation links have better performance, since they don't need
// to make a call to external scheme or python code to get evaluated.
//
// The VirtualLink designation is needed by the pattern matcher,
// in order to be able to find and treat these terms correctly.
//
// VirtualLinks only need to be used for those GPN's that take 2 or
// more arguments. If they take only one, then there is no reason
// for them to be declared as virtual (at least, as far as the pattern
// matcher is concerned, which, right now, is the only user of this
// link type.)
//
// In mathematics nomenclature, VirtualLinks are "relations": they are
// terms that evaluate to crisp true/false values.
VIRTUAL_LINK <- CRISP_OUTPUT_LINK
GREATER_THAN_LINK <- VIRTUAL_LINK,NUMERIC_INPUT_LINK
LESS_THAN_LINK <- VIRTUAL_LINK,NUMERIC_INPUT_LINK

// Test whether all outgoing Atoms are closed, that is do not contain
// any free variable.
IS_CLOSED_LINK <- UNORDERED_LINK,VIRTUAL_LINK

// Test whether all outgoing Atoms have a TRUE_TV (resp. FALSE_TV).
IS_TRUE_LINK <- UNORDERED_LINK,VIRTUAL_LINK
IS_FALSE_LINK <- UNORDERED_LINK,VIRTUAL_LINK

// IdenticalLink tests for syntactic equality.  It does NOT execute its
// arguments; it is true only if both sides are the same Atom.
// EqualLink tests for semantic equality: the two sides are equal, if,
// after execution, they evaluate to the same Atom.
IDENTICAL_LINK <- UNORDERED_LINK,VIRTUAL_LINK
EQUAL_LINK <- UNORDERED_LINK,VIRTUAL_LINK

// AlphaEqualLink tests to see if both sides are the same, up to an
// alpha-renaming of any variables that they may have.
ALPHA_EQUAL_LINK <- UNORDERED_LINK,VIRTUAL_LINK

// ExclusiveLink tests to make sure all elements differ from
// one-another. True only if they all differ...
EXCLUSIVE_LINK <- UNORDERED_LINK,VIRTUAL_LINK

// If the pattern has a grounding (any grounding at all), then
// return true, else return false. This is a crisp binary true/false.
SATISFACTION_LINK <- SATISFYING_LINK,VIRTUAL_LINK

// --------------------------------------------------------------
// Functions that do NOT bind variables.

// A FunctionLink is a Link that can be executed, with the result of
// execution being some Atom.  FunctionLink does NOT derive from
// LambdaLink, which may seem counter-intuitive; here's why, so
// listen up.  All of the explicitly-named functions (e.g. PlusLink)
// do not need to explicitly name their arguments, and it would even
// be confusing if they did so.  Instead, the convention is that every
// element in the outgoing set of the FunctionLink IS an argument of
// the function; that's all, end-of-story.
//
// All variables that appear underneath the FunctionLink are necessarily
// free variables; they are neither scoped, nor bound.
//
// The FunctionLink is meant to be a base type for links that define
// functions.  It is NOT meant to be used as a base type for
// user-defined structures; users should use the LambdaLink for that.
FUNCTION_LINK <- FREE_LINK,EXECUTABLE_LINK

// XXX TODO-FIXME: Many of the link types below are derived from
// FunctionLink, but the gains are marginal. Here's the tradeoff:
// * The FreeLink ctor takes CPU-time to run, so that costs.
// * The benefit is that FunctionLinks get beta-reduction capability for
//   free. This is used in half-a-dozen unit tests. It makes Atomese
//   expressions simpler to write and easier to read: the alternative
//   would be to force users to always use Lambda to explicitly declare
//   the variables that will appear as the function API. The cost is
//   then one more Atom in the AtomSpace, plus more cognitive load on
//   the human author of Atomese.
//
// How widespread is this? The ExecutionOutputLink makes use of this,
// and so does FormulaPredicateLink.cc. Altering the first is easy.
// The second is easy to stub out, but then siz unit tests fail. Sooo
// leave as-is seems like the correct choice.

// --------------------
// Boolean-valued functions

// Similar to earlier and/or/not links, but these are actually
// executable functions, and not just declarative declarations.
// These links can be used to operate on BoolValues, which are
// vectors of bools. The ops apply point-wise to the vectors.
BOOL_OP_LINK <- FUNCTION_LINK,BOOLEAN_OUTPUT_LINK,BOOLEAN_INPUT_LINK
BOOL_AND_LINK <- BOOL_OP_LINK
BOOL_OR_LINK <- BOOL_OP_LINK
BOOL_NOT_LINK <- BOOL_OP_LINK

// --------------------
// Arithmetic and number-valued functions

NUMERIC_FUNCTION_LINK <- FUNCTION_LINK,NUMERIC_OUTPUT_LINK,NUMERIC_INPUT_LINK

// Basic arithmetic operators
FOLD_LINK <- FUNCTION_LINK
ARITHMETIC_LINK <- FOLD_LINK,NUMERIC_INPUT_LINK,NUMERIC_OUTPUT_LINK
PLUS_LINK <- ARITHMETIC_LINK
MINUS_LINK <- PLUS_LINK
TIMES_LINK <- ARITHMETIC_LINK
DIVIDE_LINK <- TIMES_LINK

// Minimum and maxmimum of a set of numbers.
MIN_LINK <- NUMERIC_FUNCTION_LINK
MAX_LINK <- NUMERIC_FUNCTION_LINK

// Truncate to integer (floor)
FLOOR_LINK <- NUMERIC_FUNCTION_LINK

// Heaviside step function; same as GreaterThan, but works
// for vectors, and returns numeric value.
// Uses stdd:signbit to determine if float is positive or not.
HEAVISIDE_LINK <- NUMERIC_FUNCTION_LINK

// Converts vector of bools into vector of floats.
// Replacing false, true by 0.0 and 1.0
IMPULSE_LINK <- FUNCTION_LINK,BOOLEAN_INPUT_LINK,NUMERIC_OUTPUT_LINK

// Logarithm base2
LOG2_LINK <- NUMERIC_FUNCTION_LINK

// Power x**y
POW_LINK <- NUMERIC_FUNCTION_LINK

// Return uniformly distributed random number between two limits.
RANDOM_NUMBER_LINK <- NUMERIC_FUNCTION_LINK

// Trigonometric Sine function
SINE_LINK <- NUMERIC_FUNCTION_LINK

// Return the sum of vector components of a NumberNode or FloatValue.
ACCUMULATE_LINK <- NUMERIC_FUNCTION_LINK

// Apply a BoolValue to any other vector, knocking out all locations
// marked with a zero, keeping all location marked with a one, thus
// creating a shorter vector. Works on vectors of Bools, Strings, Floats,
// etc. Declare that, so the static typechecker passes.
DECIMATE_LINK <- FUNCTION_LINK,NUMERIC_OUTPUT_LINK,BOOLEAN_OUTPUT_LINK

// Same as above, but instead of specifying a mask, the input is a
// vector holding the index offsets of the mask bits. I.e. the input is
// a list of indexes of items to keep.
ELEMENT_OF_LINK <- FUNCTION_LINK,NUMERIC_OUTPUT_LINK,BOOLEAN_OUTPUT_LINK

// TODO: perhaps create shift-left, shift-right and truncate operators?
// Someday, they will be needed; just not yet, I guess.

// Convert a FloatValue to a NumberNode. The argument is presumed to
// be some executable link that, when executed, returns a FloatValue
// (or some derived type, e.g. some stream) and now we want an
// actual NumberNode.
NUMBER_OF_LINK <- FUNCTION_LINK,NUMERIC_OUTPUT_LINK

// Return the current time.
TIME_LINK <- FUNCTION_LINK,NUMERIC_OUTPUT_LINK

// --------------------
// Value getters. Grab the current Value attached to some Atom.

// Return the indicated Value on the indicated Atom.
// The BoolValueOf and FloatValueOf links exist only to provide
// creation-time type checking; otherwise, they behave just like
// the ValueOfLink. The StreamValueOf can return non-number streams,
// but we lie about this to keep the static typechecker happy.
VALUE_OF_LINK <- FUNCTION_LINK
BOOL_VALUE_OF_LINK <- VALUE_OF_LINK,BOOLEAN_OUTPUT_LINK
FLOAT_VALUE_OF_LINK <- VALUE_OF_LINK,NUMERIC_OUTPUT_LINK
STREAM_VALUE_OF_LINK <- VALUE_OF_LINK,NUMERIC_OUTPUT_LINK
TRUTH_VALUE_OF_LINK <- FLOAT_VALUE_OF_LINK
STRENGTH_OF_LINK <- FLOAT_VALUE_OF_LINK
CONFIDENCE_OF_LINK <- FLOAT_VALUE_OF_LINK
COUNT_OF_LINK <- FLOAT_VALUE_OF_LINK

// Return size of the wrapped link. If it's a NumberNode
// or a Value, return the length of the underlying vector.
SIZE_OF_LINK <- FLOAT_VALUE_OF_LINK

// Return the type of the wrapped Atom
TYPE_OF_LINK <- VALUE_OF_LINK

// Grab an IncomingSet of an Atom, and return it as a LinkValue.
INCOMING_OF_LINK <- VALUE_OF_LINK

// Convert a LinkValue to a SetLink. The argument is presumed to
// be some executable link that, when executed, returns a LinkValue
// (or some derived type, e.g. a QueueValue) and now we want an
// actual set.
COLLECTION_OF_LINK <- FUNCTION_LINK,COLLECTION_LINK

// Opposite of the ValueOfLink; attach a Value to an Atom.
// Verb: "to set", and not noun "a set (collection)"
SET_VALUE_LINK <- FUNCTION_LINK
SET_TV_LINK <- SET_VALUE_LINK,EVALUATABLE_LINK "SetTVLink"

// Internal-use-only wrapper for Values. Older code for function
// application and beta reduction only works with Atoms, not Values.
// Rewriting it to flow Values is really hard: we don't have a strategy
// for applying functions to Values. This is the tactical work-around:
// It can be placed inside a Link, so beta-reduction works. It holds
// a Value, which functions can obtain by calling execute(). It *cannot*
// be placed in the AtomSpace, so is not quite a "real" Atom.
VALUE_SHIM_LINK <- EXECUTABLE_LINK,NUMERIC_OUTPUT_LINK

// -----------
// Similar to ValueOfLink, but this returns a promise to return a Value
// sometime in the future. This is accomplished by returning a either
// a FutureStream or a FormulaStream when executed. This stream will
// then cough up the actual Value later on, when interrogated. Used to
// create dynamically executable computation chains.
PROMISE_LINK <- VALUABLE_LINK,EXECUTABLE_LINK

// Return a FormulaTruthValue when evaluated. Same as above, but for
// TruthValues only.  This can be used to wrap any Atom that returns a
// TruthValue. The effect is to defer to the future the evaluation of
// that predicate. Used to create dynamically evaluatable formulas.
PROMISE_PREDICATE_LINK <- EVALUATABLE_LINK, PROMISE_LINK

// Return a SimpleTruthValue when evaluated.
// This is used to wrap any Atom that returns a FloatValue; all this
// does is to provide some formatting.  It is not strictly needed,
// because any LambdaLink returning FloatValue is enough. But this is
// handy to have while a transition is made to a more general setting.
// Its handy because it looks a lot like a GROUNDED_PREDICATE_NODE,
// except that the formula is in the Atomese, not scheme/python.
//
// Its a ScopeLink, because in general it will contain variables that
// are scoped, bound. The Lambda provides the mechanism to access/shield
// the variables.
FORMULA_PREDICATE_LINK <- SCOPE_LINK,EVALUATABLE_LINK

// FilterLink was called MapLink (but this name was wrong) or
// FilterMapLink or UnPutLink.  UnPut, because it undoes a beta-
// reduction, by extracting Values for a given set of variables.
// In many ways,  it resembles a GetLink, except that it searches
// only its argument list, instead of the entire AtomSpace.
//
// MapLink, because it resembles the standard functional-programming
// concept of "map", except that it discard unmatchable entries, so
// it's really FilterMapLink. That's a mouthful, so we go with FilterLink.
FILTER_LINK <- FUNCTION_LINK

// --------------------
// Other kinds of functions.

// The ExecutionOutputLink is a specific kind of function: it must have
// a Schema of some kind in it's first argument. Current choices include:
// Schema, GroundedSchema, DefinedSchema and PromiseSchema. The other
// kinds of FunctionLinks do not need this; the function they perform,
// that is, the schema, is implicit in the link type.
EXECUTION_OUTPUT_LINK <- FUNCTION_LINK

// Return (with uniform distribution) one of the links it wraps.
RANDOM_CHOICE_LINK <- FUNCTION_LINK

// Conditional if-then-else list. First term must evaluate to crisp
// true/false. If true, then the second term is returned, else the
// third term. If there are more than three terms, this repeats: so
// odd terms must evaluate to true/false, resulting in the return of
// the first even term which followed the first true evaluation.
//
// We don't really know what it returns, but it might be a number.
// The static type checker will complain, unless we all NumericOutput.
COND_LINK <- FUNCTION_LINK,NUMERIC_OUTPUT_LINK

// Sleep link pauses execution for the indicated number of seconds.
SLEEP_LINK <- FUNCTION_LINK,NUMERIC_INPUT_LINK

// ====================================================================
// Performance scripting links.
//
// ParallelLink launches multiple threads, but does not wait for any of
// them to return.  ThreadJoinLink launches multiple threads, and waits
// for all of them to return, and then returns the boolean And of their
// TruthValues.
PARALLEL_LINK <- UNORDERED_LINK,EVALUATABLE_LINK
THREAD_JOIN_LINK <- PARALLEL_LINK

// Somewhat like ThreadJoinLink, except that this works with executable,
// not evaluatable links.
EXECUTE_THREADED_LINK <- EXECUTABLE_LINK

// Everything under a PureExecLink is executed in a different AtomSpace.
// This is used to isolate the present AtomSpace from the execution
// results. If no AtomSpace is specified, a temporary is created.
PURE_EXEC_LINK <- EXECUTABLE_LINK

// ==============================================================
// Procedure and schema nodes.
//
// These form the foundation for a different way of looking at
// Values and Predicates: they generalize the notion of "predicate"
// so that any Value or Atom can be the result of evaluation
// (which is now renamed "execution", to make a distinction).
//
// Procedures are generic terms; when they are executed, they can
// return any Value, including Atoms, and not just TruthValues.
PROCEDURE_NODE <- NODE

// DefinedProcedureNodes are used to make human-written Atomese easier
// to read by humans. They have no other fundamental usefulness...
// They are meant to be wrappers for more complex Atomese that return
// some Value.
DEFINED_PROCEDURE_NODE <- PROCEDURE_NODE

// Grounded procedures/predicates/schemas are "jets", which replace
// inefficient code with efficient implementations in an ad-hoc kind of
// way. They accelerate code that would otherwise be impractical to
// express or execute in Atomese. See for example
// http://lambda-the-ultimate.org/node/5482 for discussion of jets.
GROUNDED_PROCEDURE_NODE <- PROCEDURE_NODE

// GroundedPredicates wrap something that returns a TruthValue.
GROUNDED_PREDICATE_NODE <- PREDICATE_NODE,GROUNDED_PROCEDURE_NODE

// DefinedPredicateNodes are used to make human-written Atomese easier
// to read by humans. They have no other fundamental usefulness...
// They are meant to be wrappers for more complex Atomese that return
// some TruthValue.
DEFINED_PREDICATE_NODE <- PREDICATE_NODE,PROCEDURE_NODE

// SchemaNodes are similar to PredicateNodes, except they must
// necessarily return Atoms when executed.
SCHEMA_NODE <- PROCEDURE_NODE
DEFINED_SCHEMA_NODE <- SCHEMA_NODE,DEFINED_PROCEDURE_NODE
GROUNDED_SCHEMA_NODE <- SCHEMA_NODE,GROUNDED_PROCEDURE_NODE

// ==============================================================
// Foreign abstrast syntax trees (AST's)

// Base class for all foregin (non-Atomese) language abstract syntax
// trees.
FOREIGN_AST <- LINK

// Abstract syntax trees, in the form of s-expressions
SEXPR_AST <- FOREIGN_AST

// AST for DataLog subset of Prolog
DATALOG_AST <- FOREIGN_AST

// AST for JSON.
JSON_AST <- FOREIGN_AST

// AST for Python programs
PYTHON_AST <- FOREIGN_AST

// ==============================================================
// Assorted miscellaneous link types with an unclear future.
// Some of these need to be moved to the URE.

// This is a marker used to avoid type-checking in the static type
// checker. See `atoms/core/Checkers.cc`
DIRECTLY_EVALUATABLE_LINK <- LINK

// The ImplicationLink and the InheritanceLink ... these are really
// basic knowledge representation links, and so basically should
// probably stay in the core AtomSpace. However, they should be
// described more carefully. Right now, they seem ambiguous.

// Sugar forms of implication and equivalence links. See
// http://wiki.opencog.org/wikihome/index.php/ImplicationLink
// for more information
IMPLICATION_LINK <- ORDERED_LINK, DIRECTLY_EVALUATABLE_LINK
INHERITANCE_LINK <- ORDERED_LINK, DIRECTLY_EVALUATABLE_LINK

// Logical quantifiers (adjoints to pullbacks of relations). Both are
// scoped.
//
// Exists == left adjoint to the pullback functor of a relation. (The
//           set-membership relation.) Note that PRESENT_LINK above is
//           the unscoped variant of this, used in the pattern matcher.
// ForAll == right adjoint to the pullback functor of a relation. (The
//           set-membership relation.) Note that ALWAYS_LINK below is
//           the unscoped variant of this, used in the pattern matcher.
//
// At least, that's the fancy definition. It's not used anywhere. The
// plain definition is just the conventional first-order-logic definition.
// Since they have a conventional and well-known meaning, I guess they
// can stay in the core AtomSpace, as a part of the set of links useful
// for knowledge representation.
//
// In reality, its a mish-mash. Currently, these are used only in unit
// tests.  They're somewhat poorly defined. They are currently defined
// to inherit from CollectionLink, thus allowing them to be set-valued,
// and used in probabilistic contexts.
FORALL_LINK <- SCOPE_LINK,COLLECTION_LINK "ForAllLink"
EXISTS_LINK <- SCOPE_LINK,COLLECTION_LINK

// These are used only in unit tests, at this point.
// No clear role assigned, other than that there is some "association"
// Perhaps this should be a base type for ... some knowledge
// representation thingy?
ASSOCIATIVE_LINK <- ORDERED_LINK

// A relation much stronger than Similarity, and not just EqualLink.
// Used only in unit tests, at this time.
EQUIVALENCE_LINK <- UNORDERED_LINK

// Undocumented mystery link. Used in unit tests.
EXECUTION_LINK <- ORDERED_LINK
