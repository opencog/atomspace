#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Graphs, Metagraphs, RAM, CPU
\end_layout

\begin_layout Author
Linas Vepstas
\end_layout

\begin_layout Date
2 Sept 2020 Version 1.0
\end_layout

\begin_layout Date
19 Nov 2021 Version 2.0
\end_layout

\begin_layout Abstract
This text reviews the concepts of a graph store, starting from the fundamental
 question of how to efficiently represent a graph in RAM (that is, in storage).
 Starting with a naive conception of a graph database, it arrives at hypergraphs
 and metagraphs as simpler and more efficient representations for graphical
 data.
\end_layout

\begin_layout Abstract
Even stronger claims are made: metagraph databases are easier to use than
 graph databases.
 The structure and contents of a metagraph database is easier to understand.
 Algorithms that act on a metagraph database are simpler, more compact,
 and easier to write, than corresponding algorithms for graph databases.
 This is really quite remarkable, and seems to come 
\begin_inset Quotes eld
\end_inset

for free
\begin_inset Quotes erd
\end_inset

 with just a minor change in perspective.
\end_layout

\begin_layout Abstract
Once one arrives at the concept of a metagraph (and arrives at it quite
 naturally, through minor modifications of an ordinary graph store), there
 is then a rather remarkable and easy slide down-hill that culminates at
 the OpenCog AtomSpace and Atomese as a (near-)optimal design point.
 The metagraph representation is remarkably flexible and powerful tool for
 representing data (representing knowledge) and working with (manipulating,
 rewriting) that data.
\end_layout

\begin_layout Abstract
This is part of a sequence of texts on sheaves, although it does not explicitly
 mention these.
 It is a mandatory pre-requisite for understanding the further efficiencies
 and flexibility that sheaves provide.
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
Currently, graph databases are popular, and they have a rather distinct
 performance profile, differing from both SQL and noSQL databases.
 At a simplistic level, the OpenCog AtomSpace is a kind of a graph database.
 More correctly, it is a generalized-hypergraph or 
\begin_inset Quotes eld
\end_inset

metagraph
\begin_inset Quotes erd
\end_inset

 database.
 This design has certain implications for RAM and CPU usage.
 This text argues that it has superior properties to ordinary graph databases.
 It arrives at this conclusion by starting with the most basic, foundational
 description of graph databases, and then defines hypergraphs and metagraphs
 as minor variants on the underlying data structures.
\end_layout

\begin_layout Standard
Graphs offer an interesting storage format for many reasons.
 Coupled to those reasons is a need for graph traversal, and another need
 for graph query (solving the subgraph isomorphism problem).
 Thus, the questions examined here is how one might best be able to traverse
 graphs, and how to best perform subgraph matching.
 By 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

, it is meant algorithms that find a good balance betwen speed and size.
 Effectively all the discussion in this text assumes uniform memory access;
 that is a 
\begin_inset Quotes eld
\end_inset

flat
\begin_inset Quotes erd
\end_inset

 memory topology, where any location in storage can be accessed with the
 same latency as any other.
\end_layout

\begin_layout Standard
This text is organized into several parts:
\end_layout

\begin_layout Itemize
An introduction to naive graphs,
\end_layout

\begin_layout Itemize
An aside about more traditional knowledge representation formats, including
 tables, JSON and s-expressions.
\end_layout

\begin_layout Itemize
How graphs can be represented in memory,
\end_layout

\begin_layout Itemize
Modifications to the representation that result in hypergraphs and metagraphs,
 including a quick analysis for memory usage
\end_layout

\begin_layout Itemize
A discussion of the concept of 
\begin_inset Quotes eld
\end_inset

indexing
\begin_inset Quotes erd
\end_inset

, especially in how it contrasts with the concept as generally understood
 in SQL/noSQL databases,
\end_layout

\begin_layout Itemize
A quick introduction to partial indexes (a full discussion is impossible
 without first tackling pattern matching 
\emph on
aka
\emph default
 querying, done in a later text).
\end_layout

\begin_layout Itemize
A short review of how meta-trees are used to represent knowledge.
\end_layout

\begin_layout Section*
Graph Representations
\end_layout

\begin_layout Standard
Formally, a graph is
\end_layout

\begin_layout Itemize
A set of vertexes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of edges 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each edge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered pair of vertexes drawn from the set 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Standard
Because edges are ordered pairs, it is conventional to denote them with
 arrows, having a head and tail.
 These can be joined together in arbitrary ways.
 Below is a 
\begin_inset Quotes eld
\end_inset

typical
\begin_inset Quotes erd
\end_inset

 directed graph:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/directed-graph.png
	lyxscale 40
	width 30col%

\end_inset


\end_layout

\begin_layout Subsection*
Attributes
\end_layout

\begin_layout Standard
In practice, one wishes to associate a label to each vertex, and also some
 additional attribute data; likewise for the edges.
 There are three fundamental choices available for storing attributes: merged
 schema+data, disjoint schema–data and s-expressions.
 An examples of the first is JSON.
 Each block of data to be stored is preceded by its name.
 Additional markup, such as quotes and square brackets, indicate structure
 such as text-strings and arrays.
 An example of disjoint schema–data are tables.
 The name and data type appears only in the column heading; individual rows
 in the table do not need to repeat the schema.
 Clearly, for tables with more than a few rows, the tabular format offers
 a huge advantage in terms of memory usage.
 Conversely, having many tables with just one or two rows each quickly becomes
 a table management problem; conentional systems are not designed to hold
 a million tables of one row each.
\end_layout

\begin_layout Standard
Tables are highly inflexible when new columns or new schema need to be added.
 There is no sensible way to take one row of a table, and have it use a
 different schema than the other rows.
 It doesn't even make sense to talk about rows in this way; if one row has
 a different schema than another, they aren't rows of the same table any
 more.
\end_layout

\begin_layout Standard
An example of an s-expression store is a key-value store.
 Here, the first word is taken to be the key; subsequent words are taken
 to be a list of values associated with that key.
 The idea of s-expressions emphasizes that the key-value store can be hierarchic
ally structured.
 An example is the Unix filesystem structure: each directory can have files,
 but it can alos have subdirectories, ad infinitum.
 In this sense, a URL can be understood to be a kind-of s-expression.
\end_layout

\begin_layout Standard
In a graph store, one has these three choices for storing attributes, both
 for vertexes and for edges.
 One might even contemplate a mixture; after all, a JSON blob is isomorphic
 to a table with only a single row.
 The remainder of this text will make little or no assumptions about the
 storage format of the attributes, as this has little or no impact on the
 primary topics here.
 With one exception: query and indexing.
 This is reviewed in a distinct section later on.
\end_layout

\begin_layout Subsubsection*
Emulating Tables
\end_layout

\begin_layout Standard
This section aims to make the above commentary a bit more concrete by working
 though some examples.
 Although the examples in this section are written in text, the reader is
 very strongly urged to try to imagine how these structures might be represented
 in RAM, and how much storage they might take.
 A later section will return to these questions of in_RAM representations.
\end_layout

\begin_layout Standard
Consider the need to store data about some stundents.
 Expressed in JSON format, it might be written as:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	{ grades:
\end_layout

\begin_layout Plain Layout

		[
\end_layout

\begin_layout Plain Layout

			{ student: {name: Joe},    {gpa: 3.5}},
\end_layout

\begin_layout Plain Layout

			{ student: {name: Mary},   {gpa: 3.6}},
\end_layout

\begin_layout Plain Layout

			{ student: {name: Rachel}, {gpa: 3.0}}
\end_layout

\begin_layout Plain Layout

		]
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset

The square brackets denote a list; as is conventional with a list, all list
 elements are uniform and of the same type.
 Clearly, this appears to be a very regular structure, and if there are
 hundreds of students.
 One might try to save some space by eliminating the repeated attribute
 names.
 If JSON is used for this, this becomes a column-store:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		{ table:
\end_layout

\begin_layout Plain Layout

			{ schema: {name: string}, {gpa: float}}
\end_layout

\begin_layout Plain Layout

			{ names:  [Joe, Mary, Rachel] },
\end_layout

\begin_layout Plain Layout

			{ gpa:    [3.5, 3.6, 3.0 ] }
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

That is, each entry in the table is a column name, followed by a list of
 all of the values in that column.
\end_layout

\begin_layout Standard
This is distinct from a row-store.
 In a row store, one conventionally provides a schema describing the columns
 and thier formats, much as above, and then provides the rows, one by one,
 as 
\begin_inset Quotes eld
\end_inset

records
\begin_inset Quotes erd
\end_inset

, or inhomogenous lists of fixed length.
 That is, each entry in the list has a different type (it has the type of
 the column), but each list is exactly the same length; thus, a 
\begin_inset Quotes eld
\end_inset

record
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Students
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gpa
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Joe
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rachel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
There does not appear to be any way of representing a row-store in JSON,
 at least not in the JSON as naively conceived here.
 One wishes to write something like the below, but the syntax makes it illegal:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	{ table:
\end_layout

\begin_layout Plain Layout

		{ schema: {name: string}, {gpa: float}}
\end_layout

\begin_layout Plain Layout

		{ students:
\end_layout

\begin_layout Plain Layout

			[
\end_layout

\begin_layout Plain Layout

				(Joe,    3.5),		# This is not valid JSON!
\end_layout

\begin_layout Plain Layout

				(Mary,   3.6),
\end_layout

\begin_layout Plain Layout

				(Rachel, 3.0)
\end_layout

\begin_layout Plain Layout

			]
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is this last example that makes clear that an s-expression store can
 offer the best of both worlds.
 This is shown in the next section.
\end_layout

\begin_layout Subsubsection*
OGRE: Open Generic Representation
\end_layout

\begin_layout Standard
A particularly nice and human-freindly API can be found in the OGRE module
 in BAP.
\begin_inset CommandInset citation
LatexCommand cite
key "OGRE"
literal "false"

\end_inset

 It is an s-expression database that allows new data structures to be defined
 in generic ways.
 In short, any s-expression is a valid record.
 Records do not need to be of the same length, or of the same type.
\end_layout

\begin_layout Standard
Thus, the previous example can be written as
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		(student (name Joe)    (gpa 3.5))
\end_layout

\begin_layout Plain Layout

		(student (name Mary)   (gpa 3.6))
\end_layout

\begin_layout Plain Layout

		(student (name Rachel) (gpa 3.0))
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Note that these are three distinct records, and are NOT a list of three
 rows!
\end_layout

\begin_layout Standard
As written, this has a distinctly JSON-ic feel to it, in that every value
 is tagged with the field type that names it.
 But then, the OGRE documentation notes that this is equivalent to 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		(student Joe    3.5)
\end_layout

\begin_layout Plain Layout

		(student Mary   3.6)
\end_layout

\begin_layout Plain Layout

		(student Rachel 3.0)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

provided that one already knows the column structure of the data.
 But this is easily acheived:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		(declare student (name str) (gpa float))
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

This last statement resembles a conventional table-database table declaration.
\end_layout

\begin_layout Standard
One can go farther: there is no particular need to tag each row with the
 row-label '
\family typewriter
student
\family default
'.
 The most compact representation then appears to be the following: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		(students-table
\end_layout

\begin_layout Plain Layout

			(Joe    3.5)
\end_layout

\begin_layout Plain Layout

			(Mary   3.6)
\end_layout

\begin_layout Plain Layout

			(Rachel 3.0))
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

This last form now obviously has the shape of a row-store.
 Each row is a tuple, all tuples look alike.
 
\end_layout

\begin_layout Standard
This last form enables a rather conventional SQL query system to be defined.
 There is a table definition, providing colum types, and column lables (the
 labels are needed for query/search), and the individual records (rows)
 in the table are uniform.
 The uniformity allows both for very compact storage and easy query.
\end_layout

\begin_layout Standard
The nature of query in these three styles, and what it implies for RAM consumpti
on and CPU use, is quite dramatic.
 They can have remarkably different performance profiles, and even some
 remarkable limitations in the kinds of queries that can be imagined or
 can be written.
 This is a more complex topic, and will be returned to later in this text.
\end_layout

\begin_layout Subsection*
Graphs for Storing Data
\end_layout

\begin_layout Standard
The above listed three ways of storing attributes on a graph, and yet seemed
 to ignore the graph itself.
 Thus, for completeness, lets draw the diagram of how this might be stored
 in a graph.
 
\end_layout

\begin_layout Standard
Obviously, its 
\begin_inset Quotes eld
\end_inset

graphical
\begin_inset Quotes erd
\end_inset

 if it is drawn as follows:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/joe-mary-v1.eps
	width 60col%

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In the above, the vertexes are labelled with s-expressions; the edges are
 not labelled.
 It consists of two disjoint graphs; one of the graphs is used to encode
 the type information used in the other graph.
 There are a large variety of choices that can be made in how this is done.
 The above just shows one way; it might not be the best way, although that
 depends on the problem domain.
 
\end_layout

\begin_layout Standard
Below shows another alternative, this time with labelled edges:
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace defskip
\end_inset


\begin_inset Graphics
	filename graphics/joe-mary-v2.eps
	width 35col%

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
As before, the graph explicitly includes a description of the schema used
 in another part of the graph.
 For the first time, a non-trivial graph is drawn.
 It begins to give a hint of the utility of graphs for general knowledge
 representation.
\end_layout

\begin_layout Subsubsection*
Mixed Repesentations
\end_layout

\begin_layout Standard
In both of the above examples, the graph store was assumed to have some
 distinct, separate attribute store for each vertex, and possibly each edge.
 Thus, in a sense, this is not a 
\begin_inset Quotes eld
\end_inset

pure
\begin_inset Quotes erd
\end_inset

 graph store, where each edge or vertex can only have an atomic singleton
 value on it (a single number or a single string).
 Of course, one could rework the above graphs so that each vertex/edge does
 have just one single value on it.
 While the simplicity of singleton-valued graphs is perhaps intellectually
 appealing, it proves to not be practical for everyday use.
 Assuming singleton-valued graphs also has some very strong implications
 on RAM and CPU use, and the ability to perform searches/queries.
 This point will be returned to below.
 In the meanwhile, this kind of mixed model will be assumed: some data will
 be stored graphically, and some data will be stored as complex attribute
 sets attached to the nodes and vertexes.
\end_layout

\begin_layout Standard
In the interim, some historical hand-waving can be done to justify the origins
 of a mixed-model graph store.
 In predicate logic, and in model theory, one distinguishes the predicates
 and terms that one is discussing, from the truth values or valuations that
 can be assigned to them.
 It is relatively straightforward to envision predicates and terms as trees
 or DAG's.
 The truth values are distinct from the graphs themselves; instead, they
 are an assignment of true/false to each expression.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Of course, this is but the grand leap from Aristotelian, 
\begin_inset Quotes eld
\end_inset

classical
\begin_inset Quotes erd
\end_inset

 logic, to predicate logic.
 The disentanglement of truth-valuations from propositions enables giant
 leaps in reasoning abilities.
 This in turn opens the ability to further disentangle syntactic from semantic
 entailment, thus allowing a connection to grammar and language to be made.
 The adjointness between grammar and graphs is precisely the core, central
 reason why properly constructed graph databases are central to the pursuit
 of AGI.
\end_layout

\end_inset

 A straight-forward example can be found in Prolog: in the beginning, there
 are expressions; by means of inference, truth-value labels are infered.
\end_layout

\begin_layout Standard
Of course, things get interesting as soon as one leaves the domain of crisp-logi
c T/F values, and considers instead valuations that are Bayesian probabilities.
 Some monkeying around then leads one to distinguish Bayesian probabilities
 from fuzzy logic valuations.
 Other kinds of data worms it's way in: confidence intervals; frequentist
 counts; marginals.
 Some of this data is non-numeric, but are choices (
\emph on
e.g.

\emph default
 true, false or unknown) or explicitly symbolic (
\emph on
e.g.

\emph default
 red, blue or green).
 It usually does not take long to realize the practical need for a mixed-model
 graph database, supporting both good graph features, and also supporting
 complex attribute systems attached to each node/vertex.
\end_layout

\begin_layout Section*
Representing Graphs in RAM
\end_layout

\begin_layout Standard
In what follows, all data is assumed to live in-RAM; the on-disk representations
 do not concern us.
 One reason for this is that a variety of disk management systems exist,
 and work quite well at abstracting details.
 The earliest such is perhaps the Berkeley DBM, and the Gnu gdbm.
 These have been followed by Google's LevelDB and Facebook's extensions
 RocksDB.
 It is usually not too hard to take an in-RAM database, and layer it on
 top of one of these systems to obtain a disk-backed database.
 Of course, there are numerous ifs-and-buts, which provide motivations to
 roll-your-own; these will be ignored in this text.
\end_layout

\begin_layout Subsubsection*
Naive RAM Representations
\end_layout

\begin_layout Standard
Storing a set of vertexes in RAM is straight-forward.
 Since it is a set, one can use either a hash-table, a b-tree, or even an
 array or list.
 For the discussion here, the precise format is not directly relevant, and
 so a tabular format will be used to illustrate the ideas.
 Again, the table rows might actually reside in hash-tables or b-trees,
 depending on desired access and update performance.
\end_layout

\begin_layout Standard
The vertex table is straight-forward:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The goal of having a vertex id (which is necessarily a 
\begin_inset Quotes eld
\end_inset

universally unique id
\begin_inset Quotes erd
\end_inset

 or uuid) is that it is required by the edge table.
 In the most obvious, direct form, the edge table will have the shape
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
head-vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tail-vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
77
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
88
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
99
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "graph edge table"

\end_inset


\end_layout

\begin_layout Standard
This representation is perhaps too naive.
 To perform a graph traversal, i.e.
 to walk from vertex to vertex, following only connecting edges, one needs
 to know which edges come in, and which edges go out.
 Of course, these can be found in the edge table, but searching the edge
 table is absurd: for an edge table of 
\begin_inset Formula $N$
\end_inset

 edges, such a search takes 
\begin_inset Formula $O\left(N\right)$
\end_inset

 time.
 Thus, it is natural to incorporate a special index for edges into the vertex
 table:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
outgoing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{77}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{77}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88,99}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "graph vertex table"

\end_inset


\end_layout

\begin_layout Standard
Note that the incoming and outgoing columns hold sets: any given vertex
 may appear in more than one edge.
 They are sets, not lists, as the order is not particularly important.
 They are not 'multisets': any given edge appears at most once in the incoming/o
utgoing sets.
 Suitable representations for sets include hash-tables and trees, each with
 it's own distinct RAM and access-time profile.
\end_layout

\begin_layout Standard
Table updates must be both thread safe and fast.
 It is easy to lock the table with a mutex, but this can quickly limit the
 amount of concurrency.
 The latest lock-free technology promises reasonable solutions; however,
 the technology remains immature.
 There are several implementations of concurrent hash maps, but none for
 concurrent multimaps (that also support erase).
 Likewise, lock-free tree implementations are absent; trees offer a considerably
 more compact storage format when tables are small.
\end_layout

\begin_layout Subsubsection*
Prelude to indexing
\end_layout

\begin_layout Standard
A conventional requirement for graph databases is to locate all nodes and
 vertexes having some particular attribute.
 This opens a Pandora's box of indexing schemes.
 The opening of this box is deferred to a later section, but we can take
 a quick peak: suppose one wants to find all vertexes where the attr-data
 has a field called 
\begin_inset Quotes eld
\end_inset

favorite song
\begin_inset Quotes erd
\end_inset

.
 Vertexes representing buildings and automobiles won't have a 
\begin_inset Quotes eld
\end_inset

favorite song
\begin_inset Quotes erd
\end_inset

, vertexes representing people might, but not necessarily.
 Thus, there is a need for an index: a set of all vertexes that have this
 tag.
 Every time a vertex is added or removed, this index might have to be updated.
 Thus, adding indexes in this way incurs a CPU overhead.
 If there are 
\begin_inset Formula $J$
\end_inset

 indexes, then there is an 
\begin_inset Formula $O\left(J\right)$
\end_inset

 CPU overhead for vertex insertion/removal.
 There is also RAM consumption: an index containing 
\begin_inset Formula $K$
\end_inset

 items requires at least 
\begin_inset Formula $O\left(K\right)$
\end_inset

 storage, and possibly 
\begin_inset Formula $O\left(K\log K\right)$
\end_inset

.
\end_layout

\begin_layout Section*
Hypergraphs
\end_layout

\begin_layout Standard
A hypergraph is much like a graph, except that the edges, now called 
\begin_inset Quotes eld
\end_inset

hyperedges
\begin_inset Quotes erd
\end_inset

 can contain more than two vertexes.
 That is, the hyperedge, rather than being an ordered pair of vertexes,
 is an ordered list of vertexes.
 The metagraph takes the hypergraph concept one step further: the hyperedge
 may also contain other hyperedges.
 A change of terminology is useful: the basic objects are now called 
\begin_inset Quotes eld
\end_inset

nodes
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

links
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

vertexes
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

edges
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Formally, a hypergraph is:
\end_layout

\begin_layout Itemize
A set of vertexes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of hyperedges 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each hyperedge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered list of vertexes drawn from the set 
\begin_inset Formula $V$
\end_inset

.
 This list may be empty, or have one, or two, or more members.
\end_layout

\begin_layout Standard
A metagraph is very nearly the same:
\end_layout

\begin_layout Itemize
A set of nodes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of links 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each hyperedge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered list of nodes, or other links, or a mixture.
 They are arranged to be acyclic (to form a directed acyclic graph).
\end_layout

\begin_layout Standard
It is convenient to give the name 
\begin_inset Quotes eld
\end_inset

atoms
\begin_inset Quotes erd
\end_inset

 to something that is either a node or a link.
 Links are thus sets of atoms.
\end_layout

\begin_layout Subsection*
Hypergraph representations
\end_layout

\begin_layout Standard
The naive representation for the hypergraph is a straight-forward extension
 of the edge table (the table 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "graph edge table"
plural "false"
caps "false"
noprefix "false"

\end_inset

 above).
 The table below provides an example that is shown in the figure following
 below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hyper-edge id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex-list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{1}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{1},v_{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{3},v_{4}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{3},v_{2},v_{1}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The vertex list may be empty, may hold one, or more vertexes.
 It is necessarily ordered (and thus not a set) and may contain repeated
 entries (a vertex may appear more than once in the list).
 In other respects, this edge table is quite similar to the edge table for
 ordinary graphs.
\end_layout

\begin_layout Standard
As before, the ability to traverse the hypergraph (quickly) is a core requiremen
t.
 This means that, given a vertex, one must be able to quickly find the edges
 attached to it.
 This requires modification to the vertex table given before.
 
\end_layout

\begin_layout Standard
Several choices are possible.
 One is to add a new column for each positional location in the vertex list.
 That is, 0'th column holds the edges which have the corresponding vertex
 in the 0'th position of the vertex list, the 1'th column likewise.
 This can be read off from the table above:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge-set-0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge-set-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge-set-2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
To actually store this table, one must have a data-structure that is a list-of-s
ets, which can be a bit over-complex and challenging to use.
 It is easier to just mash all of these into one set; that is all that is
 needed for hypergraph traversal.
 If the positional location is needed, then it can always be looked up per-hyper
edge.
 This is neither technically challenging nor CPU-intensive: the arity of
 hyperedges is typically small, based on real-world mappings with interesting
 datasets.
 Thus, the vertex table can take the simpler form
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming-set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "hyper vertex table"

\end_inset


\end_layout

\begin_layout Standard
Note that the vertex table looks a lot like the edge table, the only difference
 being that the vertex-list is an ordered list, while the incoming-set (the
 edge-set) really is a set.
 Effectively, this is because a hypergraph is 
\begin_inset Quotes eld
\end_inset

almost
\begin_inset Quotes erd
\end_inset

 a bipartite graph, having the form below, with the set 
\begin_inset Formula $E$
\end_inset

 on the left being the set of hyperedges.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/hypergraph.eps
	lyxscale 60
	width 40col%

\end_inset


\end_layout

\begin_layout Standard
The boxes denote the fact that the hyperedges are ordered lists.
 The 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $V$
\end_inset

 ellipses are the hyperedge and vertex tables.
 If the boxes could be collapsed to single points, this would be a 'true'
 bipratite graph; but they cannot be.
 The ordering is needed and important.
 
\end_layout

\begin_layout Subsubsection*
RAM Utilization
\end_layout

\begin_layout Standard
One might wish to conclude: 
\begin_inset Quotes eld
\end_inset

Oh, but a bipartite graph is just a graph, so a graph database is sufficient
 for all my needs.
\begin_inset Quotes erd
\end_inset

 At some abstract level, this is perhaps true; at the CPU and RAM-consumption
 level, it is not.
 So, in this figure, attributes (the attr-data) are attached only to the
 
\begin_inset Formula $v_{k}$
\end_inset

 and 
\begin_inset Formula $e_{k}$
\end_inset

 in the diagram; there is no attribute data attached to the lines in this
 figure.
 What's more, the lines in this figure are not directly recorded in any
 tables; they are implicit only in the structure of the vertex and hyperedge
 tables.
\end_layout

\begin_layout Standard
Counting the memory usage is instructive.
 Lets assume that the size of the vertex-id and the edge-id are the same
 – they are pointers or 64-bit ints – so each id requires 1 unit of RAM.
 Assume that lists are either null-terminated or record a length, so that
 a list of 
\begin_inset Formula $n$
\end_inset

 items requires 
\begin_inset Formula $n+1$
\end_inset

 units of storage.
 Lets encode sets as lists, to make counting easy; let 
\begin_inset Formula $\left\langle J\right\rangle $
\end_inset

 be the average size of the attribute collection.
 The hyperedges shown in the example figure then require 2+3+3+4=12 units
 of storage, plus 5 more for the hyperedge table itself, and 
\begin_inset Formula $4\left\langle J\right\rangle $
\end_inset

 of attribute storage.
 The vertexes require 4+3+3+2 units of storage, plus 5 for the vertex-table
 itself, plus 
\begin_inset Formula $4\left\langle J\right\rangle $
\end_inset

 more of attributes.
 Summing this, one obtains 
\begin_inset Formula $34+8\left\langle J\right\rangle $
\end_inset

 total RAM consumption.
\end_layout

\begin_layout Standard
For the general case, one has
\begin_inset Formula 
\[
N_{V}\left(1+\left\langle J\right\rangle +\left\langle N_{I}\right\rangle \right)+N_{E}\left(1+\left\langle J\right\rangle +\left\langle N_{O}\right\rangle \right)
\]

\end_inset

 where
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N_{V}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of vertexes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N_{E}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of hyperedges
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\langle J\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average size of attributes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average size of the incoming set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\langle N_{O}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average size of the vertex list
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The average count of the incoming set is equal to the average count of the
 vertex list, so we can approximate 
\begin_inset Formula $\left\langle N_{I}\right\rangle =\left\langle N_{O}\right\rangle $
\end_inset

; the only reason to track these separately is that one may use hash tables
 or trees for sets, whereas lists require arrays.
 This makes the RAM usage slightly different for the two.
\end_layout

\begin_layout Standard
The equivalent representation as a graph requires
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\left(N_{V}+N_{E}\right)\left(1+\left\langle J\right\rangle \right)+N_{V}\left\langle N_{I}\right\rangle +N_{E}\left\langle N_{O}\right\rangle  & \quad\mbox{ for the vertex table}\\
N_{V}\left\langle N_{I}\right\rangle \left(3+\left\langle J_{nil}\right\rangle \right) & \quad\mbox{ for the edge table}
\end{align*}

\end_inset

Comparing the this to the expression for the hypertable, we see that the
 vertex table is the same size as the entire hypertable.
 The ordinary graph representation also requires the overhead of the edge
 table; here the 
\begin_inset Formula $\left\langle J_{nil}\right\rangle $
\end_inset

 is the cost of storing an empty attribute list, and the factor of 3 comes
 from storing an ordinary edge-id and it's two endpoints.
 Graph databases can store hypergraphs, but incur a RAM penalty for doing
 so.
\end_layout

\begin_layout Subsubsection*
Storing hypergraphs in graphs, and vice-versa
\end_layout

\begin_layout Standard
If the only thing that one is storing are hypergraphs, then having a custom
 hypergraph representation really is smaller than the equivalent bipartite
 graph: it dispenses with the need for an explicit ordinary-edge table.
 Does this mean that there's some magic, here? No, not really.
 Every ordinary graph is a special case of a hypergraph, where the hyper-edge
 always has arity two.
 To use an ordinary graph store to record a single edge, we need 
\begin_inset Formula $3+\left\langle J\right\rangle $
\end_inset

 units of storage: the edge-label, and the two vertexes in the edge.
 To use a hyperedge store to record a single (ordinary) edge, we need 
\begin_inset Formula $4+\left\langle J\right\rangle $
\end_inset

 units of storage: the edge-label, the list of vertexes, and the list terminator.
 Thus, storing an ordinary graph as a hypergraph requires 
\begin_inset Formula $N_{E}$
\end_inset

 more units of storage.
 This seems tolerable: for a million-edge graph, and 64-bit pointers, this
 requires 8MBytes of additional storage.
 On modern machines, the extra 8MBytes seems not all that large.
 There's a bit of a penalty in moving from graph storage to hypergraph storage,
 but it's not that much.
 Modern cellphones have 8GBytes of RAM...
\end_layout

\begin_layout Standard
Moving in the opposite direction is much worse: the penalty is 
\begin_inset Formula $N_{V}\left\langle N_{I}\right\rangle \left(3+\left\langle J_{nil}\right\rangle \right)$
\end_inset

 which is surprisingly large.
 Assuming that 
\begin_inset Formula $\left\langle J_{nil}\right\rangle =1$
\end_inset

, then a million-vertex graph requires 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 times 32MBytes of additional storage.
 For uniformly-distributed graphs, one might have 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 of 3 to 10; for scale-free graphs of this size, 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 might be around 14; for square-root-Zipfian graphs (such as Wikipedia page
 views, or biological datasets: genome, proteome, reactome datasets) the
 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 would be around 200
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The average size of the incoming set is 
\begin_inset Formula 
\[
\left\langle N_{I}\right\rangle =\frac{1}{N_{V}}\int_{1}^{N_{V}}n\left(v\right)dv
\]

\end_inset

where 
\begin_inset Formula $n\left(v\right)$
\end_inset

 is the number of connections to vertex 
\begin_inset Formula $v$
\end_inset

 and 
\begin_inset Formula $N_{V}$
\end_inset

 is the total number of vertexes.
 For a Zipfian distribution, this is
\begin_inset Formula 
\[
\left\langle N_{I}\right\rangle =\frac{1}{N_{V}}\int_{1}^{N_{V}}\frac{N_{V}}{v}dv=\log N_{V}
\]

\end_inset

while for a square-root-Zipfian, one has 
\begin_inset Formula 
\[
\left\langle N_{I}\right\rangle =\frac{1}{N_{V}}\int_{1}^{N_{V}}\frac{AN_{V}}{\sqrt{v}}dv=2A\sqrt{N_{V}}
\]

\end_inset

The scale factor 
\begin_inset Formula $A$
\end_inset

 is data-dependent.
 For Wikipedia page views, 
\begin_inset Formula $A\approx20$
\end_inset

, see https://en.wikipedia.org/wiki/Wikipedia:Does_Wikipedia_traffic_obey_Zipf%27s
_law%3F for graphs and discussion.
 For genomics, see https://github.com/linas/biome-distribution/blob/master/paper/
biome-distributions.pdf where 
\begin_inset Formula $A$
\end_inset

 is in the range of 0.1 to 0.3, depending on the dataset.
 These last estimates are a bit glib, as the specifics of the datasets are
 quite subtle.
 Still, one may conclude that these considerations have quite dramatic implicati
ons for graph stores.
\end_layout

\end_inset

, so we are looking at overheads in the gigabyte range.
 There is a huge cost of jamming a hypergraph into an ordinary graph store.
\end_layout

\begin_layout Standard
XXX TODO This is making some rather strong claims about RAM usage, and really
 needs to be quadruple-checked and strengthened.
 It's a bit breezy and casual, as written.
 XXX TODO.
\end_layout

\begin_layout Subsection*
Metagraph representations
\end_layout

\begin_layout Standard
The metagraph differs from the hypergraph in that now a hyperedge (link)
 may contain either another vertex (node) or another link.
 Visually, this is no longer a bipartite graph, but has the shape of a directed
 acyclic graph (DAG), such as the one shown below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/metagraph.eps
	lyxscale 60
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
The primary difference between the above, and a 'true DAG' is that the links
 are ordered lists, represented as boxes in this diagram.
 For lack of a better name, this can be called a 
\begin_inset Quotes eld
\end_inset

metatree
\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Later on, metatrees will be called 
\begin_inset Quotes eld
\end_inset

Atoms
\begin_inset Quotes erd
\end_inset

.
 An Atom is simply a term for something that can be either a 
\begin_inset Quotes eld
\end_inset

Node
\begin_inset Quotes erd
\end_inset

 or a 
\begin_inset Quotes eld
\end_inset

Link
\begin_inset Quotes erd
\end_inset

.
 As we haven't yet clearly defined a Nod or Link yet, the term 
\begin_inset Quotes eld
\end_inset

metatree
\begin_inset Quotes erd
\end_inset

 will suffice.
\end_layout

\end_inset

 (later on, metatrees will be called 
\begin_inset Quotes eld
\end_inset

Atoms
\begin_inset Quotes erd
\end_inset

.) The metatree can be converted to a DAG in two different ways.
 One way is to collapse the boxes to single points.
 The other way is to dissolve the boxes entirely, and replace a single arrow
 from point-to-box by many arrows, from point to each of the box elements.
\end_layout

\begin_layout Standard
The node table for a metagraph is effectively the same as the vertex table
 for the hypergraph (
\begin_inset CommandInset ref
LatexCommand vpageref
reference "hyper vertex table"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for the hypergraph, before.
 For this graph, it was
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
node id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming-set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{3}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "metagraph node table"

\end_inset


\end_layout

\begin_layout Standard
The link table now requires both an outgoing-atom list, and an incoming-link
 set.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
link id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
outgoing-list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming-set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(n_{1},n_{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(n_{2},n_{3}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(e_{1},e_{2},n_{1},e_{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(e_{3},n_{3}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "metagraph link table"

\end_inset


\end_layout

\begin_layout Standard
Notice how this link-table resembles the vertex-table (
\begin_inset CommandInset ref
LatexCommand vpageref
reference "graph vertex table"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of an ordinary graph store.
 It has both 'incoming' and 'outgoing' sets, as before.
 There are two differences: the outgoing set is no longer a set, but a list.
 The other is even stranger: the first column (the column of vertexes) has
 been replaced by a columnn of links!
\end_layout

\begin_layout Standard
Perhaps we making the wrong comparison? Oddly, it also resembles the edge
 table (
\begin_inset CommandInset ref
LatexCommand vpageref
reference "graph edge table"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For ordinary directed graphs, each edge is a vertex pair.
 The vertecies of an edge may be termed the 'head vertex' and the 'tail
 vertex'; equivalently, the outgoing vertex and the incoming vertex (or
 
\emph on
vice-versa
\emph default
, depending on how one envisions the arrows).
 These two endpoints are replaced by the incoming set and the outgoing list.
 Now, the first column remains the same: a column of edges, in both cases.
 The overall four-column form remains the same.
\end_layout

\begin_layout Standard
Looking at this table, one might imagine that the naive graph tables, the
 hypergraph tables, and the metagraph tables seem to have much in common.
 This is, however, perhaps a bit deceptive, as performance considerations
 dictate the finer aspects of the design.
 This will be looked at next.
\end_layout

\begin_layout Standard
Clearly, the metagraph, having the general shape of a DAG, can be wedged
 into an ordinary graph store.
 Conversely, an ordinary graph is merely a metagraph that never goes more
 than one-level deep, and whose links always have arity-two.
 Either format is adequate for representing the other.
 The metagraph, much like the hypergraph, has no need to explicitly declare
 the arrows in the tree; they are not stored, nor do they have attributes.
 The RAM-usage considerations are much like those for the hypergraph.
 We can conclude that it is quite efficient to store a graph in a metagraph,
 but that storing a metagraph in an ordinary graph database pays a large
 penalty.
\end_layout

\begin_layout Section*
Indexing
\end_layout

\begin_layout Standard
More interesting is the structure of indexes, or rather, the alternatives
 one has for index representation.
 The whole point of using a graph database, as opposed to a collection of
 tables, or key-value database, or a JSON-database is that the graph structure
 encodes something important about the problem, something that cannot be
 easily achieved by doing table joins or key-value look-ups.
 Some examples of 
\begin_inset Quotes eld
\end_inset

difficult
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

impossible
\begin_inset Quotes erd
\end_inset

 queries will be looked at in a later section.
\end_layout

\begin_layout Standard
It is worth remarking that the so-called noSQL databases are effectively
 'identical' to SQL databases.
 They are 'identical' in the sense of being categorical opposites: the direction
s of all arrows are reversed.
 This was explicitly articulated in a famous paper by Meijer and Bierman.
\begin_inset CommandInset citation
LatexCommand cite
key "Meijer2011"
literal "false"

\end_inset

 Much of the following uses an SQL-style notation; if the reader is more
 familiar with key-value databases, then simply reverse the directions of
 all arrows to obtain the equivalent discussion.
\end_layout

\begin_layout Standard
A few comments are in order regarding the SQL-style query notation.
 It has become dominant.
 One can look at systems as different as SparQL and GraphQL, or even the
 OGRE query langauge
\begin_inset CommandInset citation
LatexCommand cite
key "OGRE"
literal "false"

\end_inset

 (
\emph on
op.
 cit.
\emph default
) and clearly see not just the influence of SQL, but in fact a nearly verbatim
 copy of it.
 There is a reason for this dominance, and it is not (just) history.
 The reason is anchored (once again) in table representations, and the presence
 (or rather, lack thereof) of inbuilt indexes in the tables.
 
\end_layout

\begin_layout Standard
This is also the place to make a heretical claim: SQL or it's variants (GraphQL,
 SparQL...) are 
\emph on
NOT
\emph default
 the best choice for a metagraph query language.
 A better alternative will become clear, once a more careful examination
 is made of the role of indexes in queries.
\end_layout

\begin_layout Standard
However, in a hypergraph database, just as in a table-based database, there
 will be certain types of queries that are used a lot, and speeding these
 up through indexing is a key ability.
 How might this work, in practice? Let's examine some queries, and see how
 they might work.
\end_layout

\begin_layout Subsection*
Single attribute queries
\end_layout

\begin_layout Standard
Suppose one wishes to find all nodes with some specific attribute.
 Naively, this requires walking over all nodes, examining the attached attribute
 structure, extracting a named field from the attributes, and examining
 the value of that field.
 This is a task that SQL databases excel at - for example, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT name,salary FROM employees WHERE department='sales';
\family default
\emph default

\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The author would like to apologize for this seemingly non-sexy example.
 It is the stereotypical example from database textbooks, and harks back
 to the 1960's, when working out the fine details of management science
 actually was a sexy research topic, and helped power the economic ascent
 of the Western world.
 It's importance should not be under-estimated: Ancient Rome was an agrarian
 civilization built on concepts of hierarchical organization; organizational
 hierarchies will continue to describe reality, including AGI.
 Org-charts are boring but important.
\end_layout

\end_inset

 A graph database is not needed for this task.
 Nonetheless, this is a plausible task, even for a graph database.
 The traditional solution would be 
\begin_inset Quotes eld
\end_inset


\family sans
CREATE INDEX ON employees(department);
\family default

\begin_inset Quotes erd
\end_inset

 which results in the creation of ordered pairs 
\begin_inset Formula $\left(D,\left\{ R\right\} \right)$
\end_inset

 with 
\begin_inset Formula $D$
\end_inset

 the name of the department, and 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

 the set of all records having that value.
 The 
\family typewriter
\emph on
SELECT
\family default
\emph default
 is then straight-forward: given 
\begin_inset Formula $D$
\end_inset

, it need only return 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

.
 The size of this index is 
\begin_inset Formula $O\left(N\right)$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the number of employees.
 This is necessarily so: one cannot build an index smaller than the number
 of employees: every employee must be in some department, as, conventionally,
 table-driven databases don't have null entries in rows.
 (Well, in practice, they often do; but now imagine the task of finding
 all records with a null value in some column...) Table-based information also
 has some representational difficulties: imagine the case of an employee
 with dashed-line reporting to multiple departments.
\end_layout

\begin_layout Standard
How might one accomplish indexing like this in a graph database? The simplest,
 most naive answer is to create new, 
\begin_inset Quotes eld
\end_inset

privileged
\begin_inset Quotes erd
\end_inset

 vertexes, one vertex per department.
 They are 
\begin_inset Quotes eld
\end_inset

privileged
\begin_inset Quotes erd
\end_inset

, in that the associated attributes record one and only one value: the name
 of the department.
 Basically, the vertexes are labeled, thus escaping the overhead of crawling
 through a collection of attributes to find one in particular.
 One also created an unlabeled, attribute-free edge, from the department
 name back to the full employee record.
 Finding all employees in 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 is fast: one searches the vertex table (
\begin_inset CommandInset ref
LatexCommand vpageref
reference "graph vertex table"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to find the vertex 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

, and then trace all outgoing edges to the full record.
 The graph can be thought of as a table with a special 
\begin_inset Quotes eld
\end_inset

built in
\begin_inset Quotes erd
\end_inset

 index: the index of outgoing edges.
\end_layout

\begin_layout Standard
This is to be contrasted to a conventional table database.
 The contents of a conventional table (row) database, after indexing, is
 illustrated below.
 Before indexing, the vertexes 
\begin_inset Formula $v_{6},v_{7},v_{8}$
\end_inset

 and edges 
\begin_inset Formula $e_{1},e_{2},e_{3},e_{4},e_{5}$
\end_inset

 simply did not exist.
 The act of indexing creates these vertexes and edges.
 The documentation for convetional table databases does not 'talk about'
 vertexes and edges; but, 
\emph on
de facto
\emph default
, this is how system arhictects think about things.
 When they think about creating an index on a table, this is what they think
 of.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is not meant to be a psychological assessment; rather it is meant to
 provide a translation between the 'algebraic' form of typed commands sent
 to relational DB's, and an equivalent 'geometric', visual form.
 The geometric form can be understood as being either metaphorical and abstract,
 or it can be taken literally, as a collection of pointers and the things
 they point to.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/partial-index.eps
	width 75col%

\end_inset


\end_layout

\begin_layout Standard
The size of this structure is again 
\begin_inset Formula $O\left(N\right)$
\end_inset

 for 
\begin_inset Formula $N$
\end_inset

 employees, assuming every employee is indexed.
 More precisely, it is 
\begin_inset Formula $O\left(N\right)+O\left(N_{D}\right)$
\end_inset

 where 
\begin_inset Formula $N_{D}$
\end_inset

 is the number of departments.
\end_layout

\begin_layout Standard
This diagram exposes some unusual possibilities: If one is interested only
 in sales, then not every employee has to be indexed! In a graph database,
 it is possible to create only one vertex, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

, and hook up edges to only that one.
 Effectively, this is a partial index, with correspondingly less RAM usage!
 This is not possible in a naive table system; one needs a system which
 explicitly supports partial indexes.
 As it happens, most-all SQL systems do.
 An experienced SQL DBA knows exactly how to achieve this effect: 
\begin_inset Quotes eld
\end_inset


\family sans
CREATE INDEX ON employees(department) WHERE department=sales;
\family default

\begin_inset Quotes erd
\end_inset

 This is not a big deal, and so, here, at least, graphs do not offer any
 particular advantage, other than perhaps some conceptual clarity.
 Under the covers, the SQL databases effectively have more-or-less the same
 format, although their internal graph-based nature is 
\emph on
ad hoc
\emph default
, evolved over the decades and mostly hidden from the user.
 There are no explicit graph-walking directives in SQL.
\end_layout

\begin_layout Standard
The key point here is that, in a properly-designed graph database, there
 is no generic need for 
\begin_inset Quotes eld
\end_inset

indexes
\begin_inset Quotes erd
\end_inset

 
\emph on
per se
\emph default
, they can be conjured into being at any time, as they are ultimately graphical
 in nature.
 There's even a bit of an advantage: in the graph database, the graph structure
 of the index is explicit, and can be walked.
\end_layout

\begin_layout Subsection*
Space and Time
\end_layout

\begin_layout Standard
Comparing RAM-usage, at first glance, there is no particular difference
 between the SQL and the graph database.
 Naively, both require 
\begin_inset Formula $O\left(N\right)$
\end_inset

 for 
\begin_inset Formula $N$
\end_inset

 employees, plus 
\begin_inset Formula $O\left(N_{D}\right)$
\end_inset

 for 
\begin_inset Formula $N_{D}$
\end_inset

 different departments.
 Looking more carefully, there are also the edges 
\begin_inset Formula $e_{1},e_{2},e_{3},e_{4},e_{5}$
\end_inset

.
 In the SQL case, these edges were implicit in the index: after all, the
 index was a collection of ordered pairs 
\begin_inset Formula $\left(D,\left\{ R\right\} \right)$
\end_inset

: the edges run from 
\begin_inset Formula $D$
\end_inset

 to 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

.
 In the graph representation, these edges become explicit: that is, they
 appear in an explicit table, with attached attributes, even if the attributes
 are null.
 Shades of hypergraphs! Why, this was exactly the 
\emph on
same
\emph default
 situation as with the hypergraph! Squinting more carefully, the indexed
 employee table is nothing other than a bipartite graph! Thus, one can effective
ly say: the indexes in an SQL database are 
\emph on
de facto
\emph default
 hypergraphs under the covers, even though no one ever explicitly says so.
 The bipartite nature of the graph makes this overt.
 Surprise!
\end_layout

\begin_layout Standard
The explicit hypergraph representation does cost more than its implicit
 form SQL databases.
 An SQL index can be a b-tree or hash table; the only thing that the b-tree/hash
 table needs to store is the row ID.
 For a hypergraph, we have imposed the additional requirement that hypergraphs
 must be rapidly traversible.
 This forces the storage of the incoming set in addition to the outgoing
 set.
 Hypergraph stores necessarily use more RAM than equivalent SQL tables.
 But recall why we did this: rapid graph traversal.
 Graph traversal in SQL is easy for trivial graphs, but becomes profoundly
 challenging for anything more complex.
 Mashing up 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT INTO
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 with 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
JOIN
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 is tough.
 Mashing it up two levels deep is tougher.
 Can you count to three? It would be a significant challenge, even for experienc
ed DBAs.
 Some more examples of challenging queries will be presetned later.
\end_layout

\begin_layout Standard
Suppose you are clever enough to write deep table joins in SQL.
 Is your query planner as clever as you? Most SQL systems have a query analyzer
 or query compiler, which takes a given SQL statement, analyzes it's structure,
 and then creates a plan as to which data shall be fetched first, and in
 what order.
 Poor planning results in poor performance, sometimes disasterously poor
 performance.
 For large databases, there has been a vast (multi-billion-dollar) investment
 in sophisticated query planning.
 Walking graphs, represented in terms of tables, is not for the faint of
 heart.
\end_layout

\begin_layout Standard
CPU usage considerations are harder to dissect.
 To avoid discussions of network overhead in client-server architectures,
 its easier, here, to limit discussions to databases that run in the same
 address space as the application.
 Thus, for SQL bench-marking, one might look at SQLite, which runs embedded,
 rather than Postgres, which requires network interfaces.
 Queries usually begin life as text-strings, for example, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT name,salary FROM employees WHERE department='sales';
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 was a text-string that had to be parsed to figure out 
\begin_inset Quotes eld
\end_inset

what to do
\begin_inset Quotes erd
\end_inset

.
 Let's assume that this cost has been amortized, and that there is a way
 to get a handle to a query that has already been analyzed.
 Query run-time execution is then a matter of finding the vertex 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

, tracing the edges to each of the employees, and completing the work by
 extracting fields for each employee.
 If vertexes themselves are indexed (as they should be), then locating the
 vertex 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 is either 
\begin_inset Formula $O\left(1\right)$
\end_inset

 for hash tables, or 
\begin_inset Formula $O\left(\log N_{D}\right)$
\end_inset

 for trees.
 In the hypergraph representation, finding the set 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

 of employees in 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 comes for free.
 The dominant cost is almost surely the analysis needed to extract the desired
 information from the record attributes.
\end_layout

\begin_layout Subsection*
Partial indexes and metagraphs
\end_layout

\begin_layout Standard
The power of partial indexes together with metagraphs begins to reveal itself
 when one considers query and search query optimization.
 This text is long enough, so this will be deferred to a later chapter.
\end_layout

\begin_layout Standard
Partial indexes reveal their utility in another way.
 Sticking with the management example from above, consider extending and
 looking at organizational structures (org charts).
\end_layout

\begin_layout Standard
Conventionally, corporations, political and military organizations are organized
 hierarchically, with divisions reporting to executives, departments rolling
 up into divisions, and so on.
 This is precisely the structure of a metatree.
 It is tempting to gloss this, and say that the org chart is a tree, or
 perhaps a DAG.
 It is not! It is a metatree, and confusion arises because a metatree can
 be collapsed to a DAG in several different ways.
 So, consider a division chief who manages a line item.
 One can draw the org-chart several ways: by drawing an edge from a manager
 to each (named) employee that they manage, or from the manager to a functional
 box labeled with the function.
 Employees are then grouped inside these functional boxes.
 This is shown below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/org-chart.eps
	lyxscale 70
	width 30col%

\end_inset


\end_layout

\begin_layout Standard
This is manifestly in the shape of a metatree.
 It can be collapsed down to an ordinary directed tree in several ways,
 left to the imagination of the reader.
 The point is that the natural structure of an org chart is not a naive
 tree; it contains a bit more complexity than that, and is far more readily
 represented with a metatree.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is hardly the only way to represent an org-chart with a meta-tree.
 One could put the department titles into boxes of their own, as well as
 perhaps the names of the actual people, adding even some dashed-line cross-func
tional reporting structures.
 The point here is that it is not 
\begin_inset Quotes eld
\end_inset

just a tree
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The conceptual jump here is then: rather than stopping with a single-level
 hypergraph, which had 
\begin_inset Quotes eld
\end_inset

tables
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

indexes
\begin_inset Quotes erd
\end_inset

 that were 
\begin_inset Quotes eld
\end_inset

on top of tables
\begin_inset Quotes erd
\end_inset

, one can go further: indexes of indexes: namely, the metagraph.
\end_layout

\begin_layout Subsection*
Normalization
\end_layout

\begin_layout Standard
The implication for RAM usage is similar to that of 
\begin_inset Quotes eld
\end_inset

database normalization
\begin_inset Quotes erd
\end_inset

.
 In a naive, un-normalized table format, one might store, for each employee,
 the employee name, the department, the 2nd line, the division and the name
 of the company.
 This is a bit silly in terms of storage: 5 columns are needed; for 
\begin_inset Formula $N$
\end_inset

 employees, this requires 
\begin_inset Formula $O\left(5N\right)$
\end_inset

 storage.
 One 
\begin_inset Quotes eld
\end_inset

normalizes
\begin_inset Quotes erd
\end_inset

 by storing only the employee-department relationship with a table of 
\begin_inset Formula $O\left(2N\right)$
\end_inset

 in size, and the remainder of the org chart in a separate table, also of
 two columns, encoding the directed tree reporting structure.
 This offers a huge space savings.
 For 
\begin_inset Formula $N_{D}$
\end_inset

 departments/divisions, this second table is 
\begin_inset Formula $O\left(2N_{D}\right)$
\end_inset

 and clearly, 
\begin_inset Formula $O\left(5N\right)\gg O\left(2N\right)+O\left(2N_{D}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Look-ups in a normalized database proceed through table joins.
 To find all employees in a division, one looks up what 2nd lines report
 to the division, what departments report to the second line, and what employees
 report to the departments (this is the 'transitive closure' of a recursive
 relation.) The indexing proceeds just as described before.
 The table joins are an 
\emph on
ad hoc
\emph default
 graph walk.
 The SQL for this is a bit nasty, but still effectively human-readable:
 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT employees.name FROM employees, orgchart WHERE employees.department
 = orgchart.dept AND orgchart.division = 'marketing & sales';
\family default
\emph default

\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Its nasty, because we have to 
\begin_inset Quotes eld
\end_inset

join
\begin_inset Quotes erd
\end_inset

 different rows in the org chart table.
 SQL does not offer any basic primitives for joining different rows together;
 this requires a good bit of creativity on the part of the DBA.
\end_layout

\end_inset

 This SQL snippet is oversimplified by quite a bit, but it does convey the
 general spirit of the thing.
 It is attempting to specify a graph-walk without explicitly acknowledging
 that there is a graph hidden under the covers.
\end_layout

\begin_layout Standard
The key message here is that metagraphs retain the key benefits of table
 normalization, while making the graphical nature of indexing explicit.
 They do even more: they effectively 
\begin_inset Quotes eld
\end_inset

automate
\begin_inset Quotes erd
\end_inset

 table normalization.
 To some fairly large degree, you no longer have to explicitly think about
 table normalization.
 It 
\begin_inset Quotes eld
\end_inset

just happens naturally
\begin_inset Quotes erd
\end_inset

, as you organize data into graphical form.
 This is not because there is some super-clever algo running under the covers,
 performing magic normalization.
 It is instead purely a byproduct of changing one's perspective about data
 and it's structure.
\end_layout

\begin_layout Standard
Comparing metagraphs to graph stores, one sees a different improvement.
 By discarding the edge table (
\begin_inset CommandInset ref
LatexCommand vpageref
reference "graph edge table"
plural "false"
caps "false"
noprefix "false"

\end_inset

) (that the graph store demands), and the associated edge attributes, one
 gets the representational compactness of indexes, without paying a high
 price for them.
 The price one does pay (the incoming set of the metagraph link table 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "metagraph link table"
plural "false"
caps "false"
noprefix "false"

\end_inset

) enables something quite dramatic: an easy graph walk, which is anything-but-ea
sy in a traditional SQL database.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
OK, sure, it becomes 
\begin_inset Quotes eld
\end_inset

easy
\begin_inset Quotes erd
\end_inset

 if you are willing to write PL/SQL, or, if your database supports it, then
 embedded Python.
 Otherwise, you have to descend into C/C++ (or your other favorite programming
 language of choice), and once you are 
\begin_inset Quotes eld
\end_inset

programming
\begin_inset Quotes erd
\end_inset

, it is no longer 
\begin_inset Quotes eld
\end_inset

easy
\begin_inset Quotes erd
\end_inset

.
 A properly designed graph query system makes graph walks 
\begin_inset Quotes eld
\end_inset

easy
\begin_inset Quotes erd
\end_inset

.
 And, to take one quick pot-shot: GraphQL is not properly designed.
 It is effectively a query anti-pattern.
 It took what is nice about SQL, but then utterly failed to take into account
 anything and everything that this text is trying to explain.
 It is not for nothing that the OpenCog AtomSpace differs so dramatically
 from everything else out there.
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Metatrees and String Representations
\end_layout

\begin_layout Standard
The proper way of representing a meta-tree as a text string can be mildly
 confusing.
 Articulating this carefully is rewarding.
 Consider again the generic example:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/metagraph.eps
	lyxscale 60
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
This can be written as 
\begin_inset Formula $\left(e_{4}:\left(e_{3}:\left(e_{1}:n_{1},n_{2}\right),\left(e_{2}:n_{2},n_{3}\right),n_{1},\left(e_{2}:n_{2},n_{3}\right)\right),n_{3}\right)$
\end_inset

 or perhaps, with indentation, but without parenthesis, so as to improve
 readability (so, Python-style, 
\emph on
i.e.

\emph default
 with 
\begin_inset Quotes eld
\end_inset

significant whitespace
\begin_inset Quotes erd
\end_inset

): 
\begin_inset Formula 
\[
\begin{array}{cccc}
e_{4}: & e_{3}: & e_{1}: & n_{1}\\
 &  &  & n_{2}\\
 &  & e_{2}: & n_{2}\\
 &  &  & n_{3}\\
 &  & n_{1}\\
 &  & e_{2}: & n_{2}\\
 &  &  & n_{3}\\
 & n_{3}
\end{array}
\]

\end_inset

Alternately, in Unix directory style (URLs), with slashes.
 Each 
\begin_inset Formula $e_{k}$
\end_inset

 and its trailing slash denotes a subdirectory.
 Each 
\begin_inset Formula $n_{k}$
\end_inset

 denoting a file: the terminal leaf in the tree.
 Observe that the same file appears in multiple locations in the directory
 tree.
 This is accomplished with either hard or soft links ('
\family typewriter
man ln
\family default
').
 It is somewhat uncommon for ordinary users to do this, but is a widespread
 technique used in package installs.
\begin_inset Formula 
\[
\begin{array}{cccc}
e_{4}/ & e_{3}/ & e_{1}/ & n_{1}\\
 &  &  & n_{2}\\
 &  & e_{2}/ & n_{2}\\
 &  &  & n_{3}\\
 &  & n_{1}\\
 &  & e_{2}/ & n_{2}\\
 &  &  & n_{3}\\
 & n_{3}
\end{array}
\]

\end_inset

Either of these requires understanding indentation.
 Yuck.
 This is still hard to read.
 Perhaps JSON will do:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Link: {
\end_layout

\begin_layout Plain Layout

			Link: {
\end_layout

\begin_layout Plain Layout

				Link: {
\end_layout

\begin_layout Plain Layout

					Node: 
\begin_inset Quotes eld
\end_inset

one
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Plain Layout

					Node: 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

				},
\end_layout

\begin_layout Plain Layout

				Link: {
\end_layout

\begin_layout Plain Layout

					Node: 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Plain Layout

					Node: 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

				},
\end_layout

\begin_layout Plain Layout

				Node: 
\begin_inset Quotes eld
\end_inset

one
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Plain Layout

				Link: {
\end_layout

\begin_layout Plain Layout

					Node: 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Plain Layout

					Node: 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			Node: 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset

Better, but still a bit awkward.
 Perhaps all the links can be replaced with square brackets, so an array
 of arrays? Doing this will convert the JSON into funny-looking s-expression.
 This will be presented shortly, below; in the meantime, it is left to the
 reader's imagination.
\end_layout

\begin_layout Standard
A strange thing has happened here: the nodes 
\begin_inset Formula $n_{1},n_{2}$
\end_inset

 and 
\begin_inset Formula $n_{3}$
\end_inset

 appear in multiple places, yet they are supposed to be 
\begin_inset Quotes eld
\end_inset

the same thing
\begin_inset Quotes erd
\end_inset

.
 Likewise for 
\begin_inset Formula $e_{2}$
\end_inset

, which appears twice, but is meant to be the same 
\begin_inset Formula $e_{2}$
\end_inset

 both times.
\end_layout

\begin_layout Standard
Consider representing the metatree with JSON (or something similar, 
\emph on
e.g.

\emph default
 YAML) The duplication presents a difficulty for JSON.
 Ordinary JSON does not support object references; there is no way to say
 the multiple 
\begin_inset Formula $e_{2}$
\end_inset

's and the 
\begin_inset Formula $n_{k}$
\end_inset

's are 
\begin_inset Quotes eld
\end_inset

the same thing
\begin_inset Quotes erd
\end_inset

.
 There is an IETF draft standard for references, but it is not widely used.
 Thus, although metatrees can be represented with JSON, some care must be
 taken when parsing them: one must find all repeated objects and understand
 them to be universally unique.
 That is, one must replace all repeated objects by universally unique references.
\end_layout

\begin_layout Subsection*
S-expressions
\end_layout

\begin_layout Standard
Let return to the string expression 
\begin_inset Formula $\left(e_{4}:\left(e_{3}:\left(e_{1}:n_{1},n_{2}\right),\left(e_{2}:n_{2},n_{3}\right),n_{1},\left(e_{2}:n_{2},n_{3}\right)\right),n_{3}\right)$
\end_inset

.
 What's wrong with just writing it as a basic s-expression? It appears to
 be entirely unambiguous to just drop the colon and the comma.
 It becomes:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(e4 (e3 (e1 n1 n2) (e2 n2 n3) n1 (e2 n2 n3)) n3)
\end_layout

\end_inset

Can't get any shorter than that.
 
\end_layout

\begin_layout Standard
This is not exactly an 'ordinary' s-expression, though.
 Key differences:
\end_layout

\begin_layout Itemize
Every open-paren must be followed by a link '
\family typewriter
ek
\family default
': this is what a meta-edge must necessarily be.
\end_layout

\begin_layout Itemize
Every node is globally unique.
 That is, each time the node '
\family typewriter
n
\family default
2' appears in this expression, it is exactly the same '
\family typewriter
n
\family default
2', instead of being a different instance.
 Refering back to the metagraph node table (
\begin_inset CommandInset ref
LatexCommand vpageref
reference "metagraph node table"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we see that there is only one true instance of '
\family typewriter
n
\family default
2': it just has one set of attributes on it.
 When parsing the s-expression, whichever apparent copy of '
\family typewriter
n
\family default
2' that we grab hold of, the attributes attached to it will be the same.
\end_layout

\begin_layout Itemize
Every link is globally unique.
 For example, the sub-expression '(e2 n2 n3)' appears twice; in both cases,
 it is exactly the same subexpression.
 This is clear by refering to the metagraph link table (
\begin_inset CommandInset ref
LatexCommand vpageref
reference "metagraph link table"
plural "false"
caps "false"
noprefix "false"

\end_inset

): there is really just one copy.
\end_layout

\begin_layout Standard
We conclude that s-expressions offer a marvelous compact string representation
 for metagraphs.
 Yet one should not be mislead; these are not ordinary s-expressions.
 This will be further amplified below, when considering queries performed
 over s-expressions.
\end_layout

\begin_layout Subsection*
UUID's
\end_layout

\begin_layout Standard
Because each node and link is globally unique, it is very tempting, at this
 point, to say 
\begin_inset Quotes eld
\end_inset

oh, hey, just use universally unique identifiers
\begin_inset Quotes erd
\end_inset

 (UUID's).
 This is good enough for local address spaces; if nothing else, then an
 ordinary C/C++ pointer is a UUID to the object.
 But, when writing a text string, what UUID shall one use? 
\end_layout

\begin_layout Standard
Much worse, UUID's cause major, fundamental problems when considering network-di
stributed storage; this is the problem of UUID collision.
 One solution to avoid UUID collision is to have a single centralized atomic
 issuer of ID's that can guarantee uniqueness.
 This introduces a single, centralized bottleneck.
 Another solution is to use cryptographic hashes.
 Each meta-tree string can be hashed down to a number.
 To avoid collisions due to the birthday paradox, the hashes have to be
 quite large.
 For 1 million distinct atoms, a 64-bit hash and crossed fingers should
 be enough; uncrossing the fingers requires at least a 96-bit hash.
 For a trillion atoms, a 128-bit hash is just barely enough and a 192-bit
 hash is preferred.
 These eat up RAM (as compared to pointers) and the computation of cryptographic
 hashes requires significant CPU overhead.
 
\end_layout

\begin_layout Standard
Just how big is a 64-bit hash, vs.
 the expression it is standing in for? Well, 64-bits is 8 bytes.
 Suppose that the data that one was storing consisted of English words (there
 are about a million of them, if you includ geographical place names, product
 and corporate names, historical events and a smattering of Latin and foreign
 loan-words.) The average length of these is about six letters, thus six
 byes; seven if including the null terminator.
 How about the names of genes and proteins? These are not particularly lengthly
 either.
 
\begin_inset Quotes eld
\end_inset

Ah, but tree structure!
\begin_inset Quotes erd
\end_inset

 you might think.
 All those parens, they need to be counted too! If you dump those plain-ASCII
 (plain-UTF8) s-expressions to a file, and then run gzip on it, or better
 yet, bzip2 or 7z, you find that those raw string s-expressions compress
 very well, outperforming by a wide margin the 64-bit UUID hash.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

But
\begin_inset Quotes erd
\end_inset

, you say, 
\begin_inset Quotes eld
\end_inset

we can't compress; the data lives in memory, not a file!
\begin_inset Quotes erd
\end_inset

 ah, yes, this is true.
 The in-RAM representation is explosively larger than the string s-expression
 form.
 Reviewing the two tables 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "metagraph node table"
plural "false"
caps "false"
noprefix "false"

\end_inset

, each apparance of a node or link in those tables must be a (64-bit) pointer.
 The example metagraph being worked here is two levels deep, and is quite
 'small'.
 Yet, counting the edges in the drawing of it, there are ten edges.
 Each edge is bidirectional: there are pointers going both ways; those 20
 pointers are required, or 
\begin_inset Formula $160=20\times8$
\end_inset

 bytes.
 Plus three bytes each for the null terminated strings '
\family typewriter
n
\family default
1', '
\family typewriter
n
\family default
2' ...
 'e1', 'e2' for a total of 
\begin_inset Formula $160+24=184$
\end_inset

 bytes minimum.
 The string-length of the string '
\family typewriter
(e4 (e3 (e1 n1 n2) (e2 n2 n3) n1 (e2 n2 n3)) n3)
\family default
' is 48 characters: 48 bytes.
 The s-expression representation is far more compact than the in-RAM representat
ion!
\end_layout

\begin_layout Standard
Finally, there is the problem of the UUID-to-meta-tree mapping.
 Where is it stored? New meta-trees could be added weeks or months later.
 Is this UUID-to-meta-tree mapping supposed to be live, available on-line
 at any time? What happens if it goes down? How is it kept unique? With
 locks? How many UUID's per second can be issued? What happens if it gets
 corrupted? Who has spare copies? Do byzantine generals show up here? How
 much storage does this all require?
\end_layout

\begin_layout Standard
To conclude: having hashes around can be useful, as hashes are needed for
 hash tables.
 However, conceiving of them as if they were truly universally-unique ID's
 is problematic in a dozen different ways.
 By contrast, each and every s-expression really really is globally unique.
 There is only one of any given kind! No centralized authority was needed
 to issue this unique string! Anyone can mint it at any time, at very low
 cost! If forgotten, it can be recreated! And it's ASCII representation,
 compressed with bog-standard compression routines, is formidably tiny.
 UUID's are horrible; s-expressions are smart.
\end_layout

\begin_layout Section*
Insertion, Deletion and Mutability
\end_layout

\begin_layout Standard
When a metatree is added to a metagraph, a scan must be made to determine
 if the tree, or any subtree already occurs in the metagraph.
 How might we know this? By looking it up! But where is this stored? 
\end_layout

\begin_layout Standard
One concludes that there is really only one option: there has to be a mutable,
 top-level index that holds all of the meta-trees in the metagraph.
 In a sense, it is the one link to rule them all.
 Put differently, a metagraph store is, 
\emph on
de facto
\emph default
, just a store for one single mutable meta-tree.
 
\end_layout

\begin_layout Standard
The word 'mutable' was used several times in the last few sentences.
 This is important.
 For all other meta-trees, it is not only convenient to treat them as if
 they were immutable, it becomes a necessity.
 Returning to the example meta-tree:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(e4 (e3 (e1 n1 n2) (e2 n2 n3) n1 (e2 n2 n3)) n3)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Suppose one wishes to change 
\begin_inset Quotes eld
\end_inset

just one
\begin_inset Quotes erd
\end_inset

 of the '
\family typewriter
n
\family default
3's into an '
\family typewriter
n
\family default
5'.
 But which one? They are, after all, all the same '
\family typewriter
n
\family default
3', so if edited, they all change together, atomically.
 Suppose now that this meta-tree is a subtree of something larger and more
 complex.
 Performing an edit, changing the '
\family typewriter
n
\family default
3' into an '
\family typewriter
n
\family default
5' in this meta-tree requires examining the incoming set of this tree, and
 determining what to do in each case.
 This might be a non-trvial decision proceedure.
 Should each of these larger trees get the new, modified version, or should
 they keep the original unmodified version? If the latter, then the unmodified
 version becomes 
\emph on
de facto
\emph default
 immutable, and the new, modified version just becomes a completely new
 meta-tree.
\end_layout

\begin_layout Standard
So immutable meta-trees are quite all right.
 Besides avoiding the decision problem of what to do with the incoming set,
 there are some much more mundane advantages.
 Immutable meta-trees can be traversed lock-free; there is no concern that
 one thread is traversing it even as another thread is altering it.
 The importance of having small structures being lock-free cannot be overstated.
\end_layout

\begin_layout Standard
This all changes when one considers the top-most, master index.
 It 
\emph on
must
\emph default
 be mutable.
 It 
\emph on
must
\emph default
 be possible to add new trees, and remove stale ones from this master index.
 Otherwise, it cannot be called a database!
\end_layout

\begin_layout Standard
Yet, oddly, this top-level index/table looks exactly like any other metatree.
 Yes, its large: it may have many millions of (immutable) subtrees in it.
 But it itself is just another tree, and there is no particular reason why
 it cannot be the subtree of yet other trees.
 The only difference is that it is mutable.
 
\end_layout

\begin_layout Standard
Thus, we've identified two fundamentally differrent structures, serving
 different purposes, yet both having the same form.
 The mutable form is a 'database'.
 The immutable form is the 'data'.
 In all other respects, they are the same.
\end_layout

\begin_layout Standard
Jumping ahead, the mutable form has been historically called the 'AtomSpace'.
 It can be stacked and nested and used to form diamond-shaped inheritance
 diagrams, however one wishes.
 The immutable Nodes and Links have been called 'Atoms', as a stand-in term
 for something that can be either a Node or a Link.
\end_layout

\begin_layout Subsubsection*
Metagraph mutability vs.
 SQL table mutability
\end_layout

\begin_layout Standard
There are two ways to delete a row from an SQL table.
 Either one already knows the 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
PRIMARY KEY
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 of that row, and one asks for that key to be deleted, or one does not.
 If one does not know, then one has to 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT key FROM employees WHERE name='Agent Smith';
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 and present the resulting key to be deleted.
 Yes, of course, this can be done with a single statement; that only hides
 the fact that, without the key, nothing can be done.
\end_layout

\begin_layout Standard
In SQL, effectively all tables have a primary key: it is the master key
 for each row.
 For the discussion above, it is effectively the UUID.
 As the 
\emph on
de facto
\emph default
 UUID of SQL systems, it suffers from all the drawbacks previously hinted
 at.
 SQL databases are notoriously hard to shard across multiple network nodes.
 Consistency and atomic updates are hard: there is effectively one centralized
 bottleneck.
 This is the foundation stone for the ACID vs.
 BASE debates.
\end_layout

\begin_layout Standard
How does this compare to the one mutable index of all immutable meta-trees?
 Well, there are at least three 'obvious' ways in which the deletion of
 a meta-tree could be implemented.
\end_layout

\begin_layout Itemize
If the master index is a hash table or a tree of raw memory pointers, and
 one has the raw pointer to the memory to be deleted, the deletion can be
 immediately and directly performed.
 direct.
 This is analogous to already knowing the primary key of an SQL table row.
\end_layout

\begin_layout Itemize
If the master index is a hash table or a tree of abstract indicators, and
 one has the abstract indicator of the meta-tree to be deleted, the deletion
 can be immediately and directly performed.
 Unlike the case of UUID's, there are abstract indicators that can be compuuted
 uniquely and in a relatively rapid fashion.
 An example of this is the Merkle tree.
 It is 'decentralized', in the sense that, no matter who has a copy of a
 given meta-tree, or where it might be located, everyone will agree as to
 what it's Merkle tree hash will be.
 It is not 'unique', in the sense that there might be hash collisions.
 However, for practical use in the database, being collision-free is not
 important; being computable in a decentralized fashion is.
 It avoids the UUID/primary-key pitfall.
 This certainly turns the ACID vs.
 BASE debate a bit on it's side.
 The current actual OpenCog AtomSpace in-RAM implementation uses Merkle
 trees.
\end_layout

\begin_layout Itemize
If the master index is an ordered key-value-store (OKVS, see Wikipedia)
 of s-expressions, and one has the s-expression corresponding to the meta-tree
 to be deleted, the deletion can be immediately and directly performed.
 But it is already apparent that it is easy and cheap to compute (in a decentral
ized fashion) the s-expression corresponding to a meta-tree.
 This is effectively a variant of the above, where the 
\begin_inset Quotes eld
\end_inset

abstract indicator
\begin_inset Quotes erd
\end_inset

 is the s-exp, instead of the Merkle tree.
 Given the earlier discussion concerning the size of s-expressions vs.
 the size of pointers, this is certainly a viable storage format for the
 in-RAM metagraph database.
 That it is not used by the current in-RAM AtomSpace is largely a historical
 accident.
 However, one of several of the current file-storage backends to the AtomSpace
 is RocksDB.
 That backend 
\emph on
does
\emph default
 use s-expressions as the 
\begin_inset Quotes eld
\end_inset

primary key
\begin_inset Quotes erd
\end_inset

, and ROCKSDB itself is a kind of OKVS.
\end_layout

\begin_layout Standard
Metagraph insertion can be compared to SQL table insertion along the same
 lines.
 
\end_layout

\begin_layout Standard
As should be clear, there is not really all that much difference here, at
 least conceptually.
 The biggest and by far the most apparent difference is that SQL explicitly
 and overtly exposes UUIDs in the form of primary keys, thus dragging all
 that baggage along with it.
 By contrast, a metagraph store can keep all of this hidden, and has multiple
 implementation options for the analagous concept of a primary key: either
 Merkle trees, or s-expressions, or possibly something else.
 From the implementors point of view, this is nice: there are various possible
 implementations.
\end_layout

\begin_layout Standard
This is also nice from the user's point of view: why mess with primary keys,
 if one doesn't have to? One less thing to think about, and not unrelated
 to the 
\begin_inset Quotes eld
\end_inset

automatic
\begin_inset Quotes erd
\end_inset

 nature of table normalization with metagraphs.
 Metagraphs provide automatic key maintenance.
 Nice!
\end_layout

\begin_layout Subsubsection*
Metagraph mutability vs.
 Graph databases
\end_layout

\begin_layout Standard
Compared to a graph database ...
 well, how, exactly is one supposed to say that 
\begin_inset Quotes eld
\end_inset

this vertex is the same as that vertex
\begin_inset Quotes erd
\end_inset

 in a graph store? This is non-trivial; it requires either references or
 some other technique; if one is not careful, one finds oneself performing
 queries at the same time that one is inserting data.
 
\end_layout

\begin_layout Standard
The answer to be supplied here is utterly opaque.
 This section is short because the problem is a bit mind-boggling.
 To conclude: we seem to have discovered, quite accidentally, with no explicit
 intent, that hypergraphs offer an elegant property that graph databases
 lack.
\end_layout

\begin_layout Section*
Query Languages and Graph Traversal
\end_layout

\begin_layout Standard
The majority of popular query languages (QL) are modelled on SQL, taking
 SQL as not just as an inspiration, but rather directly borrowing (stealing)
 most of its keywords and syntax.
 This is good, in that it makes it easy for users who are already familiar
 with SQL to learn the new system.
 This is good, in that it acts as a guidepost to the developer of the NewQL:
 if things get confusing, just take a look at how SQL did it, and make NewQL
 do it more-or-less the same way.
\end_layout

\begin_layout Standard
This is bad, in that, when the QL is to be applied to a new domain, such
 as graphs, hypergraphs or metagraphs, the mind-set that was suitable for
 table queries might not be appropriate for graphs.
 But this is not obvious: just half an hour with GraphQL documentation and
 examples will easily leave you with the impression that you can do anything
 you want with GraphQL.
 Got a graph? GraphQL can traverse it! That there might be some other way,
 maybe even a better way, never really enters your mind.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is a reply to the Sapir–Whorf Hypothesis in the strong affirmative.
 The Sapir–Whorf hypothesis is breifly worded as 
\begin_inset Quotes eld
\end_inset

language limits thought.
\begin_inset Quotes erd
\end_inset

 Originally, the language was natural language, say English or Chinese.
 The hypothesis seems a bit absurd: if I speak English or Chinese, why 
\emph on
wouldn't
\emph default
 I be able to think of anything (if I'm smart enough)? What's limiting about
 language? It's hard to imagine what one wouldn't be able think of.
 In the present case, the language is SQL, and if you are a programmer/DBA
 who thinks in terms of SQL, it is very hard to imagine what kind of queries
 one could perform that 
\emph on
don't
\emph default
 look like SQL.
 This is the topic of this section: exposing the limitations of SQL-thinking.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
There is no doubt that the mathematical theory of relational algebras is
 the 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

, or at least the 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

 theory for tables and the records stored in them.
 It's overwhelmingly dominant, and there does not appear to be any reason
 to question it.
 Likewise, the manifestion of relational algebras as SQL has the same effect:
 it works really really well for records and tables, and there is no compelling
 reason to replace it with something else.
 (A little voice asks: 
\begin_inset Quotes eld
\end_inset

if that's the case, then why graphs?
\begin_inset Quotes erd
\end_inset

) The sucess of this theory has the effect of shutting down any thought
 process that might lead elsewhere.
\end_layout

\begin_layout Standard
The aim of this section is to make this thought process overt, and show
 how there might be QL's that are not SQL clones.
 It begins by reviewing the actual strucure of metgraphs, and then examines
 how they compare to conventional table queries.
\end_layout

\begin_layout Subsection*
Weak Pointers
\end_layout

\begin_layout Standard
The example metatree diagram, as originally drawn (on the left) is misleading
 as to how it is actually represented in memory.
 If one examines the metagraph link table (
\begin_inset CommandInset ref
LatexCommand vpageref
reference "metagraph link table"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and includes arrows for both the incoming set and the outgoing list, one
 gets the diagram on the right:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/metagraph.eps
	lyxscale 60
	width 25col%

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Graphics
	filename graphics/metagraph-weak.eps
	lyxscale 60
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
The dotted arrows are back-pointers from lower levels to higher levels:
 the are the incoming set pointers, in contrast to the solid arrows, which
 show the outgoing links.
 They are almost in one-to-one correspondance, but not quite: notice there
 is only one dotted arrow from 
\begin_inset Formula $e_{2}$
\end_inset

 to 
\begin_inset Formula $e_{3}$
\end_inset

, although there are two distinct downward links.
\end_layout

\begin_layout Standard
The back-pointers are needed to maake the graph full traversible; that is
 the topic of this section.
 The back-pointers do et up RAM; but this RAM usage has already been counted,
 above.
 Here, it is only the diagram that has been corrected to more appropriately
 show the actual situation.
 In actual implementations, the dotted arrows are weak pointers.
 This is required for memory management, whether through garage collection
 (GC), or through reference counting (RC) with smart pointers.
 Both kinds of systems (GC and RC) can only work with DAG's, and do not
 tolerate loops, as these cannot be freed.
 Yet programmers need to sometimes create loops of pointers; weak pointers
 are provided for this use.
 That is what is shown here.
\end_layout

\begin_layout Standard
It is natural to use weak pointers for the incoming set, and regular pointers
 for the outgoing list.
 This is because, as observed earlier, metatrees must be immutable after
 they have been created.
 They cannot be edited; they can only be deleted.
 There is, however, one minor point of confusion, illustrated in the daigram
 below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/metagraph-new.eps
	lyxscale 60
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
This shows that a new link 
\begin_inset Formula $e_{5}$
\end_inset

 has been addeed to the previous diagram.
 This is 
\emph on
not
\emph default
 an edit! The earlier tree, rooted at 
\begin_inset Formula $e_{4}$
\end_inset

, is completely unchanged.
 None of the regular pointers have changed.
 Two of the atoms 
\begin_inset Formula $e_{2}$
\end_inset

 and 
\begin_inset Formula $n_{3}$
\end_inset

 have enlarged incoming sets: they have gained a weak pointer each.
 That the original metatree has not changed can be most easily observed
 by the fact that it's corresponding s-expression is the same as before:
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(e4 (e3 (e1 n1 n2) (e2 n2 n3) n1 (e2 n2 n3)) n3)
\end_layout

\end_inset

The diagram above shows two metatrees.
 The second one is
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(e5 (e2 n2 n3) n3)
\end_layout

\end_inset

The new root points to two existing metatrees: 
\begin_inset Formula $e_{2}$
\end_inset

 and 
\begin_inset Formula $n_{3}$
\end_inset

; neither has been modified.
 The point here is that immutability does not conflict with creation and
 deletion.
 
\end_layout

\begin_layout Subsection*
Queries and Tables
\end_layout

\begin_layout Standard
What do weak incoming sets have to do with queries? That they allow complete
 traversal of the metagraph is intuitively obvious: there are plenty-enough
 arrows (both regular and weak pointers) to be able to take walks from any
 Atom to any other.
 But are these really needed? The aim here is to show that the answer is
 'yes'.
\end_layout

\begin_layout Standard
As an initial example, consider a treewalk starting at 
\begin_inset Formula $e_{4}$
\end_inset

.
 Using conventional recursion techniques, it is easy to recurse (left to
 right) down to 
\begin_inset Formula $e_{3}$
\end_inset

 then 
\begin_inset Formula $e_{2}$
\end_inset

 and then 
\begin_inset Formula $n_{1}$
\end_inset

.
 Implemented as a stack machine, the nex step is to pop, and then visit
 
\begin_inset Formula $n_{2}$
\end_inset

.
 The next stack pop brings us back to 
\begin_inset Formula $e_{3}$
\end_inset

 and traversal procees as normal.
 Nowhere in this stack machine recursion is it possible to visit 
\begin_inset Formula $e_{5}$
\end_inset

.
 If one has started at 
\begin_inset Formula $e_{4}$
\end_inset

, one cannot get to 
\begin_inset Formula $e_{5}$
\end_inset

.
 Worse: perhaps one's starting point was 
\begin_inset Formula $n_{1}$
\end_inset

.
 From there, one cannot get to anywhere, at least, not when there aren't
 any incoming-set pointers (the dotted lines).
\end_layout

\begin_layout Standard
But is this relevant in any real-world application? Consider the following
 interpretation of the above diagram, where the Nodes is individuals, taking
 school classes and working part-time jobs:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interpretation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Joe
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rachel
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Intro Computer Science
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Intro Beauty and Hair Care
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dean of Students
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Whatsamatta University
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ayurvedic School of Cosmetology II
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{3}-n_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Joe assists in the Dean's Office
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{5}-n_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rachel is a TA in cosmetology
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
A natural question to pose in this interpretation is 
\begin_inset Quotes eld
\end_inset

what schools does Rachel attend?
\begin_inset Quotes erd
\end_inset

.
 Starting at 
\begin_inset Formula $n_{3}$
\end_inset

, one can trace upwards to find that Rachel attends both Whatsamatta U.
 and ASCII.
 
\end_layout

\begin_layout Standard
How might this have worked in conventional SQL? Well, for starters, we need
 something like this: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	CREATE TABLE Schools (name TEXT, uuid INT PRIMARY KEY);
\end_layout

\begin_layout Plain Layout

	INSERT INTO Schools ...
 ;
\end_layout

\begin_layout Plain Layout

	CREATE TABLE Courses (name TEXT, school_uuid INT FOREIGN KEY, uuid INT
 PRIMARY KEY);
\end_layout

\begin_layout Plain Layout

	CREATE TABLE Students (name TEXT, course_id INT FOREIGN KEY, student_id
 INT PRIMARY KEY);
\end_layout

\end_inset

One continues in this fashion, creating a few more tables.
 Denoting that Joe assists in the Dean's Office and that Rachel assists
 in the School of Cosmetology poses a bit of a challenge.
 Perhaps this might do?
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	CREATE TABLE Employment (name TEXT, employer TEXT, taxpayer_id INT PRIMARY
 KEY);
\end_layout

\end_inset

The need to denote employment adds a challenge to representing everything
 properly with tables, but is not relevant to the query about the schools
 that Rachel attends.
 Mostly, we just note that, even for this rather simple graph, there already
 is a profusion of tables with some rather complex relationships between
 one-another.
 Textbooks insist that normalization is the correct thing to do; students
 often find that normalization is just plain hard.
\end_layout

\begin_layout Standard
How does the query work? 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	SELECT Schools.name FROM Schools WHERE
\end_layout

\begin_layout Plain Layout

		Students.name = 'Rachel' AND
\end_layout

\begin_layout Plain Layout

		Students.course_id = Courses.uuid AND
\end_layout

\begin_layout Plain Layout

		Schools.uuid = Courses.school_uuid;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above has the form of an explicit path walk.
 It starts at 
\begin_inset Formula $n_{3}$
\end_inset

 and explicitly names a path that takes it to 
\begin_inset Formula $e_{2}$
\end_inset

 and then ...
 Well, obviously, we've left out a few details, in that 
\begin_inset Formula $e_{2}$
\end_inset

 is jointly managed both by ASCII and by the Dean of WU.
 Representing this properly requires a few more tables, and an additional
 clause in the 
\family typewriter
SELECT
\family default
 statement.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We've left out more than a few details.
 There is the concept of '
\family typewriter
JOIN
\family default
', and its variants of '
\family typewriter
INNER JOIN
\family default
', '
\family typewriter
OUTER JOIN
\family default
' and so on, all of which exist to allow the DBA to more carefully control
 and craft the nature of the graph walk needed, and how the data flows through
 the query, so that the query will run in an efficient, performant manner.
 The DBA really needs to actually think of what the query is doing (and
 to know the concepts, and to consult the documentation).
 I'd like to suggest that programming in SQL is like programming in assembly
 code, but for data.
 Perhaps it's time for a higher-level query langauge that abstracts away
 these details.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This query works precisely because the DBA who is creating the query has
 a very concrete grasp of all of the tables involved, and is able to thread
 an explicit path between the tables.
 The reason that the SQL database engine can execute the query is because
 the DBA explicitly inserted 
\family typewriter
FOREIGN KEY
\family default
 constraints into appropriate locations.
 These foreign keys have the side effect of defining an index that manifests
 the dashed arrows in the metagraph diagram.
 The foreign keys are the dashed arrows.
 Not all of them; just some of them, only the ones that the DBA saw fit
 to add during the table design.
 Just like the dashed weak pointers allowed the metatree to be traversed
 upwards, so also the foreign keys allow the tables to be traversed 
\begin_inset Quotes eld
\end_inset

upwards
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Query planning
\end_layout

\begin_layout Standard
Query planning concerns the topic of how the database engine will actually
 perform the query.
 The above example was written in a fashion that highlights an obviously
 efficient and easy way to run the query.
 Start at the join '
\family typewriter
Students.name = 'Rachel'
\family default
' and trace the dashed arrows upwards, to immediately arrive at the desired
 answer.
\end_layout

\begin_layout Standard
Of course, there is no guarantee that the SQL engine will actually do this.
 It might decide to start with '
\family typewriter
TABLE Schools
\family default
', examine each school in turn, and then trace downwards from the top, until
 it eventually reaches Rachel, and is able to satisfy this final constraint.
 Table joins are a constraint satisifaction problem.
 Solving constraint satsifaction problems (CSP) is non-trivial; there is
 a vast literature devoted to this, both for the case of general CSP, and
 to the specific case of query plannning.
\end_layout

\begin_layout Standard
Why would an SQL engine run this query in an inefficent way? Well, the query
 panner may have decided that it is too expensive to create the dashed-arrow
 indexes.
 Without the dashed arrows, one obviously has to start at the top.
 Why would it decide that the dashed arrows are too expensive? Well, it
 might have looked at all the tables, noted that they are all very small,
 and that a direct downward-recursive query could be performed rapidly.
 Why splurge on indexes if they are not needed? 
\end_layout

\begin_layout Standard
There are also more mundane reasons to run the query top-down: the particular
 SQL engine may not even have much of a query planner.
 It might lack the sophistication to do anything fancy.
\end_layout

\begin_layout Subsubsection*
Example: OGRE QL
\end_layout

\begin_layout Standard
A worthwhile example to contemplate is the query language for OGRE
\begin_inset CommandInset citation
LatexCommand cite
key "OGRE"
literal "false"

\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Documentation for it is currently located at this URL: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://binaryanalysisplatform.github.io/bap/api/odoc/ogre/Ogre/Query/index.html
\end_layout

\end_inset


\end_layout

\end_inset

 The influence of SQL in this query language is clear.
 Interestingly, OGRE was designed to be a dtabase for s-expressions, and,
 as we've noted, s-expressions seem to make for an almost ideal representation
 for metatrees.
 So what's the catch? 
\end_layout

\begin_layout Standard
Well, the OGRE s-expressions are just that: strings.
 They are not metatrees; they are not interpreted as metatrees.
 They are interpreteed only as ordinary, conventional abstract syntax trees.
 Because of this, there is no particularly compelling reason to automatically
 manage the incoming sets for these trees.
 Or rather, there is no particularly compelling reason, until one considers
 the implementation of the 'JOIN' keyword.
 In OGRE, there are no over primary keys, and no foreign keys, so these
 need to be generated implicitly, as needed, to perform a query that joins
 together multiple s-expressions.
\end_layout

\begin_layout Standard
Does OGRE actually auto-create these primary-key/foreign-key relations,
 under the covers? Without looking at the implementation, it is hard to
 guess, but there are a few hints.
 OGRE works as follows.
 Each s-expression has the form
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	( <attribute-name> <v1> <v2> ...
 <vM> )
\end_layout

\end_inset

That is, the very first word appearing after the opening parenthsis has
 a special meaning.
 This is entirely conventional: in LISP/Scheme, the first word appearing
 after an opening parenthesis also has a very special significance.
 It is a lambda.
 For our metatrees written as s-expressions, that first word is necessarily
 a Link.
 And so in OGRE, the first word is called the 
\begin_inset Quotes eld
\end_inset

name of a proposition
\begin_inset Quotes erd
\end_inset

; the subsequent words are the object (or subject) of the proposition.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The word 
\begin_inset Quotes eld
\end_inset

proposition
\begin_inset Quotes erd
\end_inset

 is no accident.
 It is meant to make you think of propositional logic.
 This point will be returned to when we look at ProLog.
 It is notable that there is confusion between subject and object; that
 these are taken to be synonymous.
 In the general sheaf theory, subjects and objects are not synonymous; they
 correspond to different connector types.
 But this is a topic outside of teh scope of the present text.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
As noted in the introduction to this text, an s-expression such as 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(student (name Joe) (gpa 3.5))
\end_layout

\end_inset

can be shortened to 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(student Joe 3.5)
\end_layout

\end_inset

provided that one has declared a 
\begin_inset Quotes eld
\end_inset

predicate
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(declare student (name str) (gpa float))
\end_layout

\end_inset

This last statement resembles a conventional table-database table declaration.
 The resemblance is more than superficial.
 The explicit BNF syntax for the declaration is
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	declaration ::= ( declare <attribute-name> <field> <field> ...
 )
\end_layout

\begin_layout Plain Layout

	field ::= ( <field-name> <field-type> )
\end_layout

\begin_layout Plain Layout

	field-type ::= int | str | bool | float
\end_layout

\end_inset

The field type is explicitly a concrete type.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is a good time to start talking about type theory.
 The correct handling of metatrees requires recognizing that the first word
 following the open parenthesis, the so-called Link, is a 
\emph on
de facto
\emph default
 type-theoretical type.
 Perhaps there is some way for it to not be a type, but, as Sapir-Whorf
 suggests, it proves to be difficult to imagine how it could be anything
 other than a type.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The need for explicit declarations, and the explicit identiffication of
 concrete types for fields, suggests that, under the covers, OGRE is building
 up all the machinery needed to perform table joins.
 Presumably this means the creation of the dashed-arrow incoming sets that
 are needed for upwards traversals.
 Or perhaps not: maybe the OGRE query planner always initiates queries top-down,
 starting at the uppermost declaration, and running a stack machine to perform
 recursive joins downwards.
 If one has well-defined tables, a top-down query would seem like a viable
 approach.
\end_layout

\begin_layout Standard
Note, by the way, that the declaration statement is of fixed length, and
 is 
\emph on
NOT
\emph default
 variadic! The declaration statement really is defining fixed-length records
 which can be placed into a completely conventional row-table.
 This is perhaps why the OGRE query language loooks a lot like SQL: it has
 not departed from the table paradigm.
 It has merely slapped on a prettier API, prettier in the sense that the
 primary key and foreign key constraints have disappeared into the woodwork.
\end_layout

\begin_layout Standard
As a meta-comment about table declarations and queries: this all works fine,
 as long as one has a small number of declarations.
 A dozen, a few dozen, less than a hundred.
 Pondering the situation of a million different table declarations is ..
 imponderable, if one comes from an SQL background.
 Because: oh good lord, how could one ever write meaningful queries if there
 are a million tables? Can't even imagine.
 Why, one would need to write meta-queries to query tables, and perhaps
 query meta-tables of tables.
 If only there was a meta-query language to query meta-tables in recursively-org
anized meta-trees...
 oh wait, what?
\end_layout

\begin_layout Standard
We'll get back to you on that one.
\end_layout

\begin_layout Standard
In the meanwhile, it is important to observe that OGRE was designed to be
 a plugin for OCaML.
 A significant part of the query apparatus is defined in terms of OCaML
 and not in terms of s-expressions.
 Portions of the query are explicitly typed; many of the type declarations
 are functional-programming function arrows (in type theory, these go by
 the name of 
\begin_inset Quotes eld
\end_inset

function type
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

arrow type
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

exponential
\begin_inset Quotes erd
\end_inset

, the later name harking back to size of the codomain of set-theoretic functions
).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Function_type
\end_layout

\end_inset


\end_layout

\end_inset

 The query language is usable only if one is writing OCaML.
\end_layout

\begin_layout Standard
Perhaps the most innovative aspect of the OGRE query language is that it
 is wrapped in a Keliesi triple (a Monad).
 Somewhat oddly, though, that monad seems to reinvent some subset of LISP,
 or at least of the SRFI-1 list iterators.
 This is perhaps not enitrely unexpected: s-expressions do look like lists,
 and it is natural to want to do list operations on them.
\end_layout

\begin_layout Section*
A Meta-Query Language
\end_layout

\begin_layout Standard
How else could the query about the schools that Rachel attends could be
 formulated? Returning to the example diagram
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/metagraph-new.eps
	lyxscale 60
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
and once again noting that the presence of the dotted arrows allows rapid
 graph traversal starting from any Atom, we can offer the following as a
 possibility: 
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(Meet (Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

		(Present
\end_layout

\begin_layout Plain Layout

			(Link (Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

			(Link (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

) (Node 
\begin_inset Quotes eld
\end_inset

Rachel
\begin_inset Quotes erd
\end_inset

))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reading of this query is as follows:
\end_layout

\begin_layout Itemize
'
\family typewriter
Meet
\family default
' is a special keyword defining the query.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The name '
\family sans
Meet
\family default
' comes from the mathematical concept of meets and joins on a lattice.
 See 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Join_and_meet
\end_layout

\end_inset

.
 The '
\family sans
Present
\family default
' link is a listing of several points in a lattice, all of which must be
 met by any solution to the query.
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
'
\family typewriter
Variable
\family default
' is a special keyword, that, when it follows a '
\family typewriter
Meet
\family default
', it indicates what is to be returned.
 It has other (related) meanings in other contexts.
\end_layout

\begin_layout Itemize
'
\family typewriter
Present
\family default
' is a special keyword, asking that all of the clauses must explicitly appear
 in the database.
 They must be matched, as patterns in a pattern matcher.
 It is an unordered Link; the order of the clauses in this Link carries
 no significance.
\end_layout

\begin_layout Itemize
The '
\family typewriter
Node
\family default
' and '
\family typewriter
Link
\family default
' keywords are special keywords, explicitly denoting the Nodes and Links
 about which we've been talking all along.
\end_layout

\begin_layout Standard
The intent is that the '
\family typewriter
(Variable ?course?)
\family default
' is grounded by 
\begin_inset Formula $e_{2}$
\end_inset

, a course Rachel (
\begin_inset Formula $n_{3}$
\end_inset

) is attending.
 The '
\family typewriter
(Variable ?what-school?)
\family default
' is grounded by 
\begin_inset Formula $e_{5}$
\end_inset

, the School of Cosmetology.
\end_layout

\begin_layout Standard
This should be contrasted with the earlier SQL query:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	SELECT Schools.name FROM Schools WHERE
\end_layout

\begin_layout Plain Layout

		Students.name = 'Rachel' AND
\end_layout

\begin_layout Plain Layout

		Students.course_id = Courses.uuid AND
\end_layout

\begin_layout Plain Layout

		Schools.uuid = Courses.school_uuid;
\end_layout

\end_inset

The most notable difference is that the meta-query does not need to explicitly
 name the '
\family typewriter
Schools
\family default
' table.
 Indeed, the metagraph does not have a '
\family typewriter
Schools
\family default
' table, and so it is not nameable (this could be 
\begin_inset Quotes eld
\end_inset

fixed
\begin_inset Quotes erd
\end_inset

 by adding more nodes and links to the metagraph, but that is besides the
 point.) 
\end_layout

\begin_layout Standard
Another fundamental difference is that SQL embodies an explicit 
\begin_inset Quotes eld
\end_inset

equational theory
\begin_inset Quotes erd
\end_inset

, whereas the meta-query does not.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Theory_of_pure_equality
\end_layout

\end_inset

 and 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Equational_logic
\end_layout

\end_inset

.
 In mathematical logic and model theory, the equational theory is the first
 theory that is more complicated than the 
\begin_inset Quotes eld
\end_inset

free theory
\begin_inset Quotes erd
\end_inset

 (see 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Free_theory
\end_layout

\end_inset

.) In breif: with the free theory, you can freely 
\begin_inset Quotes eld
\end_inset

write down anything
\begin_inset Quotes erd
\end_inset

, as long as the parenthesis balance.
 Both s-expressions and Prolog can be taken to be examples of free theories.
 The theory of pure equality adds the equals sign, and says 
\begin_inset Quotes eld
\end_inset

you can write down anything
\begin_inset Quotes erd
\end_inset

, as long as the parenthesis balance and you also take transitive closures
 of the things that are equated.
 Problems of consistency first show up here, as it is possible to write
 down nonsense and paradoxes using equals signs.
 Relational algebra (
\emph on
e.g.

\emph default
 SQL) is the theory where you can 
\begin_inset Quotes eld
\end_inset

write down anything
\begin_inset Quotes erd
\end_inset

, but you can also use relations between things.
 Each relation corresponds to an SQL table.
 That relation is 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 if the corresponding row exists in the SQL table, else it is 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset

; thus relations are sometimes called predicates.
 A pure relational algebra, without equality, is not quite interesting enough
 to be practical.
 As all of these examples show, you need to fold in the theory of equality
 in order to perform table joins.
 The equals sign just says 
\begin_inset Quotes eld
\end_inset

this variable appearing in this predicate is equal to this other variable
 or constant appearing in some other predicate
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 The SQL statement has implicit variables in it: the expression '
\family typewriter
Students.course_id
\family default
' is meant to be understood as a variable, ranging over all possible values
 of '
\family typewriter
course_id
\family default
' in the '
\family typewriter
Students
\family default
' table.
 The '
\family typewriter
Courses.uuid
\family default
' is another implicit variable.
 The equals sign is needed, because of the way that the variables appeared
 implicitly.
 There is no other way of saying 
\begin_inset Quotes eld
\end_inset

hey, these two variables are really the same thing
\begin_inset Quotes erd
\end_inset

, and thus the concept of table joins is born.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The complexity of table joins is in part a side-effect of the complexity
 of the theory of equality.
 You might think that equality seems pretty darned easy; it's just equals
 signs, right? Contemplating the complexity of SQL table joins, and the
 complexity of SQL query planners in planning table joins should quickly
 disabuse you of the idea that 
\begin_inset Quotes eld
\end_inset

equality is simple
\begin_inset Quotes erd
\end_inset

.
 It's hard.
 If you are still not convinced, review the Wikiipedia article on equational
 logic again: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Equational_logic
\end_layout

\end_inset

.
 It has a number of axioms to make it work, and it is no accident that it
 was developed by computer scientists who were also known for thier contribution
s to relational algebras and query languages.
\end_layout

\end_inset

 The meta-query made use of the property of meta-graphs that any given Atom
 is always the same Atom.
 That is, the '
\family typewriter
(Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

)
\family default
' is the same Atom in both subtrees.
 There is no need to use an equals sign to equate these two positions; they
 are already 
\begin_inset Quotes eld
\end_inset

the same thing
\begin_inset Quotes erd
\end_inset

 as metagraphs; they can't not be 
\begin_inset Quotes eld
\end_inset

the same thing
\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Variables, are, however, always named, given a name.
 It is an open question is to how anonymous (unamed) variables might be
 written.
\end_layout

\end_inset

 There is no explcit need for equality.
\end_layout

\begin_layout Standard
A third fundamental difference is that the metaquery did not require any
 prior table definition.
 The situation is thus quite different than the aforementioned OGRE QL.
 Thanks to the implicit presence of the dashed arrows, there is no need
 to explicitly define indexes (i.e.
 there is no '
\family typewriter
CREATE INDEX ON Students(name);
\family default
' which would be needed if we wanted to have fast-running SQL queries on
 student names.
 The primary keys, of course, did not need explicit index declarations.)
\end_layout

\begin_layout Standard
A fourth fundamental difference is that the metaquery is itself a metatree.
 It does not live outside of the system of metagraphs.
 It does have a peculiar syntax and a collection of syntax rules (
\emph on
i.e.

\emph default
 it must begin with '
\family typewriter
Meet
\family default
', it must have some variable declarations and use the '
\family typewriter
Present
\family default
' link, and so on) but that syntax is a sublanguage within the language
 of free s-expressions.
 The fact that the metaquery is itself a metatree opens the possibility
 of querying for queries.
 This may sound utterly absurd, but is in fact very commonplace in chatbots!
 This is expanded on below.
\end_layout

\begin_layout Standard
It is perhaps instructive to draw the metatree diagram for this query:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/metaquery.eps
	lyxscale 60
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
The reading for this metatree, in terms of its Atoms, is as follows:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atom
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S-expression
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(Node 
\begin_inset Quotes eld
\end_inset

Rachel
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(Link
\end_layout

\begin_layout Plain Layout

    (Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

    (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(Link
\end_layout

\begin_layout Plain Layout

    (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

    (Node 
\begin_inset Quotes eld
\end_inset

Rachel
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3,linewidth=40pt"
inline false
status open

\begin_layout Plain Layout

(Present
\end_layout

\begin_layout Plain Layout

   (Link (Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

   (Link (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

) (Node 
\begin_inset Quotes eld
\end_inset

Rachel
\begin_inset Quotes erd
\end_inset

))))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $g_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

(Meet
\end_layout

\begin_layout Plain Layout

   (Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

   (Present
\end_layout

\begin_layout Plain Layout

      (Link (Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

      (Link (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

) (Node 
\begin_inset Quotes eld
\end_inset

Rachel
\begin_inset Quotes erd
\end_inset

))))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
It is not entirely obvious, but performing this query requires solving a
 subgraph isomorphism problem.
 Clearly, the query implictly demands that the variables should be grounded.
 The variables are to be grounded by Atoms, which may be either Nodes or
 Links.
 In the cse of Links, these are (by definition) metatrees themselves, and
 so the grounding matches a variable to a subgraph.
 The collection of subgraphs must be those specified in the '
\family typewriter
Present
\family default
' link: 
\emph on
i.e.

\emph default
 they must be isomorphic to it.
 Thus, the subgraph isomorphism problem.
\end_layout

\begin_layout Standard
The careful reader may have noticed that the above query only allows Rachel
 to be a student of ASCII.
 The full query, which would also reveal her to be a student of WU, is given
 below.
 The comparable SQL statement is considerably more complex and not given.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(Meet (Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

		(Present
\end_layout

\begin_layout Plain Layout

			(Link (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

) (Node 
\begin_inset Quotes eld
\end_inset

Rachel
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\begin_layout Plain Layout

		(Choice
\end_layout

\begin_layout Plain Layout

			(Present
\end_layout

\begin_layout Plain Layout

				(Link (Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\begin_layout Plain Layout

			(Present
\end_layout

\begin_layout Plain Layout

				(Link (Variable 
\begin_inset Quotes eld
\end_inset

?what-school?
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?deprtment?
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

				(Link (Variable 
\begin_inset Quotes eld
\end_inset

?department?
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?course?
\begin_inset Quotes erd
\end_inset

)))))
\end_layout

\end_inset

The above introduces the 'Choice' Link.
 For the most part, it can be read as a logical-OR of the two predicates
 that it wraps.
 More precisely, it can be used as a menu-choice: pick one or pick the other
 (but not both).
 Choice commonly appears as a fragement of intuitionistic logic and of linear
 logic.
\end_layout

\begin_layout Subsection*
Query Planning
\end_layout

\begin_layout Standard
There is little to be said about query planning, other than to notice that
 performing a query requires a graph walk.
 Thanks to the incoming set, the query can be started anywhere.
 It is advantageous to start the graph walk at the thinnest, most distant
 part of the graph, so that it does not need to be regularly revisted.
\end_layout

\begin_layout Standard
Similarly, it is advantageous to borrow some ideas from SAT solving, and
 prune simple trees from the query, before performing an exhaustive search
 of a multiply-conneted tight nucleus.
 The pruned trees can be re-attached later.
 Equivalently, they might only need to be pattern-matched once.
 In this case, pruing is equivalent to maintaining a cache of pattern matches
 acheived earlier during traversal.
 (That is, a recursive graph walk will typically revisit certain parts of
 the graph.
 But if those parts have already been grounded, they do not need to be revisited
 again; it is sufficeint to have a cache of the groundings.)
\end_layout

\begin_layout Standard
The OpenCog query engine makes use of both of these query optimizations.
\end_layout

\begin_layout Subsection*
Attributes (Tags)
\end_layout

\begin_layout Standard
This text opened with an extended discussion of attributes, and about how
 attributes are attached to the nodes and vertexes of a graph.
 This is still the case, still a desirable thing to do, when working with
 metagraphs.
 
\begin_inset Quotes eld
\end_inset

But why?
\begin_inset Quotes erd
\end_inset

 you may wonder, 
\begin_inset Quotes eld
\end_inset

why can't everthing be encoded as as metagraph?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Well, of course, everything can be encoded as a metagraph.
 However, there's a cost; several costs, actually.
 One cost is that metatrees are immutable.
 If one has a list of 100 floating point numbers, and wishes to change the
 42nd one, it seems like overkill to be blocked from doing so by immutability.
 One might like to have something mutable, for this kind of a low-level
 vector.
 Another cost is the weak pointer (the dashe arrow).
 There is no particular need to maintain an incoming set for each floating
 point in a list.
 It is unlikely that two different Links will share the same floating point
 number (to all of it's glorious 18 decimal places!? Really?) It is unlikely
 that there will ever be any need for a query to traverse backwards (through
 the incoming set) of that float.
 Traversing forward into the vector of floats is plenty enough, if the only
 query decision to be performed is greater-then, less-than on some arithmetic
 ops on those numbers.
 Saving some RAM by not storing the weak pointers is a laudable thing do
 to.
\end_layout

\begin_layout Standard
If the attributes are stored as key-value pairs (KVP), then the attributes
 on any given Atom can be understood conceptually as a key-value database
 per Atom.
 This might feel like overkill, but it isn't really any different from graph
 databases in general.
 If a vertex or an edge of a graph has some attributes attached to it, then
 those attributes can be thought of as residing in a database specific to
 that edge or vertex.
\end_layout

\begin_layout Standard
In the present case, there is one fun little twist: if the KVP's are heirarchica
l, 
\emph on
i.e.

\emph default
 a tree, then they can be thought of as a special case of a metatree (as,
 indeed, trees are special cases of metatrees), but it is a metatree that
 is shorn of it's weak back-pointers, and thus can be mutable.
 One saves RAM and regains the mutability that was lost.
 The price to be paid is that such attributes are no longer searchable.
 (More precisely, they are no longer searchable except by brute force exhaustive
 search.
 The weak pointers acted as local indexes; without the ability to do an
 index lookup, brute force exhaustive search is all that one has left.)
\end_layout

\begin_layout Standard
The OpenCog AtomSpace supports attributes in the form of KVP trees.
 It has made one unfortunate naming choice for these attribute trees: they
 got called 
\begin_inset Quotes eld
\end_inset

Values
\begin_inset Quotes erd
\end_inset

 with a capital V.
 This naming choice forces all sorts of contortions when one wants to talk
 about ordinary values with a lower-case v.
 The naming choice was arrived at under the influence of model theory, where
 a clear distinction is made between sentences of a language and thier valuation.
 In model theory, and in logic, sentences are assigned 
\begin_inset Quotes eld
\end_inset

truth values
\begin_inset Quotes erd
\end_inset

.
 Historically, these are crisp true/false values.
 But in Bayesian beleif networks and in Markov logic networks, these valuations
 are given floating-point probabilites as thier truth values.
 On OpenCog, these were historically called TruthValues, wirtten in CamelCase.
 When generalized to arbitrary KVP valuations, they become Values.
 A better name might have been Attributes or Tags, as they are treated as
 ...
 attributes, or tags.
\end_layout

\begin_layout Subsection*
Chatbots, Rule Engines and Inverted Queries
\end_layout

\begin_layout Standard
Here's something SQL cannot do: it cannot search for SQL.
 Absurd, right? One of the eary chatbot technologies is called SRAI (Stimulous-R
esponse AI), and the scripting language for SRAI is known as AIML (AI Markup
 Language).
 A snippet of AIML is given below.
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	<aiml>
\end_layout

\begin_layout Plain Layout

		<category>
\end_layout

\begin_layout Plain Layout

			<pattern>I love *</pattern>
\end_layout

\begin_layout Plain Layout

			<template>I like <star/> a lot.</template>
\end_layout

\begin_layout Plain Layout

		</category>
\end_layout

\begin_layout Plain Layout

		<category>
\end_layout

\begin_layout Plain Layout

			<pattern>I * you</pattern>
\end_layout

\begin_layout Plain Layout

			<template>Well, I <star/> you, too!</template>
\end_layout

\begin_layout Plain Layout

		</category>
\end_layout

\begin_layout Plain Layout

	</aiml>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The goal of this is to specify some conversational patterns to be matched,
 and, if matched, to produce the indicated output.
 Thus, if a human says 
\emph on

\begin_inset Quotes eld
\end_inset

I love baseball
\begin_inset Quotes erd
\end_inset


\emph default
, the chatbot responds 
\emph on

\begin_inset Quotes eld
\end_inset

I like baseball a lot.
\begin_inset Quotes erd
\end_inset


\emph default
 If the human says 
\emph on

\begin_inset Quotes eld
\end_inset

I hate you
\begin_inset Quotes erd
\end_inset


\emph default
, the response 
\emph on

\begin_inset Quotes eld
\end_inset

Well, I hate you, too!
\begin_inset Quotes erd
\end_inset


\emph default
 is elicited.
 In the case of 
\emph on

\begin_inset Quotes eld
\end_inset

I love you
\begin_inset Quotes erd
\end_inset


\emph default
, there are two possible responses, and a coin is flipped to pick one.
\end_layout

\begin_layout Standard
What is being done here is a kind of inverted query.
 One is presented with the 'answer', say 
\emph on

\begin_inset Quotes eld
\end_inset

I love you
\begin_inset Quotes erd
\end_inset


\emph default
, and the goal is to find all 'queries' which can be satisfied by that answer.
 In this example, the two queries are '
\family sans
<pattern>I love *</pattern>
\family default
' and '
\family sans
<pattern>I * you</pattern>
\family default
'.
 Abandoning the XML markup in favor of s-expressions, the two patterns are
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(I love (Variable 
\begin_inset Quotes eld
\end_inset

?star?
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

	(I (Variable 
\begin_inset Quotes eld
\end_inset

?star?
\begin_inset Quotes erd
\end_inset

) you)
\end_layout

\end_inset

An AIML chatbot consists of tens of thousands of such patterns, and the
 matching responses.
 In order to have rapid query responses, chatbot implementations organize
 the patterns into a trie
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A prefix tree, see 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Trie
\end_layout

\end_inset


\end_layout

\end_inset

 and typically implement some variation of the Rete algorithm.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Rete_algorithm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All this can be expressed in the Atomese meta-query language.
 It is necessarily a bit more verbose, but perhaps still readable without
 assistance.
 The AtomSpace is populated with SRAI rules, having the form
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(Query
\end_layout

\begin_layout Plain Layout

		(Present (Word 
\begin_inset Quotes eld
\end_inset

I
\begin_inset Quotes erd
\end_inset

) (Word 
\begin_inset Quotes eld
\end_inset

love
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?star?
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\begin_layout Plain Layout

		((Word 
\begin_inset Quotes eld
\end_inset

I
\begin_inset Quotes erd
\end_inset

) (Word 
\begin_inset Quotes eld
\end_inset

like
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?star?
\begin_inset Quotes erd
\end_inset

) (Word 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

) (Word 
\begin_inset Quotes eld
\end_inset

lot
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	(Query
\end_layout

\begin_layout Plain Layout

		(Present (Word 
\begin_inset Quotes eld
\end_inset

I
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?star?
\begin_inset Quotes erd
\end_inset

) (Word 
\begin_inset Quotes eld
\end_inset

you
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

		((Word 
\begin_inset Quotes eld
\end_inset

Well,
\begin_inset Quotes erd
\end_inset

) (Word 
\begin_inset Quotes eld
\end_inset

I
\begin_inset Quotes erd
\end_inset

) (Variable 
\begin_inset Quotes eld
\end_inset

?star?
\begin_inset Quotes erd
\end_inset

) (Word 
\begin_inset Quotes eld
\end_inset

you
\begin_inset Quotes erd
\end_inset

) (Word 
\begin_inset Quotes eld
\end_inset

too!
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reading of this content is as follows:
\end_layout

\begin_layout Itemize
'
\family sans
Query
\family default
' is a special keyword defining the rewrite rule.
 It is much like '
\family sans
Meet
\family default
', introduced previously, except that, this time, instead of delivering
 a grounding, it delivers a rewrite making use of that grounding.
 The first Atom following the query is the pattern to be matched.
 The second Atom of the query is the rewrite to apply, after a match has
 been found.
\end_layout

\begin_layout Itemize
The '
\family sans
Variable
\family default
' and '
\family sans
Present
\family default
' keywords are just as before.
\end_layout

\begin_layout Itemize
The '
\family sans
Word
\family default
' is a handy variant of a Node, reminding readers that the indicated string
 is a natural language word.
 One could have just as easily said '
\family sans
Node
\family default
', here; this is just some visual bling.
 
\end_layout

\begin_layout Standard
This is not SQL! We've said this before, but it is worth saying again: the
 metagraph database is populated with tens of thousands of such statements,
 
\begin_inset Quotes eld
\end_inset

statements
\begin_inset Quotes erd
\end_inset

 which just happen to have the form of queries.
 In the database, these queries are dormant; they are not running, they
 are just sitting there, waiting for thier day in the sun.
 The actual query to be performed looks like this:
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

	(Dual (Word 
\begin_inset Quotes eld
\end_inset

I
\begin_inset Quotes erd
\end_inset

) (Word 
\begin_inset Quotes eld
\end_inset

love
\begin_inset Quotes erd
\end_inset

) (Word
\begin_inset Quotes erd
\end_inset

you
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that this query has no variables in it: it consists entirely of constants
! It is an 'answer', not a question! The subgraph isomorphism engine, aka
 the query engine, aka the 'pattern matcher', finds all matching patterns.
 In this case, it is the two queries shown earlier.
 To run the chatbot, one then flips a coin, picks one of the two queries,
 runs it, and prints the response.
 Running the query is computationally 'trivial', as there is only one pattern
 to match: 
\emph on

\begin_inset Quotes eld
\end_inset

I love you
\begin_inset Quotes erd
\end_inset


\emph default
.
\end_layout

\begin_layout Standard
Pay attention: the above is 
\emph on
NOT
\emph default
 saying that there are ten thousand queries that are each performed, until
 a match is found! 
\emph on
No!
\emph default
 It is saying that only two queries are run: first, the '
\family sans
Dual
\family default
', to find some candidates, and then one of the candidates is chosen and
 run on a tiny, itsy-bitsy dataset consisting of one sentence.
 Its fast.
 In so far as all of this content is stored as metatrees, all of the prior
 considerations about RAM usage, search performance and tree walking apply.
\end_layout

\begin_layout Standard
The above is more or less a peculiar variation of the Rete algorithm.
 The Dual link is used to narrow down the selection of rules to apply, then
 (users choice) either one of the rules is selected and fired, or maybe
 all of the rules can be fired.
\end_layout

\begin_layout Standard
The take-away lessons are:
\end_layout

\begin_layout Itemize
Inverted queries are still queries.
\end_layout

\begin_layout Itemize
SQL-inspired languages cannot support inverted queries.
 As a corollary, most graph databases cannot support inverted queries.
\end_layout

\begin_layout Itemize
Chatbots are highly specialized, customized database engines, highly tuned
 for performing inverse queries.
\end_layout

\begin_layout Itemize
Rule engines are highly specialized, customized database engines, highly
 tuned for performing inverse queries.
\end_layout

\begin_layout Itemize
A metagraph-style query language can easily support both queries and inverted
 queries, because the query engine itself is a subgraph isomorphism solver,
 and it does not particularly care about the types of the Nodes and Links
 that it is matching, as long as it is able to match.
\end_layout

\begin_layout Itemize
Because metatrees contain both the forward pointers and the weak pointers
 pointing backwards, they effectively have a trie (prefix tree) built in.
 That is, the organizational advantages of using prefix trees to perform
 rapid string-matching searches come 
\begin_inset Quotes eld
\end_inset

for free
\begin_inset Quotes erd
\end_inset

 in a metagraph, as a part of the general infrastructure.
\end_layout

\begin_layout Itemize
Because metaqueries can support both direct and inverted queries, they provide
 a natural infrastructure on which to build both rule engines and forward-infere
ncing chainers.
 
\end_layout

\begin_layout Standard
That chatbots can be unified with conventional query is perhaps one of the
 more entertaining aspects coming out of metaqueries.
\end_layout

\begin_layout Section*
Types and Atomese
\end_layout

\begin_layout Standard
Lets return to the string expression 
\begin_inset Formula $\left(e_{4}:\left(e_{3}:\left(e_{1}:n_{1},n_{2}\right),\left(e_{2}:n_{2},n_{3}\right),n_{1},\left(e_{2}:n_{2},n_{3}\right)\right),n_{3}\right)$
\end_inset

.
 Since nodes and links (atoms) are unique, the subscripts on the hyperedges
 are not required.
 Nor is the use of the colon.
 The above is representable with the S-expression
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		(Link
\end_layout

\begin_layout Plain Layout

			(Link
\end_layout

\begin_layout Plain Layout

				(Link
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

one
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

				(Link
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

				(Node 
\begin_inset Quotes eld
\end_inset

one
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

				(Link
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\begin_layout Plain Layout

			(Node 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset

Just as with JSON, the same considerations about repeated objects apply.
\end_layout

\begin_layout Subsection*
Types
\end_layout

\begin_layout Standard
Perhaps the most interesting aspect of the s-expression format is the first
 explicit appearance of types.
 Here, there are just two types: the nodes, and the links.
 The nodes have to be given a name, so as to disambiguate them from one-another.
 The links do not: the metatree structure is enough to disambiguate one
 link from another.
 Again: nodes and links are naturally universally unique (or conversely,
 every node having the same name, every link having the same structure is
 indistinguishable.)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is eerily similar to atomic physics.
 All electrons are indistinguishable.
 All protons are indistinguishable.
 When combined into atoms, however, this changes.
 An element of one type (say, carbon) is clearly different than another
 (say, oxygen), but all carbon atoms are indistinguishable...
 unless they appear in an organic molecule.
 That is, it is the relationship of elementary particles to one-another
 that gives structure to the universe.
 It is not the particles themselves.
\end_layout

\end_inset

 When written in this form, the doubly-typed nature of the metatree is calling
 out for generalization.
 The types are sitting there, almost begging: 
\begin_inset Quotes eld
\end_inset

do something with me
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Multiple types are not strictly needed for storage: indeed, the two tables,
 one for nodes, and one for links, is sufficient to tell them apart.
 Actually generalizing the written form above to multiple types does require
 additional storage.
 Is it worth it?
\end_layout

\begin_layout Standard
In comp sci, in practice, types are incredibly useful.
 If they are not given explicit, distinguished treatment in the metatree,
 they will appear, without question, in the attribute section.
 Hang on, whats a type?
\end_layout

\begin_layout Standard
By 
\begin_inset Quotes eld
\end_inset

types
\begin_inset Quotes erd
\end_inset

 it is meant both the types of computer science, and of type theory.
 In ordinary programming, ints, floats and strings are types (these are
 the 
\begin_inset Quotes eld
\end_inset

primitive types
\begin_inset Quotes erd
\end_inset

), and so are object-oriented classes (these are the 
\begin_inset Quotes eld
\end_inset

compound types
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

product types
\begin_inset Quotes erd
\end_inset

).
 Function calls have a type signature too, and ML, CaML, Haskell and F#
 are all about programming with types.
 Unlike these standard, well-established languages, there is no particular
 need to limit oneself to a proscribed set of primitive types with a metagraph.
 One can have as many different primitive types as desired.
 One can have user-defined types.
\end_layout

\begin_layout Standard
The simplest example of a user-defined type is, for example, a 
\family sans
\emph on
CatLink
\family default
\emph default
.
 What's a 
\family sans
\emph on
CatLink
\family default
\emph default
?
\emph on
 
\emph default
Well, cats - house cats, are those things with paws and whiskers, and have
 an entire subdivision of the internet devoted to them.
 What do you do with a 
\family sans
\emph on
CatLink
\family default
\emph default
? Well, anything you want: use it to link to a photo URL.
 Use it in some phylogenetic tree.
 Describe the properties of a cat: fur, tail, 
\emph on
etc
\emph default
.
 Generic knowledge representation.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		; 
\begin_inset Quotes eld
\end_inset

The cat sat on the mat
\begin_inset Quotes erd
\end_inset

, as a typed metatree.
\end_layout

\begin_layout Plain Layout

		(SittingLink
\end_layout

\begin_layout Plain Layout

			(ObjectNode 
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

			(ObjectNode 
\begin_inset Quotes eld
\end_inset

mat
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, a good collection 
\family sans
\emph on
IsALink
\family default
\emph default
s, 
\family sans
\emph on
HasALink
\family default
\emph default
s and 
\family sans
\emph on
PartOfLink
\family default
\emph default
s, together with some reasonable verbs might be able to achieve the same
 goals
\emph on
 
\emph default
...
 but those are ...
 more types.
 The point here is that there is no need to limit oneself to ints, floats
 and strings, and the object-oriented classes one can build out of these
 primitives.
 There is no need to be constrained by the philosophy of functional programming
 language design.
\end_layout

\begin_layout Standard
Wait, what? Programming language design?
\end_layout

\begin_layout Subsection*
Atomese
\end_layout

\begin_layout Standard
Metagraphs fit well with type theory: it is easy, effectively trivial to
 represent product types, sum types and function signatures with metagraphs.
 This, in turn, opens the door to a very unusual property of metagraphs:
 they can be interpreted as programs.
 To illustrate, consider the case of an abstract syntax tree.
 Conventionally, one says that an expression, such as 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
if (a > b) return a+b;
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 can be represented by an abstract syntax tree.
 This is a tree where each internal node of the tree is one of the operators:
 plus, greater-than, if().
 Leaves are variables or constants.
\end_layout

\begin_layout Standard
For the case of (typed) metatrees, the representation is 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		(IfLink
\end_layout

\begin_layout Plain Layout

			(GreaterThanLink
\end_layout

\begin_layout Plain Layout

				(VariableNode 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

				(VariableNode 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

			(PlusLink
\end_layout

\begin_layout Plain Layout

				(VariableNode 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

				(VariableNode 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This not only represents the expression 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
if (a > b) return a+b;
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 but it can also be made active: when supplied with values for the variables,
 the comparison and the addition can be explicitly performed.
\end_layout

\begin_layout Standard
This is a key property that (typed) metatrees have, and that ordinary (typed
 or untyped) graphs do not.
 Ordinary graphs are not, in general, DAGs: they can contain cycles.
 Erecting an abstract syntax tree structure on an ordinary graph store is
 not natural; one must impose some representational constraints.
 Now, of course, one could limit oneself to using only DAG's, but any sane,
 normal designer of any graph store would strenuously object to adding executabl
e graphs as a fundamental property of the graph store itself.
 The execution of expressions is 
\begin_inset Quotes eld
\end_inset

orthogonal
\begin_inset Quotes erd
\end_inset

 to the storage of graphs.
 These tasks have 
\begin_inset Quotes eld
\end_inset

orthogonal concerns
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

non-overlapping concerns
\begin_inset Quotes erd
\end_inset

.
 Strangely, metatrees erase that orthogonality.
\end_layout

\begin_layout Subsubsection*
ProLog
\end_layout

\begin_layout Standard
Perhaps this seems dubious.
 The core issue is most easily exposed by looking at something like ProLog.
 It's a programming language, of course.
 It makes abstract syntax trees fairly explicit: it is hard to understand
 how prolog works, unless one learns to think in terms of trees.
 Certainly, the 
\begin_inset Quotes eld
\end_inset

cut operator
\begin_inset Quotes erd
\end_inset

 in prolog is one of the early stumbling blocks for programmers learning
 prolog.
 It's hard to see what it does, until one realizes that it is literally
 cutting branches off of a tree.
 At the same time, chapter one, the very first chapter of any book on prolog
 programming is rife with examples of knowledge representation.
 One will find something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		father_child(tom, erica).
\end_layout

\begin_layout Plain Layout

		father_child(mike, tom).
\end_layout

\begin_layout Plain Layout

		sibling(X, Y) :- parent_child(Z, X), parent_child(Z, Y).
\end_layout

\end_inset

The first two statements are assertions of fact, the third is a inference
 rule.
 They have a very obvious representation as trees, and, more precisely as
 meta-trees.
 Yet, strangely, prolog programs are encoded in text files, and 
\emph on
not
\emph default
 as a collection of entries in a graph database!
\end_layout

\begin_layout Standard
This last observation becomes truly bizarre, if one imagines some non-trivial
 knowledge representation problem.
 Imagine keeping census data in prolog.
 Maintaining a text file with dozens of lines of code for millions of people
 is absurd.
 Applying transformations or graph rewrites is impossible for text files.
 Consider the inference 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sibling
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 above.
 It can be taken as a run-time directive, but it can also be taken as a
 graph rewrite rule: find all graphs having two terms, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
parent_child(Z, X)
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
parent_child(Z, Y)
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 and create a new term 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sibling(X, Y)
\family default
\emph default

\begin_inset Quotes erd
\end_inset

.
 Such a rewrite is not all that hard in a database; in SQL, some appropriate
 combination of 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT INTO
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
JOIN
\family default
\emph default

\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The only stumbling block being the need to reference the 
\begin_inset Quotes eld
\end_inset

parents
\begin_inset Quotes erd
\end_inset

 table twice during the join.
 Hmm...
 what was that bit, about explicit graph-walking, again?
\end_layout

\end_inset

 Looking at it this way, prolog 
\begin_inset Quotes eld
\end_inset

wants
\begin_inset Quotes erd
\end_inset

 to live in a database.
 Yet it doesn't.
\end_layout

\begin_layout Standard
So, yes, superficially, databases and execution are orthogonal concerns.
 But if one begins to look at what people actually do, in practice, with
 SQL, and how, in practice, they design code for object-relational databases,
 that orthogonality gets a bit fuzzy.
 It's downright cloudy by the time one is writing PL/SQL statements.
 Coming from the opposite direction, as prolog does, makes the 
\begin_inset Quotes eld
\end_inset

separation of concerns
\begin_inset Quotes erd
\end_inset

 even cloudier.
\end_layout

\begin_layout Subsubsection*
Intermediate Languages
\end_layout

\begin_layout Standard
These aren't even the only examples.
 Inside of compilers, one finds 
\begin_inset Quotes eld
\end_inset

intermediate languages
\begin_inset Quotes erd
\end_inset

.
 For Microsoft, this is the CIL or Common Intermediate Language.
 For Gnu GCC, it is GIMPLE.
 For LLVM, it is the LLVM IR.
 These are somewhat like assembly code, but abstract, and not specific to
 CPU hardware.
 They encode abstract syntax trees, and thus sit above the bytecode layer.
 Looking carefully, one will observe that 
\begin_inset Quotes eld
\end_inset

compiler optimization
\begin_inset Quotes erd
\end_inset

 actually consists of a very small database of the currently active, non-retired
 abstract syntax trees, and that optimization is a collection of re-write
 rules (in the sense of the prolog rewrite rule, above) being applied to
 the trees in the active database.
\end_layout

\begin_layout Standard
Of course, what happens inside a compiler is very narrow, and very carefully
 crafted to suite the needs of the compiler, and nothing more.
 This is a high art that has been honed over many decades.
 Intermediate languages are almost never written to disk, except as text
 strings.
 Yet the lessons they teach can be taken as generic: creating graphs, and
 then transforming them, via graph re-writing, is a generically useful operation.
 Representing knowledge as trees, and specifically, as typed meta-trees,
 offers a huge representational efficiency over plain graphs or SQL tables
 or key-value stores.
 The efficiency is both computational (RAM usage, CPU cycles) and expressive:
 writing inferences in prolog really is a lot easier than writing SQL statements.
\end_layout

\begin_layout Subsubsection*
Atomese
\end_layout

\begin_layout Standard
The above seems to be saying 
\begin_inset Quotes eld
\end_inset

typed metatrees are a programming language
\begin_inset Quotes erd
\end_inset

.
 This is true, and in the OpenCog AtomSpace, it actually is a language,
 called 
\begin_inset Quotes eld
\end_inset

Atomese
\begin_inset Quotes erd
\end_inset

.
 But what kind of language is it? Well, if one abstains from providing some
 large collection of Link and Node types, then the answer is 
\begin_inset Quotes eld
\end_inset

any kind at all
\begin_inset Quotes erd
\end_inset

.
 The metatrees provide just enough structure, just enough groundwork, to
 create your own language.
 This is vaguely comparable to lex and yacc: these are just some basic tools
 that allow competent users to design custom, user-defined languages.
 Likewise here: metatrees offer the toolset needed to design a custom knowledge
 representation system.
 Perhaps offering a built-in 
\family sans
\emph on
IfLink
\family default
\emph default
, 
\family sans
\emph on
GreaterThanLink
\family default
\emph default
, 
\family sans
\emph on
PlusLink
\family default
\emph default
 and 
\family sans
\emph on
VariableNode
\family default
\emph default
 is a good idea, and perhaps not.
 Nothing compels a metagraph database system to offer these; at the same
 time, it makes it easy to offer these.
 To some large degree, it is sufficient to offer a typed metagraph storage
 system, and nothing more.
\end_layout

\begin_layout Standard
The OpenCog AtomSpace does this, but it also tacks on more than 100 different
 predefined Atom types.
 This is effectively a historical accident, having to do with how it evolved.
 A strong case could be made for splitting out this vast assortment of predefine
d types into their own module.
 This is easier said than done; the AtomSpace continues to be a research
 platform for the concepts described here.
\end_layout

\begin_layout Section*
Conclusion
\end_layout

\begin_layout Standard
Several important claims were made here about metagraphs and metagraph stores.
 These are:
\end_layout

\begin_layout Itemize
Metagraphs are a simple and relatively minor generalization of graphs.
\end_layout

\begin_layout Itemize
Metagraphs are more representationally compact than graphs.
 They are more efficient at representing data.
\end_layout

\begin_layout Itemize
Table normalization, normally an intellectually demanding task for relational
 database design, comes 
\begin_inset Quotes eld
\end_inset

for free
\begin_inset Quotes erd
\end_inset

, when one works with metagraphs.
\end_layout

\begin_layout Itemize
Specifying metagraphs as text strings is easier than specifying graphs as
 strings.
\end_layout

\begin_layout Itemize
Typed metatrees can be abstract syntax trees; ordinary graphs cannot.
\end_layout

\begin_layout Itemize
Typed metagraphs provide a powerful under-girding for symbolic computing,
 not just for representing knowledge, but also carrying out the computations
 themselves.
\end_layout

\begin_layout Standard
This text started out as an attempt to describe the RAM and CPU usage properties
 of metagraphs, and unwittingly turned into a strong statement about the
 general utility of metagraphs as a foundational system.
 As such, it provides a strong statement about many of the design decisions
 that went into the OpenCog AtomSpace, which is the primary research vehicle
 for these ideas.
 Even so, it is not the culmination of the journey.
 The series of chapters in this directory are about sheaves.
 These provide a general connectionist approach to data representation,
 and the sheaf approach is different from metagraphs, having distinct representa
tional properties (including CPU and RAM usage).
 Understanding metagraphs is a key gateway to the sheaves project.
 Fortunately, the metagraph approach, taken by the current AtomSpace is
 fairly mature, having more than a decade of implementation and use experience
 behind it.
 This text gives a flavor of where it has arrived.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "lang"
options "tufte"

\end_inset


\end_layout

\end_body
\end_document
