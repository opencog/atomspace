#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Graphs, Sheaves, RAM, CPU
\end_layout

\begin_layout Author
Linas Vepstas
\end_layout

\begin_layout Date
2 Sept 2020 draft version 0.3
\end_layout

\begin_layout Abstract
Using connectors-and-sheaves for knowledge representation has distinct implicati
ons for RAM usage and CPU cycles.
 This text sketches and compares memory and CPU usage for three types of
 systems: a naive graph database, the current OpenCog AtomSpace, which is
 an in-RAM metagraph database, and a hypothetical connector-based database.
 The design constraints are such that several different kinds of typical
 knowledge-representation tasks must be efficient and performant; these
 include graph traversal (pattern matching), graph rewriting, and parsing
 (rule application).
\end_layout

\begin_layout Abstract
This is a work in progress ...
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
Currently, graph databases are popular, and they have a rather distinct
 performance profile, differing from SQL and noSQL databases.
 The connectors-and-sheaves concepts sketched in this series of texts provide
 a different way of representing graphs, and working with them.
 This representation is not just abstract nonsense, but has actual implications
 for RAM and CPU consumption.
 The current prototype experiments with sheaves are layered on top of the
 OpenCog AtomSpace, which is an in-RAM database for storing generalized
 hypergraphs or 
\begin_inset Quotes eld
\end_inset

metagraphs
\begin_inset Quotes erd
\end_inset

.
 It has it's own distinct representation, with certain implications for
 CPU and RAM utilization.
\end_layout

\begin_layout Standard
The goal of this text is to look at these three systems, and compare how
 they use RAM and CPU resources.
 Describing the AtomSpace is the easiest, because the current implementation
 has a specific form.
 Describing a graph database is a bit harder, as we assume a generic, naive
 design, which actual implementations may or may not follow.
 Describing the connectionist database presents similar trouble: without
 a specific implementation and the experience from using it, statements
 have to be generalized.
\end_layout

\begin_layout Standard
Each of these is described in turn, followed by a discussion of algorithms.
\end_layout

\begin_layout Section*
Graph Representations
\end_layout

\begin_layout Standard
Formally, a graph is
\end_layout

\begin_layout Itemize
A set of vertexes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of edges 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each edge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered pair of vertexes drawn from the set 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Standard
Because edges are ordered pairs, it is conventional to denote them with
 arrows, having a head and tail.
 These can be joined together in arbitrary ways.
 Below is a 
\begin_inset Quotes eld
\end_inset

typical
\begin_inset Quotes erd
\end_inset

 directed graph:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/directed-graph.png
	lyxscale 40
	width 30col%

\end_inset


\end_layout

\begin_layout Subsubsection*
Attributes
\end_layout

\begin_layout Standard
In practice, one wishes to associate a label to each vertex, and also some
 additional attribute data; likewise for the edges.
 There are two fundamental choices available for storing attributes: merged
 schema+data, and disjoint schema-data.
 An example of the first is JSON.
 Each bit of data to be stored is preceeded by it's name.
 Additional markup, such as quotes and square brackets, indicate if the
 data is a string or an array.
 An example of the second are tables.
 The name and data type appears only in the column heading; individual rows
 in the table do not need to repeat the schema.
 Clearly, the tabular format offers a huge advantage in terms of RAM usage.
 Conversely, it is highly inflexible when new columns or new schema need
 to be added.
 There is no sensible way to take one row of a table, and have it use a
 different schema than the other rows.
 It doesn't even make sense to talk about rows with a different schema.
\end_layout

\begin_layout Standard
Thus, in a graph store, one has these two choices for storing attributes,
 both for vertexes and for edges.
 One might even contemplate a mixture of both; after all, a JSON blob is
 isomorphic to a table with only a single row.
 The remainder of this text will make little or no assumptions about the
 storage format of the attributes.
 The details of attribute handling has little or no impact on the primary
 topics here, with possibly one exception: indexing.
 This is reviewed in a distinct section later on.
\end_layout

\begin_layout Subsubsection*
RAM vs.
 Disk
\end_layout

\begin_layout Standard
In what follows, all data is assumed to live in-RAM; the on-disk representations
 do not concern us.
 One reason for this is that a variety of disk management systems exist,
 and work quite well at abstracting details.
 The earliest such is perhaps the Berkeley DBM, and the Gnu gdbm.
 These have been followed by Google's LevelDB and Facebook's extensions
 RocksDB.
 It is usually not too hard to take an in-RAM database, and layer it on
 top of one of these systems to obtain a disk-backed database.
 Of course, there are numerous ifs-and-buts; these will be ignored in this
 text.
\end_layout

\begin_layout Subsubsection*
Representing graphs in RAM
\end_layout

\begin_layout Standard
Storing a set of vertexes in RAM is straight-forward.
 Since it is a set, one can use either a hash-table, a b-tree, or even an
 array or list.
 For the discussion here, the precise format used is not directly relevant,
 and so a tabular format will be used to illustrate the ideas.
 Again, the table rows might actually reside in hash-tables, b-trees, or
 wherever.
\end_layout

\begin_layout Standard
The vertex table is straight-forward:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The goal of having a vertex id (which is necessarily a 
\begin_inset Quotes eld
\end_inset

universally unique id
\begin_inset Quotes erd
\end_inset

 or uid) is that it is required by the edge table.
 The edge table might have the form
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
head-vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tail-vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
77
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
88
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
99
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This representation is perhaps too naive.
 To perform a graph traversal, i.e.
 to walk from vertex to vertex, following only connecting edges, one needs
 to know which edges come in, and which edges go out.
 Of course, these can be found in the edge table, but searching the edge
 table is absurd: for an edge table of 
\begin_inset Formula $N$
\end_inset

 edges, such a search takes 
\begin_inset Formula $O\left(N\right)$
\end_inset

 time.
 Thus, we incorporate a special index for edges into the vertex table:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
outgoing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{77}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{77}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88,99}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that the incoming and outgoing columns hold sets: any given vertex
 may appear in more than one edge.
 They are sets, not lists, as the order is not particularly important.
 They are not 
\begin_inset Quotes eld
\end_inset

multisets
\begin_inset Quotes erd
\end_inset

: any given edge appears at most once in the incoming/outgoing sets.
 Suitable representations for sets include hash-tables and trees, each with
 it's own distinct RAM and access-time profile.
\end_layout

\begin_layout Subsubsection*
Prelude to indexing
\end_layout

\begin_layout Standard
A conventional requirement for graph databases is to locate all nodes and
 vertexes having some particular attribute.
 This opens a Pandora's box of indexing schemes.
 The opening of this box is deferred to a later section, but we can take
 a quick peak: suppose one wants to find all vertexes where the json-data
 has a field called 
\begin_inset Quotes eld
\end_inset

favorite song
\begin_inset Quotes erd
\end_inset

.
 Vertexes representing buildings and automobiles won't have a 
\begin_inset Quotes eld
\end_inset

favorite song
\begin_inset Quotes erd
\end_inset

, vertexes representing people might, but not necessarily.
 Thus, we need to create an index: a set of all vertexes that have this
 tag.
 Every time a vertex is added or removed, this index might have to be updated.
 Thus, adding indexes in this way incurs a CPU overhead.
 If there are 
\begin_inset Formula $J$
\end_inset

 indexes, then there is an 
\begin_inset Formula $O\left(J\right)$
\end_inset

 CPU overhead for vertex insertion/removal.
 There is also RAM consumption: an index containing 
\begin_inset Formula $K$
\end_inset

 items requires at least 
\begin_inset Formula $O\left(K\right)$
\end_inset

 storage, and possibly 
\begin_inset Formula $O\left(K\log K\right)$
\end_inset

.
\end_layout

\begin_layout Section*
Hypergraphs
\end_layout

\begin_layout Standard
A hypergraph is much like a graph, except that the edges, now called 
\begin_inset Quotes eld
\end_inset

hyperedges
\begin_inset Quotes erd
\end_inset

 can contain more than two vertexes.
 That is, the hyperedge, rather than being an ordered pair of vertexes,
 is an ordered list of vertexes.
 The metagraph takes the hypergraph concept one step further: the hyperedge
 may also contain other hyperedges.
 A change of terminology is useful: the basic objects are now called 
\begin_inset Quotes eld
\end_inset

nodes
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

links
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

vertexes
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

edges
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Formally, a hypergraph is:
\end_layout

\begin_layout Itemize
A set of vertexes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of hyperedges 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each hyperedge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered list of vertexes drawn from the set 
\begin_inset Formula $V$
\end_inset

.
 This list may be empty, or have one, or two, or more members.
\end_layout

\begin_layout Standard
A metagraph is very nearly the same:
\end_layout

\begin_layout Itemize
A set of nodes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of links 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each hyperedge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered list of nodes, or other links.
 It is convenient to call these 
\begin_inset Quotes eld
\end_inset

atoms
\begin_inset Quotes erd
\end_inset

: an atom can be either a node, or a link.
 Links are thus sets of atoms.
\end_layout

\begin_layout Subsection*
Hypergraph representations
\end_layout

\begin_layout Standard
The naive representation for the hypergraph is a straight-forward extension
 of the edge table.
 The example encoded in this table is shown in the figure below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex-list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{1}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{1},v_{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{3},v_{4}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(v_{3},v_{2},v_{1}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The vertex list may be empty, may hold one, or more vertexes.
 It is necessarily ordered (and thus not a set) and may contain repeated
 entries (a vertex may appear more than once).
 In other respects, it is much the same.
\end_layout

\begin_layout Standard
As before, the ability to traverse the hypergraph is a hard requirement.
 This requires modification to the vertex table.
 Several choices are possible.
 One is to add a new column for each positional location:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge-set-0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge-set-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge-set-2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This requires a data-structure that is a list-of-sets, which can be a bit
 over-complex and challenging to use.
 It is easier to just mash all of these into one set; this is all that is
 needed for hypergraph traversal.
 If the positional location is needed, then it can always be looked up per-edge.
 This is neither technically challenging nor CPU-intensive: the arity of
 hyperedges is typically small, based on real-world mappings to interesting
 datasets.
 Thus, the vertex table can look like
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming-set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that the vertex table looks a lot like the edge table, the only difference
 being that the vertex-list is an ordered list, while the incoming-set (the
 edge-set) really is a set.
 Effectively, this is because a hypergraph is 
\begin_inset Quotes eld
\end_inset

almost
\begin_inset Quotes erd
\end_inset

 a bipartite graph, having the form below, with the set 
\begin_inset Formula $U$
\end_inset

 on the left being the set of hyperedges.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/hypergraph.eps
	lyxscale 60
	width 40col%

\end_inset


\end_layout

\begin_layout Standard
The boxes denote the fact that the hyperedges are ordered lists.
 The 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $V$
\end_inset

 ellipses are the hyperedge and vertex tables.
\end_layout

\begin_layout Subsubsection*
RAM Utilization
\end_layout

\begin_layout Standard
One might wish to conclude: 
\begin_inset Quotes eld
\end_inset

Oh, but a bipartite graph is just a graph, so a graph database is sufficient
 for all my needs.
\begin_inset Quotes erd
\end_inset

 At some abstract level, this is perhaps true; at the CPU and RAM-consumption
 level, it is not.
 So, in this figure, attributed (the json-data) are attached only to the
 
\begin_inset Formula $v_{k}$
\end_inset

 and 
\begin_inset Formula $e_{k}$
\end_inset

 in the diagram; there is no attribute data attached to the lines in this
 figure.
 What's more, the lines in this figure are not directly recorded in any
 tables; they are implicit only by the structure of the vertex and hyperedge
 tables.
\end_layout

\begin_layout Standard
Counting the memory usage is instructive.
 Lets assume that the size of the vertex-id and the edge-id are the same
 – they are pointers or 64-bit ints – so each id requires 1 unit of RAM.
 Assume that lists are either null-terminated or record a length, so that
 a list of 
\begin_inset Formula $n$
\end_inset

 items requires 
\begin_inset Formula $n+1$
\end_inset

 units of storage.
 Lets encode sets as lists, to make counting easy; let 
\begin_inset Formula $J$
\end_inset

 is the average size of the attribute collection.
 The hyperedges shown in the figure then require 2+3+3+4=12 units of storage,
 plus 5 more for the hyperedge table itself, and 4J of attribute storage.
 The vertexes require 4+3+3+2 units of storage, plus 5 for the vertex-table
 itself, plus 4J more of attributes.
 Summing this, one obtains 34+8J total RAM consumption.
 For the general case, one has
\begin_inset Formula 
\[
N_{V}\left(1+\left\langle J\right\rangle +\left\langle N_{I}\right\rangle \right)+N_{E}\left(1+\left\langle J\right\rangle +\left\langle N_{O}\right\rangle \right)
\]

\end_inset

 where
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N_{V}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of vertexes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $N_{E}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of hyperedges
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\langle J\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average size of attributes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average size of the incoming set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\langle N_{O}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average size of the vertex list
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The average size of the incoming set is equal to the average size of the
 vertex list, so we can approximate 
\begin_inset Formula $\left\langle N_{I}\right\rangle =\left\langle N_{O}\right\rangle $
\end_inset

; the only reason to track these separately is that one may use hash tables
 or trees for sets, whereas lists require arrays.
\end_layout

\begin_layout Standard
The equivalent representation as a graph requires
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\left(N_{V}+N_{E}\right)\left(1+\left\langle J\right\rangle \right)+N_{V}\left\langle N_{I}\right\rangle +N_{E}\left\langle N_{O}\right\rangle  & \quad\mbox{ for the vertex table}\\
N_{V}\left\langle N_{I}\right\rangle \left(3+\left\langle J_{nil}\right\rangle \right) & \quad\mbox{ for the edge table}
\end{align*}

\end_inset

Comparing the two expressions, we see that the vertex table is the same
 size as the complete hypertable.
 The ordinary graph representation also requires the overhead of the edge
 table; here the 
\begin_inset Formula $\left\langle J_{nil}\right\rangle $
\end_inset

 is the cost of storing an empty attribute list, and the factor of 3 comes
 from storing an ordinary edge-id and it's two endpoints.
\end_layout

\begin_layout Subsubsection*
Storing hypergraphs in graphs, and vice-versa
\end_layout

\begin_layout Standard
If the only thing that one is storing are hypergraphs, then having a custom
 hypergraph representation really is smaller than the equivalent bipartite
 graph: it dispenses with the need for an explicit ordinary-edge table.
 Does this mean that there's some magic, here? No, not really.
 Every ordinary graph is a special case of a hypergraph, where the hyper-edge
 always has arity two.
 To store a single edge as an ordinary edge, we need 
\begin_inset Formula $3+\left\langle J\right\rangle $
\end_inset

 units of storage: the edge-label, and the two vertexes in the edge.
 To store a single edge as a hyperedge, we need 
\begin_inset Formula $4+\left\langle J\right\rangle $
\end_inset

 units of storage: the edge-label, the list of vertexes, and the list terminator.
 Thus, storing an ordinary graph as a hypergraph requires 
\begin_inset Formula $N_{E}$
\end_inset

 more units of storage.
 This seems tolerable: for a million-edge graph, and 64-bit pointers, this
 requires 8MBytes of additional storage.
 On modern machines, the extra 8MBytes seems not all that large; there's
 a bit of a penalty in moving from graph storage to hypergraph storage,
 but it's not that much.
 Modern cellphones have 8GBytes of RAM...
\end_layout

\begin_layout Standard
Moving in the opposite direction is much worse: the penalty is 
\begin_inset Formula $N_{V}\left\langle N_{I}\right\rangle \left(3+\left\langle J_{nil}\right\rangle \right)$
\end_inset

 which is surprisingly large.
 Assuming that 
\begin_inset Formula $\left\langle J_{nil}\right\rangle =1$
\end_inset

, then a million-vertex graph requires 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 times 32MBytes of additional storage.
 For uniformly-distributed graphs, one might have 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 of 3 to 10; for scale-free graphs of this size, 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 might be around 14; for square-root-Zipfian graphs (such as Wikipedia page
 views, or biological datasets: genome, proteome, reactome datasets) the
 
\begin_inset Formula $\left\langle N_{I}\right\rangle $
\end_inset

 would be around 200
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The average size of the incoming set is 
\begin_inset Formula 
\[
\left\langle N_{I}\right\rangle =\frac{1}{N_{V}}\int_{1}^{N_{V}}n\left(v\right)dv
\]

\end_inset

where 
\begin_inset Formula $n\left(v\right)$
\end_inset

 is the number of connections to vertex 
\begin_inset Formula $v$
\end_inset

 and 
\begin_inset Formula $N_{V}$
\end_inset

 is the total number of vertexes.
 For a Zipfian distribution, this is
\begin_inset Formula 
\[
\left\langle N_{I}\right\rangle =\frac{1}{N_{V}}\int_{1}^{N_{V}}\frac{N_{V}}{v}dv=\log N_{V}
\]

\end_inset

while for a square-root-Zipfian, one has 
\begin_inset Formula 
\[
\left\langle N_{I}\right\rangle =\frac{1}{N_{V}}\int_{1}^{N_{V}}\frac{AN_{V}}{\sqrt{v}}dv=2A\sqrt{N_{V}}
\]

\end_inset

The scale factor 
\begin_inset Formula $A$
\end_inset

 is data-dependent.
 For Wikipedia page views, 
\begin_inset Formula $A\approx20$
\end_inset

, see https://en.wikipedia.org/wiki/Wikipedia:Does_Wikipedia_traffic_obey_Zipf%27s
_law%3F for graphs and discussion.
 For genomics, see https://github.com/linas/biome-distribution/blob/master/paper/
biome-distributions.pdf where 
\begin_inset Formula $A$
\end_inset

 is in the range of 0.1 to 0.3, depending on the dataset.
 These last estimates are a bit glib, as the specifics of the datasets are
 quite subtle.
 Still, one may conclude that these considerations have quite dramatic implicati
ons for graph stores.
\end_layout

\end_inset

, so we are looking at overheads in the gigabyte range.
 There is a huge cost of jamming a hypergraph into an ordinary graph store.
\end_layout

\begin_layout Standard
XXX TODO This is making some rather strong claims about RAM usage, and really
 needs to be quadruple-checked and strengthened.
 It's a bit breezy and casual, as written.
 XXX TODO.
\end_layout

\begin_layout Subsection*
Metagraph representations
\end_layout

\begin_layout Standard
The metagraph differs from the hypergraph in that now a hyperedge (link)
 may contain either another vertex (node) or another link.
 Visually, this is no longer a bipartite graph, but has the shape of a directed
 acyclic graph (DAG), such as the one shown below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/metagraph.eps
	lyxscale 60
	width 20col%

\end_inset


\end_layout

\begin_layout Standard
The primary difference between the above, and a DAG is that the links are
 ordered lists, represented as boxes in this diagram.
 For lack of a better name, this can be called a 
\begin_inset Quotes eld
\end_inset

metatree
\begin_inset Quotes erd
\end_inset

.
 The metatree can be converted to a DAG in two different ways.
 One way is to collapse the boxes to single points.
 The other way is to dissolve the boxes entirely, and replace a single arrow
 from point-to-box by many arrows, from point to each of the box elements.
\end_layout

\begin_layout Standard
The node table is effectively the same as the vertex table for the hypergraph,
 before.
 For this graph, it is
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
node id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming-set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{3}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{1},e_{2}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{2},e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The link table now requires both an outgoing-atom list, and an incoming-link
 list.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
link id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
outgoing-list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming-set
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attr-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(n_{1},n_{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(n_{1},n_{3}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{3}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(e_{1},e_{2},n_{1},e_{2}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ e_{4}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(e_{3},n_{3}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \cdot\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Notice how this link-table resembles the vertex-table of an ordinary graph
 store: it has columns for both incoming and outgoing 
\begin_inset Quotes eld
\end_inset

sets
\begin_inset Quotes erd
\end_inset

; the outgoing-set, however, is not a set but an ordered list.
 In terms of designing storage, the naive graph tables, the hypergraph tables,
 and the metagraph tables seem to have much in common.
 This is, however, perhaps a bit deceptive, as performance considerations
 dictate the finer aspects of the design.
\end_layout

\begin_layout Standard
Clearly, the metagraph, having the general shape of a DAG, can be wedged
 into an ordinary graph store.
 Conversely, an ordinary graph is merely a metagraph that never goes more
 than one-level deep, and whose links always have arity-two.
 Either format is adequate for representing the other.
 The metagraph, much like the hypergraph, has no need to explicitly declare
 the arrows in the tree; they are not stored, nor do they have attributes.
 The RAM-usage considerations are much like those for the hypergraph.
 More interesting is the structure of indexes, or rather, the alternatives
 one has for index representation.
\end_layout

\begin_layout Section*
Indexing
\end_layout

\begin_layout Standard
The whole point of using a graph database, as opposed to an SQL or noSQL
 database, is that the graph structure encodes something important about
 the problem, something that cannot be easily achieved by doing table joins
 or key-value look-ups.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In the following, only SQL databases will be discussed.
 The noSQL databases are effectively identical, from our perspective, as
 they are categorical opposites: that is, all arrows reversed.
 This was explicitly articulated in a famous paper by Meijer and Bierman.
\begin_inset CommandInset citation
LatexCommand cite
key "Meijer2011"
literal "false"

\end_inset

 Thus, in the discussions below, if you are more familiar with noSQL, then
 simply reverse the directions of all arrows to obtain the equivalent discussion.
\end_layout

\end_inset

 However, just as with table-based databases, there are certain types of
 queries that are used a lot, and speeding these up through indexing is
 a key ability.
 How might this work, in practice? Let's examine some queries, and see how
 they might work.
\end_layout

\begin_layout Subsection*
Single attribute queries
\end_layout

\begin_layout Standard
Suppose one wishes to find all nodes with some specific attribute.
 Naively, this requires walking over all nodes, examining the attached attribute
 structure, extracting a named field from the attributes, and examining
 the value of that field.
 This is a task that SQL databases excel at - for example, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT name,salary FROM employees WHERE department='sales';
\family default
\emph default

\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The author would like to apologize for this seemingly non-sexy example.
 It is the stereotypical example from database textbooks, and harks back
 to the 1960's, when working out the fine details of management science
 actually was a sexy research topic, and helped power the economic ascent
 of the Western world.
 It's importance should not be under-estimated: Ancient Rome was an agrarian
 civilization built on concepts of hierarchical organization; organizational
 hierarchies will continue to describe reality, including AGI.
 Org-charts are boring but important.
\end_layout

\end_inset

 A graph database is not needed for this task.
 Nonetheless, this is a plausible task.
 The traditional solution would be 
\begin_inset Quotes eld
\end_inset


\family sans
CREATE INDEX ON employees(department);
\family default

\begin_inset Quotes erd
\end_inset

 which results in the creation of ordered pairs 
\begin_inset Formula $\left(D,\left\{ R\right\} \right)$
\end_inset

 with 
\begin_inset Formula $D$
\end_inset

 the name of the department, and 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

 the set of all records having that value.
 The 
\family typewriter
\emph on
SELECT
\family default
\emph default
 is then straight-forward: it need only return 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

.
 Note that the size of this index is 
\begin_inset Formula $O\left(N\right)$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the number of employees.
 This is necessarily so: one cannot build an index smaller than the number
 of employees: every employee must be in some department, as, conventionally,
 table-driven databases don't have null entries in rows.
 (Well, in practice, they often do; but now imagine the task of finding
 all records with a null value in some column...) Table-based information also
 has some representational difficulties: imagine the case of an employee
 with dashed-line reporting to multiple departments.
\end_layout

\begin_layout Standard
How might one accomplish indexing like this in a graph database? The simplest,
 most naive answer is to create new, 
\begin_inset Quotes eld
\end_inset

privileged
\begin_inset Quotes erd
\end_inset

 vertexes, one vertex per department.
 They are 
\begin_inset Quotes eld
\end_inset

privileged
\begin_inset Quotes erd
\end_inset

, in that the associated attributes record one and only one value: the name
 of the department.
 Basically, the vertexes are labeled, thus escaping the overhead of crawling
 through a collection of attributes to find one in particular.
 One also created an unlabeled, attribute-free edge, from the department
 name back to the full employee record.
 Finding all employees in 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 is now trivial: one can trivially find the vertex 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

, and trace all edges to the full record.
 The contents of the graph database, after indexing, is illustrated below.
 Before indexing, the vertexes 
\begin_inset Formula $v_{6},v_{7},v_{8}$
\end_inset

 and edges 
\begin_inset Formula $e_{1},e_{2},e_{3},e_{4},e_{5}$
\end_inset

 simply did not exist.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/partial-index.eps
	width 70col%

\end_inset


\end_layout

\begin_layout Standard
The size of this structure is again 
\begin_inset Formula $O\left(N\right)$
\end_inset

 for 
\begin_inset Formula $N$
\end_inset

 employees, assuming every employee is indexed.
 It has some rather unusual properties: not every employee has to be indexed!
 It is possible to create only one vertex, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

, and hook up edges to only that one.
 Effectively, one has a partial-index, with correspondingly less RAM usage!
 Of course, with some cleverness, an experienced DBA can achieve the same
 effect: 
\begin_inset Quotes eld
\end_inset


\family sans
CREATE INDEX ON employees(department) WHERE department=sales;
\family default

\begin_inset Quotes erd
\end_inset

 and this is not a big deal, so, here, at least, graphs do not offer any
 particular advantage.
 Under the covers, the SQL databases effectively has more-or-less the same
 format, although their graph-based nature is 
\emph on
ad hoc
\emph default
, as there are no explicit graph-walking directives in SQL.
\end_layout

\begin_layout Standard
The key point here is that, in a properly-designed graph database, there
 is no generic need for 
\begin_inset Quotes eld
\end_inset

indexes
\begin_inset Quotes erd
\end_inset

 
\emph on
per se
\emph default
, they can be conjured into being as they are ultimately graphical in nature.
 In the graph database, the graph structure of the index is explicit, and
 can be walked.
\end_layout

\begin_layout Subsection*
Space and Time
\end_layout

\begin_layout Standard
Comparing RAM-usage, at first glance, there is no particular difference.
 Naively, both require 
\begin_inset Formula $O\left(N\right)$
\end_inset

 for 
\begin_inset Formula $N$
\end_inset

 employees, plus 
\begin_inset Formula $O\left(M\right)$
\end_inset

 for 
\begin_inset Formula $M$
\end_inset

 different departments.
 Looking more carefully, there are also the edges 
\begin_inset Formula $e_{1},e_{2},e_{3},e_{4},e_{5}$
\end_inset

.
 In the SQL case, these edges were implicit in the index: after all, the
 index was a collection of ordered pairs 
\begin_inset Formula $\left(D,\left\{ R\right\} \right)$
\end_inset

: the edges run from 
\begin_inset Formula $D$
\end_inset

 to 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

.
 In the graph representation, these edges become explicit: that is, they
 appear in an explicit table, with attached attributes, even if the attributes
 are null.
 Shades of hypergraphs! Why, this was exactly the 
\emph on
same
\emph default
 situation as with the hypergraph! Squinting more carefully, the indexed
 employee table is nothing other than a bipartite graph! Thus, one can effective
ly say: the indexes in an SQL database are 
\emph on
de facto
\emph default
 hypergraphs under the covers, even though no one ever explicitly says so.
 The bipartite nature of the graph makes this explicit.
 Surprise!
\end_layout

\begin_layout Standard
CPU usage considerations are harder to dissect.
 To avoid discussions of network overhead in client-server architectures,
 its easier, here, to limit discussions to databases that run in the same
 address space as the application.
 Thus, for SQL bench-marking, one might look at SQLite, which runs embedded,
 rather than Postgres, which requires network interfaces.
 Queries usually begin life as strings, for example, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT name,salary FROM employees WHERE department='sales';
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 was a string that had to be parsed to figure out 
\begin_inset Quotes eld
\end_inset

what to do
\begin_inset Quotes erd
\end_inset

.
 Let's assume that this cost has been amortized, and that there is a way
 to get a handle to a query that has already been analyzed.
 Query run-time execution is then a matter of finding the vertex 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

, tracing the edges to each of the employees, and completing the work by
 analyzing each employee.
 If vertexes themselves are indexed (as they should be), then locating the
 vertex 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 is either 
\begin_inset Formula $O\left(1\right)$
\end_inset

 for hash tables, or 
\begin_inset Formula $O\left(\log V\right)$
\end_inset

 for trees.
 In the hypergraph representation, finding the set 
\begin_inset Formula $\left\{ R\right\} $
\end_inset

 of employees in 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sales
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 comes for free.
 The dominant cost is almost surely the analysis needed to extract the desired
 information from the record attributes.
\end_layout

\begin_layout Subsection*
Partial indexes
\end_layout

\begin_layout Standard
The power of partial indexes together with metagraphs begins to reveal itself
 when one considers several examples.
 Sticking with the management example from above, one extend and look at
 organizational structures (org charts).
\end_layout

\begin_layout Standard
Conventionally, corporations, political and military organizations are organized
 hierarchically, with divisions reporting to executives, departments rolling
 up into divisions, and so on.
 This is precisely the structure of a metatree.
 It is tempting to gloss this, and see the org chart is a tree, or perhaps
 a DAG.
 It is not! It is a metatree, and confusion arises because a metatree can
 be collapsed to a DAG in several different ways.
 So, consider a division chief who manages a line.
 One can draw the org-chart several ways: by drawing a line from a manager
 to each (named) employee that they manage, or from a manager to functional
 box labelled with the function.
 Employees are then grouped inside these functional boxes.
 This is shown below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/org-chart.eps
	lyxscale 70
	width 25col%

\end_inset


\end_layout

\begin_layout Standard
This is manifestly in the shape of a metatree.
 It can be collapsed down to an ordinary directed tree in several ways,
 left to the imagination of the reader.
 The point is that the natural structure of an org chart is not a naive
 tree; it contains a bit more complexity than that, and is far more readily
 represented with a metatree.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is hardly the only way to represent an org-chart with a meta-tree.
 One could put the department titles into boxes of thier own, as well as
 perhaps the names of the actual people, adding even some dashed-line cross-func
tional reporting structures.
 The point here is that it is not 
\begin_inset Quotes eld
\end_inset

just a tree
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The conceptual jump here is then: rather than stopping with a single-level
 hypergraph, where there are 
\begin_inset Quotes eld
\end_inset

tables
\begin_inset Quotes erd
\end_inset

, and then there are 
\begin_inset Quotes eld
\end_inset

indexes
\begin_inset Quotes erd
\end_inset

 that are 
\begin_inset Quotes eld
\end_inset

on top of tables
\begin_inset Quotes erd
\end_inset

, one can go further: indexes of indexes: namely, the metagraph.
\end_layout

\begin_layout Standard
The implication for RAM usage is similar to that of 
\begin_inset Quotes eld
\end_inset

database normalization
\begin_inset Quotes erd
\end_inset

.
 In a naive table format, one might store, for each employee, the employee
 name, the department, the 2nd line, the division and the name of the company.
 This is a bit silly in terms of storage: 5 columns are needed; for 
\begin_inset Formula $N$
\end_inset

 employees, this requires 
\begin_inset Formula $O\left(5N\right)$
\end_inset

 storage.
 One 
\begin_inset Quotes eld
\end_inset

normalizes
\begin_inset Quotes erd
\end_inset

 by storing only the employee-department relationship with a table of 
\begin_inset Formula $O\left(2N\right)$
\end_inset

 in size, and the remainder of the org chart in a separate table, also of
 two columns, encoding the directed tree reporting structure.
 This offers a huge space savings.
 Look-ups proceed through table joins: to find all employees in a division,
 one looks up what 2nd lines report to the division, what departments report
 to the second line, and what employees report to the departments.
 The indexing proceeds just as described in the previous section.
 The table joins are an 
\emph on
ad hoc
\emph default
 graph walk.
 The SQL for this is a bit nasty, but still effectively human-readable:
 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT employees.name FROM employees, orgchart WHERE employees.department=orgchart.
dept AND orgchart.division='marketing & sales';
\family default
\emph default

\begin_inset Quotes erd
\end_inset

.
 This SQL snippet is oversimplified by quite a bit, but it does convey the
 general spirit of the thing.
 It is attempting to specify a graph-walk without explicitly acknowledging
 that there is a graph hidden under the covers.
\end_layout

\begin_layout Standard
The key message here is that metagraphs retain the key benefits of table
 normalization, while making the graphical nature of indexing explicit.
 This is an actual improvement over graph stores: by discarding the edge
 table, and the associated edge attributes, one gets the representational
 compactness of indexes, without paying a high price for them.
\end_layout

\begin_layout Section*
Queries and pattern matching
\end_layout

\begin_layout Standard
Query/pattern-matching algorithms on graphs are necessarily recursive.
 This is because every graph can be decomposed into a collection of trees,
 and tree-walks are recursive.
 The metagraph makes this decomposition trivial: it is alrready in the form
 of a collection of trees (metatrees), and so has natural starting, ending
 and turn-around points.
\end_layout

\begin_layout Subsection*
Metatrees, JSON and s-expressions
\end_layout

\begin_layout Standard
The propery way of representing a meta-tree as a string can be mildly confusing
 to the beginer.
 Consider again the generic example:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/metagraph.eps
	lyxscale 60
	width 20col%

\end_inset


\end_layout

\begin_layout Standard
This can be written as 
\begin_inset Formula $\left(e_{4}:\left(e_{3}:\left(e_{1}:n_{1},n_{2}\right),\left(e_{2}:n_{2},n_{3}\right),n_{1},\left(e_{2}:n_{2},n_{3}\right)\right),n_{3}\right)$
\end_inset

 or perhaps, with indentation, but without parenthesis (python-style aka
 
\begin_inset Quotes eld
\end_inset

significant whitespace
\begin_inset Quotes erd
\end_inset

) to improve readability: 
\begin_inset Formula 
\[
\begin{array}{cccc}
e_{4}: & e_{3}: & e_{1}: & n_{1}\\
 &  &  & n_{2}\\
 &  & e_{2}: & n_{2}\\
 &  &  & n_{3}\\
 &  & n_{1}\\
 &  & e_{2}: & n_{2}\\
 &  &  & n_{3}\\
 & n_{3}
\end{array}
\]

\end_inset

To understant this last, indentation matters.
 A strange thing has happened here: the nodes 
\begin_inset Formula $n_{1},n_{2}$
\end_inset

 and 
\begin_inset Formula $n_{3}$
\end_inset

 appear in multiple places, yet they are supposed to be 
\begin_inset Quotes eld
\end_inset

the same thing
\begin_inset Quotes erd
\end_inset

.
 Likewise for 
\begin_inset Formula $e_{2}$
\end_inset

, which appears twice, but is meant to be the same 
\begin_inset Formula $e_{2}$
\end_inset

 both times.
\end_layout

\begin_layout Standard
This presents a difficulty for JSON.
 Ordinary JSON does not support object references; there is no way to say
 the 
\begin_inset Formula $e_{2}$
\end_inset

 and the 
\begin_inset Formula $n_{k}$
\end_inset

's are 
\begin_inset Quotes eld
\end_inset

the same thing
\begin_inset Quotes erd
\end_inset

.
 There is an IETF draft standard for references, but it is not widely used.
 Thus, although metatrees can be represented with JSON, some care must be
 taken when parsing them: one must find all repeated objects and understand
 them to be universally unique.
 That is, one must replace all repeated objects by universally unique references.
\end_layout

\begin_layout Standard
It is very tempting, at this point, to write 
\begin_inset Quotes eld
\end_inset

just use universally unique identifiers
\begin_inset Quotes erd
\end_inset

 (UUID's).
 This is good enough for local address spaces; if nothing else, then an
 ordinary C/C++ pointer is a UUID to the object.
 However, UUID's cause major, fundamental problems when considering network-dist
ributed storage; this is the problem of UUID collision.
 One solution is to have a single centralized atomic issuer of ID's that
 can gauranteee uniqueness.
 This introduces a single centralized bottleneck.
 Another solution is to use cryptographic hashes.
 Each meta-tree string can be hashed down to a number.
 To avoid collisions due to the birthday paradox, the hashes have to be
 quite large.
 For 1 million distinct atoms, a 64-bit hash and crossed fingers should
 be enough; uncrossing the fingers requires at least a 96-bit hash.
 For a trillion atoms, a 128-bit hash is just barely enough and a 192-bit
 hash is preferred.
 These eat up RAM (as compared to pointers) and the computation of cryptographic
 hashes requires significant CPU overhead.
\end_layout

\begin_layout Standard
Merely adding references to JSON is not enough to solve the problem, either.
 There may be millions or billions of meta-trees; forcing the user correctly
 employ references across all of them, without error is unreasonable.
 Worse: new meta-trees could be added weeks or months apart.
 Using references would force the user to maintain a table of references
 over long time periods.
 How? Where shall this table be stored? How much RAM will it require? References
 can be convenient, but they don't solve the fundamental representational
 problem for metatrees.
\end_layout

\begin_layout Standard
When a metatree is added to a metagraph, a scan must be made to determine
 if the tree, or any subtree already occurs in the metagraph.
 This does require indexing on the metagraph.
 Using indexes as described in the previous section introduces a bit of
 a checken-and-egg problem.
 Thus, at the meta-graph store level, a naked b-tree or hash table is required.
 Here, (non-cryptographic) hashes are useful, as they can be made small,
 and the hash table itself resolves any collisions.
 This disambiguation adds to the cost of insertion and eletion into a metagraph
 store.
\end_layout

\begin_layout Standard
This can be contrasted with relational (SQL) stores.
 In SQL, tables have primary keys; these are the primary indexes for each
 row.
 They are always made explicit; a table schema is declared with one of the
 columns designated as 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
PRIMARY KEY
\family default
\emph default

\begin_inset Quotes erd
\end_inset

.
 In a metagraph, each distinct node and link is ...
 distinct, and unique.
 No explicit declaration is needed; uniqueness is implicit in the defintion.
\end_layout

\begin_layout Standard
Since nodes and links (atoms) are unique, the subscripts on the hyperedges
 are not required.
 Nor is the use of the colon.
 The above is representable with the S-expression
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		(Link
\end_layout

\begin_layout Plain Layout

			(Link
\end_layout

\begin_layout Plain Layout

				(Link
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

one
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

two))
\end_layout

\begin_layout Plain Layout

				(Link
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

				(Node 
\begin_inset Quotes eld
\end_inset

one
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

				(Link
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

					(Node 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\begin_layout Plain Layout

			(Node 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset

The same considerations about repeated objects apply.
\end_layout

\begin_layout Subsection*
Types and Atomese
\end_layout

\begin_layout Standard
Perhaps the most interesting aspect of the s-expression format is the first
 explicit appearance of types.
 Here, there are just two types: the nodes, and the links.
 The nodes have to be given a a name, so as to disambiguate them from one-anothe
r.
 The links do not: the metatree structure is enough to disambiguate one
 link from another.
 Again: nodes and links are naturally universally unique (or conversely,
 every node having the same name, every link having the same structure is
 indistinguishable.)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is eerily similar to atomic physics.
 All electrons are indistinguishable.
 All protons are indistinguishable.
 When combined into atoms, however, this changes.
 An element of one type (say, carbon) is clearly different than another
 (say, oxygen), but all carbon atoms are indistinugishable...
 unless they appear in an organic molecule.
 That is, it is the relationship of elementary particles to one-another
 that gives structure to the universe.
 It is not the particles themselves.
\end_layout

\end_inset

 When written in this form, the doubly-typed nature of the metatree is calling
 out for generalization.
\end_layout

\begin_layout Standard
Multiple types are not stricly needed for storage: indeed, the two tables,
 one for nodes, and one for links, is sufficient to tell apart which is
 which.
 Storing a new, distinguished tag: the node or link type, with each node
 or link does require additional storage.
 In practice, types are incredibly useful, and if not given explicit, distinguis
hed treatment, would have appeared in the attribute section.
 By 
\begin_inset Quotes eld
\end_inset

types
\begin_inset Quotes erd
\end_inset

 it is meant both the types of computer science, and of type theory.
 In ordinary programming, ints, floats and strings are types (these are
 the 
\begin_inset Quotes eld
\end_inset

primitive types
\begin_inset Quotes erd
\end_inset

), and so are object-oriented classes (these are the 
\begin_inset Quotes eld
\end_inset

compound types
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

product types
\begin_inset Quotes erd
\end_inset

).
 Function calls have a type signature too, and ML, CaML, Haskell and F#
 are all about programming with types.
 For the case of metagraphs, there is no particular need to limit oneself
 to a proscribed set of primitive types, one can have as many dfferrent
 primitive types as desired.
\end_layout

\begin_layout Standard
Metagraphs fit well with type theory: it is easy, effectively trivial to
 represent product types, sum types and signatures with metagraphs.
 This in turn opens the door to a very unusual propertype of metagraphs:
 each type can be backed by executable code.
 To illustrate, consider the case of an abstract syntax tree.
 Conventionally, one says that an expression, such as 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
if (a > b) return a+b;
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 can be represented by an abstract syntax tree.
 For the case of metatrees, the representation is 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		(IfLink
\end_layout

\begin_layout Plain Layout

			(GreaterThanLink
\end_layout

\begin_layout Plain Layout

				(VariableNode 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

				(VariableNode 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

			(PlusLink
\end_layout

\begin_layout Plain Layout

				(VariableNode 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

				(VariableNode 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This not only represents the expression 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
if (a > b) return a+b;
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 but it can also be made active: when supplied with values for the variables,
 the comparison and the addition can be explicitly performed.
\end_layout

\begin_layout Standard
This is a key property that (typed) metatrees have, and that ordinary (typed
 or untyped) graphs do not.
 Ordinary graphs are not, in general, DAGs: they can contain cycles.
 Erecting an abstract syntax tree structure on an ordinary graph store is
 not natural.
 Now, of course, one could limit onself to using only DAG's, but the designer
 of any graph store would strenously object to adding this as a fundamental
 property of the graph store itself.
 The executation of expressions is 
\begin_inset Quotes eld
\end_inset

orthogonal
\begin_inset Quotes erd
\end_inset

 to the storage of graphs.
 The tasks have 
\begin_inset Quotes eld
\end_inset

orthogonal concerns
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

non-overlaping concerns
\begin_inset Quotes erd
\end_inset

.
 Strangely, metatrees erase that orthogonality.
\end_layout

\begin_layout Standard
This is most easily seen by looking at something like ProLog.
 It's a programming language, of course.
 It makes abstract syntax trees fairly explicit: it is hard to understand
 how prology works, unless one learns to think in terms of trees.
 Certainly, the 
\begin_inset Quotes eld
\end_inset

cut operator
\begin_inset Quotes erd
\end_inset

 in prolog is one of the early stumbling blocks for programmers learning
 prolog.
 It's hard to see what it does, until one realizes that it is literally
 cutting branches off of a tree.
 At the same time, chapter one, the very first chapter of any book on prolog
 programming is rife with examples of knowledge representation.
 One will find something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

		father_child(tom, erica).
\end_layout

\begin_layout Plain Layout

		father_child(mike, tom).
\end_layout

\begin_layout Plain Layout

		sibling(X, Y)      :- parent_child(Z, X), parent_child(Z, Y).
\end_layout

\end_inset

The first two statements are assertions of fact, the third is a inference
 rule.
 They have a very obvious represention as trees, and, more precisely as
 meta-trees.
 Yet, strangely, the prolog program is encoded in a text file, and 
\emph on
not
\emph default
 as a collection of entries in a graph database!
\end_layout

\begin_layout Standard
This last observation becomes truly bizarre, if one imagines keeping census
 data in prolog.
 Maintaining a text file with dozens of lines of code for millions of people
 is abusrd.
 Applying transformations is impossible for text files.
 Consider the inference 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sibiling
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 above.
 It can be taken as a run-time directive, but it can also be taken as a
 graph rewrite rule: find all graphs having two terms, 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
parent_child(Z, X)
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
parent_child(Z, Y)
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 and crate a new term 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
sibling(X, Y)
\family default
\emph default

\begin_inset Quotes erd
\end_inset

.
 Such a rewrite is not all that hard in a database; in SQL, some appropriate
 combination of 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
SELECT INTO
\family default
\emph default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family sans
\emph on
JOIN
\family default
\emph default

\begin_inset Quotes erd
\end_inset

, the only stumbling block being the need to reference the 
\begin_inset Quotes eld
\end_inset

parents
\begin_inset Quotes erd
\end_inset

 table twice during the join.
\end_layout

\begin_layout Standard
So, yes, superficially, databases and execution are orthogonal concerns.
 But if one begins to lok at what people do, in practice, with SQL, and
 how, in practice, they design code for object-relational databases, that
 orthogonality gets a bit fuzzy.
 It's downright cloudy by the time one is writing PL/SQL statements.
 Coming from the opposite direction, as prolog does, makes the case even
 cloudier.
\end_layout

\begin_layout Standard
These aren't even the only examples.
 Inside of compilers, one finds 
\begin_inset Quotes eld
\end_inset

intermediate languages
\begin_inset Quotes erd
\end_inset

.
 For Micorosft, this is the CIL or Common Intermediate Language.
 For Gnu GCC, it is gimple.
 These are somewhat like assembly code, but abstract, and not specific to
 CPU hardware.
 They encode abstract syntax trees, and thus sit above the bytecode layer.
 Looking carefully, one will observe that 
\begin_inset Quotes eld
\end_inset

compiler optimization
\begin_inset Quotes erd
\end_inset

 is actually a vary small database of the currrently active, non-retired
 abstract syntax trees, and that optimization is a collection of re-write
 rules (in the sense of the prolog rewrite rule, above) being applied to
 the trees in the active database.
\end_layout

\begin_layout Standard
Of course, what happens inside a compiler is very narrow, and veery carefully
 crafted to suite the needs of the compiler, and nothing more.
 Intermediate languages are almost never written to disk, except as text
 strings.
 Yet the lessons can be taken as generic: creating graphs, and then transforming
 them, is a generically useful operation.
 Representing graphs as trees, and specifically, as type meta-trees, offers
 a huge representational efficiency over plain graphs or SQL/noSQL tables.
 The efficiency is both computational (RAM usage, CPU cycles) and expressive:
 writing inferences in prolog really is a lot easier than writing SQL statements.
\end_layout

\begin_layout Subsubsection*
Summary
\end_layout

\begin_layout Standard
Key points:
\end_layout

\begin_layout Itemize
Metatrees can be thought of as either s-expressions or as json.
 But with a cactch...
\end_layout

\begin_layout Itemize
Walks are explicit: one moves up or down the trees e.g.
 the car, cdr of lisp, but also the tinkerpop/gremlin primitives for graph-walki
ng.
\end_layout

\begin_layout Itemize
Tree walks are a prime example of a recursive algorithm, requiring a stack
 machine to execute, and describable by a context-free grammar.
\end_layout

\begin_layout Itemize
This means tree walks can be automated.
 Rather than designing a search query where the user explicitly states the
 walk/path to be performed (tinkerpop/gremlin), a context-free grammar can
 be used to describe the search, which is then executed by the stack machine.
 This is what 
\begin_inset Quotes eld
\end_inset

pattern matching
\begin_inset Quotes erd
\end_inset

 actually is.
\end_layout

\begin_layout Section*
Connectors and Sheaves
\end_layout

\begin_layout Standard
Only now do we get to the main act...
\end_layout

\begin_layout Itemize
Specifying (context-free) grammars in a natural way.
\end_layout

\begin_layout Itemize
Parsing as jigsaw-puzzle assembly
\end_layout

\begin_layout Itemize
RAM and CPU costs of storing jigsaw pieces
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "lang"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
