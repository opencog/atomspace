#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Graphs, Sheaves, RAM, CPU
\end_layout

\begin_layout Author
Linas Vepstas
\end_layout

\begin_layout Date
2 Sept 2020
\end_layout

\begin_layout Abstract
Using connectors-and-sheaves for knowledge representation has distinct implicati
ons for RAM usage and CPU cycles.
 This text sketches and compares memory and CPU usage for three types of
 systems: a naive graph database, the current OpenCog AtomSpace, which is
 an in-RAM metagraph database, and a hypothetical connector-based database.
 The design constraints are such that several different kinds of typical
 knowledge-repesentation tasks must be efficient and performant; these include
 graph traversal (patten matching), graph rewriting, and parsing (rule applicati
on).
\end_layout

\begin_layout Abstract
This is a work in progress ...
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
Currently, graph databases are popular, and they have a rather distinct
 performance profile, differing from SQL and noSQL databases.
 The connectors-and-sheaves concepts sketched in this series of texts provide
 a different way of representing graphs, and working with them.
 This representation is not just abstract nonsense, but has actual implications
 for RAM and CPU consumption.
 The current prototype experiments with sheaves are layered on top of the
 OpenCog AtomSpace, which is an in-RAM database for storing generalized
 hypergraphs or 
\begin_inset Quotes eld
\end_inset

metagraphs
\begin_inset Quotes erd
\end_inset

.
 It has it's own distinct representation, with certain implications for
 CPU and RAM utilization.
\end_layout

\begin_layout Standard
The goal of this text is to look at these three systems, and compare how
 they use RAM and CPU resources.
 Describing the AtomSpace is the easiest, because the current implementation
 has a specific form.
 Describing a graph database is a bit harder, as we assume a generic, naive
 design, which actual implementatins may or may not follow.
 Describing the connectionist database presents similar trouble: without
 a specific implementation and the experience from using it, statements
 have to be generalized.
\end_layout

\begin_layout Standard
Each of these is described in turn, followed by a discussion of algorithms.
\end_layout

\begin_layout Section*
Graph Representations
\end_layout

\begin_layout Standard
Formally, a graph is
\end_layout

\begin_layout Itemize
A set of vertexes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of edges 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each edge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered pair of vertexes drawn from the set 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Standard
Because edges are ordered pairs, it is conventional to denote them with
 arrows, having a head and tail.
 These can be joined together in arbitrary ways.
 Bewlow is a 
\begin_inset Quotes eld
\end_inset

typical
\begin_inset Quotes erd
\end_inset

 graph:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/directed-graph.png
	lyxscale 40
	width 30col%

\end_inset


\end_layout

\begin_layout Standard
In practice, one wishes to associate a label to each vertex, and also some
 additional attribute data; likewise for the edges.
 At this time, the JSON format is a very powerful and flexible way of encoding
 attribute data: it can encode variable format structured data consisting
 of strings, numbers, arrays and othre kinds of data.
 Thus, for the remainder of this text, it is assumed that attributes are
 encoded in a JSON format.
 There are a variety of ways of encoding JSON; this alone is a substantial
 task, and detailed discussions of this are mostly avoided, except as may
 be relevant.
\end_layout

\begin_layout Standard
In what follows, all data is assumed to live in-RAM; the on-disk representations
 do not concern us.
 One reason for this is that a variety of disk management systems exist,
 and work quite well at abstracting details.
 The earliest such is perhaps the Berkley DBM, and the Gnu gdbm.
 These have been followed by Google's LevelDB and Facebook's extensions
 RocksDB.
 It is usually not too hard to take an in-RAM database, and layer it on
 top of one of these systems to obtain a disk-backed database.
 Of course, there are numerous ifs-ands-buts, here, these are glossed over.
\end_layout

\begin_layout Standard
The vertex table is straight-forward:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The goal of having a vertex id (which is necessarily a 
\begin_inset Quotes eld
\end_inset

universaly unique id
\begin_inset Quotes erd
\end_inset

 or uid) is that it is required by the edge table.
 The edge table might have the form
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
edge id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
head-vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tail-vertex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
77
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
88
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
99
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This representation is perhaps too naive.
 To perform a graph traversal, i.e.
 to walk from vertex to vertex, following only connecting edges, one needs
 to know which edges come in, and which edges go out.
 Of course, these can be found in the edge table, but searching the edge
 table is absurd: for an edge table of 
\begin_inset Formula $N$
\end_inset

 edges, such a search takes 
\begin_inset Formula $O\left(N\right)$
\end_inset

 time.
 Thus, we incorporate a special index for edges into the vertex table:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertex id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incoming
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
outgoing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
json-data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{77}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{77}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88,99}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{88}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that the incoming and outgoing columns hold sets: any given vertex
 may appear in more than one edge.
 They are sets, not lists, as the order is not particularly important.
 They are not 
\begin_inset Quotes eld
\end_inset

multisets
\begin_inset Quotes erd
\end_inset

: any given edge appears at most once in the incoming/outgoing sets.
 Suitable representations for sets include hash-tables and trees, each with
 it's own distinct RAM and access-time profile.
\end_layout

\begin_layout Standard
A conventional requirement for graph databases is to locate all nodes and
 vertexes having some particular attribute.
 This opens a pandoras box of indexing schemes.
 The opening of this box is defered to a later section, but we can take
 a quick peak: suppose one wants to find all vertexes where the json-data
 has a field called 
\begin_inset Quotes eld
\end_inset

favorite song
\begin_inset Quotes erd
\end_inset

.
 Vertexes representing buildings and automobiles won't have a 
\begin_inset Quotes eld
\end_inset

favorite song
\begin_inset Quotes erd
\end_inset

, vertexes representing people might, but not necessarily.
 Thus, we need to create an index: a set of all vertexes that have this
 tag.
 Every time a vertex is added or removed, this index might have to be updated.
 Thus, adding indexes in this way incurs a CPU overhead.
 If there are 
\begin_inset Formula $J$
\end_inset

 indexes, then there is an 
\begin_inset Formula $O\left(J\right)$
\end_inset

 CPU overhead for vertex insertion/removal.
 There is also RAM consumption: an index containing 
\begin_inset Formula $K$
\end_inset

 items requires at least 
\begin_inset Formula $O\left(K\right)$
\end_inset

 storage, and possibly 
\begin_inset Formula $O\left(K\log K\right)$
\end_inset

.
\end_layout

\begin_layout Section*
Hypergraphs
\end_layout

\begin_layout Standard
Formally, a hypergraph is:
\end_layout

\begin_layout Itemize
A set of vertexes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of hyperedges 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each hyperedge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered list of vertexes drawn from the set 
\begin_inset Formula $V$
\end_inset

.
 This list may be empty, or have one, or two, or more members.
\end_layout

\begin_layout Standard
A metagraph is very nearly the same:
\end_layout

\begin_layout Itemize
A set of nodes 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{M}\right\} $
\end_inset


\end_layout

\begin_layout Itemize
A set of links 
\begin_inset Formula $E=\left\{ e_{1},e_{2},\cdots,e_{N}\right\} $
\end_inset

 where each hyperedge 
\begin_inset Formula $e_{k}$
\end_inset

 is an ordered list of nodes, or other links.
\end_layout

\begin_layout Standard
polytree
\end_layout

\begin_layout Section*
The AtomSpace
\end_layout

\begin_layout Standard
The AtomSpace is an in-RAM generalized hypergraph or 
\begin_inset Quotes eld
\end_inset

metagraph
\begin_inset Quotes erd
\end_inset

 database.
 A hypergraph is much like a graph, except that the edges, now called 
\begin_inset Quotes eld
\end_inset

hyperedges
\begin_inset Quotes erd
\end_inset

 can contain more than two vertexes.
 That is, the hyperedge, rather than being an ordered pair of vertexes,
 is an ordered list of vertexes.
 The metagraph takes the hyperggraph concept one step further: the hyperedge
 may also contain other hyperedges.
 A change of terminology is useful: the basic objects are now called 
\begin_inset Quotes eld
\end_inset

nodes
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

links
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

vertexes
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

edges
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_body
\end_document
