/*
 * BackwardChainerUTest.cxxtest
 *
 *  Created on: Oct 20, 2014
 *      Author: misgana
 */
#include <opencog/rule-engine/backwardchainer/BackwardChainer.h>
#include <opencog/rule-engine/UREConfigReader.h>
#include <opencog/guile/SchemeEval.h>
#include <opencog/guile/SchemeSmob.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/util/Config.h>
#include <opencog/guile/load-file.h>

using namespace opencog;
//#define DEBUG 1
class BackwardChainerUTest: public CxxTest::TestSuite
{
private:
	AtomSpace *as_;
	SchemeEval* eval_;
	BackwardChainer * bc_;

public:
	BackwardChainerUTest()
	{
		logger().setLevel(Logger::DEBUG);
		logger().setPrintToStdoutFlag(true);

		as_ = new AtomSpace();
		eval_ = new SchemeEval(as_);
	}

	~BackwardChainerUTest()
	{
		delete eval_;
	}

	void setUp();
	void tearDown();

	//void test_unify();
	//void test_filter_rules();

	void test_1rule_bc();
	void test_2rules_bc();

	void test_tvq_bc();
};

void BackwardChainerUTest::setUp()
{
	config().set("SCM_PRELOAD",
	             "opencog/atomspace/core_types.scm, "
	             "opencog/scm/utilities.scm, "
	             "opencog/scm/av-tv.scm"
	             );
	load_scm_files_from_config(*as_);
}

void BackwardChainerUTest::tearDown()
{
	as_->clear();
}
/*
void BackwardChainerUTest::test_unify()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	// empty BackwardChainer without rules
	BackwardChainer bc(as_, std::vector<Rule>());

	Handle x = as_->addNode(VARIABLE_NODE, "$x"),
		y = as_->addNode(VARIABLE_NODE, "$y"),
		z = as_->addNode(VARIABLE_NODE, "$z"),
		west = as_->addNode(CONCEPT_NODE, "west"),
		a = as_->addNode(VARIABLE_NODE, "$a"),
		nono = as_->addNode(CONCEPT_NODE, "nono");

	string target =
		"(EvaluationLink"
		"    (PredicateNode \"sell\")"
		"    (ListLink"
		"        (VariableNode \"$x\")"
		"        (VariableNode \"$y\")"
		"        (VariableNode \"$z\")))";
	Handle htarget = eval_->eval_h(target);

	string match =
		"(EvaluationLink"
		"    (PredicateNode \"sell\")"
		"    (ListLink"
		"        (ConceptNode \"west\")"
		"        (VariableNode \"$a\")"
		"        (ConceptNode \"nono\")))";

	Handle hmatch = eval_->eval_h(match);
	VarMap result;
	bc.unify(htarget, hmatch, Handle::UNDEFINED, result);

	for (const auto& kv : result) {
		std::cout << "Key = " << kv.first->toString()
		          << "Value = " << kv.second->toString() << std::endl;
	}

	TS_ASSERT_EQUALS(result.size(), 3);
	TS_ASSERT_EQUALS(result[x], west);
	TS_ASSERT_EQUALS(result[y], a);
	TS_ASSERT_EQUALS(result[z], nono);

	logger().debug("END TEST: %s", __FUNCTION__);
}

void BackwardChainerUTest::test_filter_rules()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	// load 2 rules
	JsonicControlPolicyParamLoader cpolicy_loader(JsonicControlPolicyParamLoader(as_, "tests/rule-engine/bc_cpolicy_2.json"));
	cpolicy_loader.load_config();

	std::vector<Rule> rules;

	for (Rule* pr : cpolicy_loader.get_rules())
		rules.push_back(*pr);

	BackwardChainer bc(as_, rules);

	string kb_imp_str =
		"(ImplicationLink (stv .99 .99)"
		"    (AndLink"
		"        (InheritanceLink"
		"            (VariableNode \"$x\")"
		"            (ConceptNode \"American\"))"
		"        (InheritanceLink"
		"            (VariableNode \"$y\")"
		"            (ConceptNode \"weapon\"))"
		"        (EvaluationLink"
		"            (PredicateNode \"sell\")"
		"            (ListLink"
		"                (VariableNode \"$x\")"
		"                (VariableNode \"$y\")"
		"                (VariableNode \"$z\")))"
		"        (InheritanceLink"
		"            (VariableNode \"$z\")"
		"            (ConceptNode \"hostile\")))"
		"    (InheritanceLink"
		"        (VariableNode \"$x\")"
		"        (ConceptNode \"criminal\")))";
	Handle kb_imp = eval_->eval_h(kb_imp_str);

	Handle target =
		eval_->eval_h("(InheritanceLink"
		              "    (VariableNode \"$x\")"
		              "    (ConceptNode \"criminal\"))");

	vector<Rule> filtered_rules = bc.filter_rules(target);

	for (const Rule& r : filtered_rules)
		std::cout << "rule = " << r.get_name() << std::endl;

	// At least modus ponens should be in
	auto modus_ponens_it =
	        std::find_if(filtered_rules.begin(), filtered_rules.end(),
		             [](const Rule& r) {
			             return r.get_name() == "crisp-modus-ponens";
		             });
	TS_ASSERT_DIFFERS(modus_ponens_it, rules.end());

	logger().debug("END TEST: %s", __FUNCTION__);
}
*/
void BackwardChainerUTest::test_1rule_bc()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	config().set("SCM_PRELOAD",
	             "tests/rule-engine/bc-config-1.scm,"
	             "tests/rule-engine/bc-example.scm");
	load_scm_files_from_config(*as_);

	// load 1 modus ponens rule
	Handle top_rbs = as_->addNode(CONCEPT_NODE, UREConfigReader::URE_top_name);
	UREConfigReader config_reader(*as_, top_rbs);

	BackwardChainer bc(as_, config_reader.get_rules());

	Handle target_var = eval_->eval_h("(VariableNode \"$Z\")");
	Handle target =
	    eval_->eval_h("(InheritanceLink"
	                  "   (VariableNode \"$Z\")"
					  "   (ConceptNode \"green\"))");
	Handle soln = eval_->eval_h("(ConceptNode \"Fritz\")");

	bc.set_target(target);
	bc.do_until(100);

	VarMultimap results = bc.get_chaining_result();

	TSM_ASSERT("Incorrect number of solution found!", results[target_var].size() == 1);
	TSM_ASSERT("Getting incorrect solution!", results[target_var].count(soln) == 1);

	logger().debug("END TEST: %s", __FUNCTION__);
}

void BackwardChainerUTest::test_2rules_bc()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	config().set("SCM_PRELOAD",
	             "tests/rule-engine/bc-config-2.scm,"
	             "tests/rule-engine/bc-criminal.scm");
	load_scm_files_from_config(*as_);

	// load modus ponens & deduction rules
	Handle top_rbs = as_->addNode(CONCEPT_NODE, UREConfigReader::URE_top_name);
	UREConfigReader config_reader(*as_, top_rbs);

	BackwardChainer bc(as_, config_reader.get_rules());

	Handle target_var = eval_->eval_h("(VariableNode \"$x\")");
	Handle target =
	    eval_->eval_h("(InheritanceLink"
	                  "   (VariableNode \"$x\")"
					  "   (ConceptNode \"criminal\"))");
	Handle soln = eval_->eval_h("(ConceptNode \"West\")");

	bc.set_target(target);
	bc.do_until(300);

	VarMultimap results = bc.get_chaining_result();

	TSM_ASSERT("Incorrect number of solution found!", results[target_var].size() == 1);
	TSM_ASSERT("Getting incorrect solution!", results[target_var].count(soln) == 1);

	logger().debug("END TEST: %s", __FUNCTION__);
}

void BackwardChainerUTest::test_tvq_bc()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	config().set("SCM_PRELOAD",
	             "tests/rule-engine/bc-config-1.scm,"
	             "tests/rule-engine/bc-example.scm");
	load_scm_files_from_config(*as_);

	// load modus ponens
	Handle top_rbs = as_->addNode(CONCEPT_NODE, UREConfigReader::URE_top_name);
	UREConfigReader config_reader(*as_, top_rbs);

	BackwardChainer bc(as_, config_reader.get_rules());

	Handle target =
	    eval_->eval_h("(InheritanceLink (stv 0.0 0.0)"
	                  "   (ConceptNode \"Fritz\")"
					  "   (ConceptNode \"green\"))");

	bc.set_target(target);
	bc.do_until(100);

	TSM_ASSERT("Incorrect strength after BC!", target->getTruthValue()->getMean() > 0.9f);
	TSM_ASSERT("Incorrect confidence after BC!", target->getTruthValue()->getConfidence() > 0.9f);

	logger().debug("END TEST: %s", __FUNCTION__);
}
