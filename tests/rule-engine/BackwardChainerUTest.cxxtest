/*
 * BackwardChainerUTest.cxxtest
 *
 *  Created on: Oct 20, 2014
 *      Author: misgana
 */
#include <opencog/rule-engine/backwardchainer/BackwardChainer.h>
#include <opencog/rule-engine/backwardchainer/BackwardChainerPMCB.h>
#include <opencog/guile/SchemeEval.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/atoms/pattern/PatternLink.h>
#include <opencog/util/mt19937ar.h>

using namespace opencog;
//#define DEBUG 1

#define al _as.add_link
#define an _as.add_node

class BackwardChainerUTest: public CxxTest::TestSuite
{
private:
	AtomSpace _as;
	SchemeEval _eval;
	BackwardChainer* _bc;

	void reset_bc();

public:
	BackwardChainerUTest() : _eval(&_as)
	{
		logger().set_level(Logger::DEBUG);
		logger().set_timestamp_flag(false);
		// logger().set_sync_flag(true);
		logger().set_print_to_stdout_flag(true);
		randGen().seed(0);
	}

	void setUp();
	void tearDown();

	void test_select_rule_1();
	void test_select_rule_2();
	void test_select_rule_3();
	// void test_implication_instantiation();
	// void test_bc_modus_ponens();
	// void test_bc_deduction_1();
	void test_bc_deduction_2();
	// void test_impossible_bc();
	// void test_bc_modus_ponens_deduction();
	// void test_tvq_bc();
	// void test_tvq_impossible_bc();
	// void test_focus_set();
	// void test_virtual_no_grnd();
};

void BackwardChainerUTest::setUp()
{
	string cur_pp_dir = string(PROJECT_SOURCE_DIR),
		cur_p_dir = cur_pp_dir + "/tests",
		cur_dir = cur_p_dir + "/rule-engine";
	vector<string> load_paths = {cur_pp_dir, cur_p_dir, cur_dir};
	for (string& p : load_paths)
	{
		string eval_str = string("(add-to-load-path \"") + p + string("\")");
		_eval.eval(eval_str);
	}
	_eval.eval("(use-modules (opencog))");
	// _eval.eval("(use-modules (opencog rule-engine))");
}

void BackwardChainerUTest::tearDown()
{
	_as.clear();
}

void BackwardChainerUTest::reset_bc()
{
	delete(_bc);
	_as.clear();

	string eval_result =
		_eval.eval("(load-from-path \"tests/rule-engine/bc-config.scm\")");

	// std::cout << "eval_result = " << eval_result << std::endl;

	Handle top_rbs = _as.get_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);

	_bc = new BackwardChainer(_as, top_rbs, Handle::UNDEFINED);
}

// Test select rule with a target with no variable
void BackwardChainerUTest::test_select_rule_1()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	reset_bc();

	Handle target_h = _eval.eval_h("(Inheritance"
	                               "   (Concept \"A\")"
	                               "   (Concept \"B\"))");
	BITNode target(target_h);

	Rule selected_rule = _bc->select_rule(target);

	TS_ASSERT_EQUALS(selected_rule.get_name(), "bc-deduction-rule");
}

// Test select rule with a target with variables
void BackwardChainerUTest::test_select_rule_2()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	reset_bc();

	Handle target_h = _eval.eval_h("(Inheritance"
	                               "   (Concept \"A\")"
	                               "   (Variable \"$X\"))");
	BITNode target(target_h);

	Rule selected_rule = _bc->select_rule(target);

	TS_ASSERT_EQUALS(selected_rule.get_name(), "bc-deduction-rule");
}

// Test select rule with a target with variables with the same name as
// the variable in the rule.
void BackwardChainerUTest::test_select_rule_3()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	reset_bc();

	Handle target_h = _eval.eval_h("(Variable \"$C\")"),
		vardecl_h = _eval.eval_h("(TypedVariable"
		                         "   (Variable \"$C\")"
		                         "   (Type \"InheritanceLink\"))");
	BITNode target(target_h, vardecl_h);

	Rule selected_rule = _bc->select_rule(target);

	std::cout << "selected_rule = " << oc_to_string(selected_rule);

	TS_ASSERT_EQUALS(selected_rule.get_name(), "bc-deduction-rule");
}

// void BackwardChainerUTest::test_implication_instantiation()
// {
// 	logger().debug("BEGIN TEST: %s", __FUNCTION__);

// 	_as.clear();

// 	string result = _eval.eval("(load-from-path \"tests/rule-engine/implication-instantiation-config.scm\")");

// 	logger().debug() << "result = " << result;

// 	result = _eval.eval("(load-from-path \"tests/rule-engine/bc-friends.scm\")");
// 	randGen().seed(0);

// 	// load 1 modus ponens rule
// 	Handle top_rbs = _as.get_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);
// 	BackwardChainer bc(_as, top_rbs);

// 	Handle are_friends = an(PREDICATE_NODE, "are-friends"),
// 		john = an(CONCEPT_NODE, "John"),
// 		mary = an(CONCEPT_NODE, "Mary"),
// 		edward = an(CONCEPT_NODE, "Edward"),
// 		cyril = an(CONCEPT_NODE, "Cyril"),
// 		target_var = an(VARIABLE_NODE, "$what"),
// 		target = al(EVALUATION_LINK,
// 		            are_friends,
// 		            al(LIST_LINK,
// 		               john,
// 		               target_var));

// 	bc.set_target(target);
// 	bc.get_config().set_maximum_iterations(30);
// 	bc.do_chain();

// 	HandleMultimap results = bc.get_chaining_result();

// 	TS_ASSERT_EQUALS(results[target_var].size(), 3);
// 	TS_ASSERT_EQUALS(results[target_var].count(mary), 1);
// 	TS_ASSERT_EQUALS(results[target_var].count(edward), 1);
// 	TS_ASSERT_EQUALS(results[target_var].count(cyril), 1);

// 	logger().debug("END TEST: %s", __FUNCTION__);
// }

// void BackwardChainerUTest::test_bc_modus_ponens()
// {
// 	logger().debug("BEGIN TEST: %s", __FUNCTION__);

// 	_as.clear();

// 	string result = _eval.eval("(load-from-path \"tests/rule-engine/bc-modus-ponens-config.scm\")");
// 	std::cout << result << std::endl;
// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-animals.scm\")");
// 	randGen().seed(0);

// 	// load 1 modus ponens rule
// 	Handle top_rbs = _as.get_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);
// 	BackwardChainer bc(_as, top_rbs);

// 	Handle target_var = _eval.eval_h("(VariableNode \"$what\")");
// 	Handle target =
// 		_eval.eval_h("(InheritanceLink"
// 		             "   (VariableNode \"$what\")"
// 		             "   (ConceptNode \"green\"))");
// 	Handle soln = _eval.eval_h("(ConceptNode \"Fritz\")");

// 	bc.set_target(target);
// 	bc.get_config().set_maximum_iterations(300);
// 	bc.do_chain();

// 	HandleMultimap results = bc.get_chaining_result();

// 	TS_ASSERT_EQUALS(results[target_var].size(), 2);
// 	TS_ASSERT_EQUALS(results[target_var].count(soln), 1);

// 	logger().debug("END TEST: %s", __FUNCTION__);
// }

// void BackwardChainerUTest::test_bc_deduction_1()
// {
// 	logger().debug("BEGIN TEST: %s", __FUNCTION__);

// 	_as.clear();

// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-deduction-config.scm\")");
// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-transitive-closure.scm\")");
// 	randGen().seed(0);

// 	// load 1 deduction rule
// 	Handle top_rbs = _as.get_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);
// 	BackwardChainer bc(_as, top_rbs);

// 	Handle target_var = _eval.eval_h("(Variable \"$X\")"),
// 		target = _eval.eval_h("(Inheritance"
// 		                      "   (Concept \"A\")"
// 		                      "   (Variable \"$X\"))"),
// 		B = _eval.eval_h("(Concept \"B\")"),
// 		B1 = _eval.eval_h("(Concept \"B1\")"),
// 		B2 = _eval.eval_h("(Concept \"B2\")"),
// 		C = _eval.eval_h("(Concept \"C\")"),
// 		C1 = _eval.eval_h("(Concept \"C1\")"),
// 		C2 = _eval.eval_h("(Concept \"C2\")"),
// 		D = _eval.eval_h("(Concept \"D\")");

// 	bc.set_target(target);
// 	bc.get_config().set_maximum_iterations(100);
// 	bc.do_chain();

// 	HandleMultimap results = bc.get_chaining_result();

// 	TS_ASSERT_EQUALS(results[target_var].size(), 7);
// 	TS_ASSERT_EQUALS(results[target_var].count(B), 1);
// 	TS_ASSERT_EQUALS(results[target_var].count(B1), 1);
// 	TS_ASSERT_EQUALS(results[target_var].count(B2), 1);
// 	TS_ASSERT_EQUALS(results[target_var].count(C), 1);
// 	TS_ASSERT_EQUALS(results[target_var].count(C1), 1);
// 	TS_ASSERT_EQUALS(results[target_var].count(C2), 1);
// 	TS_ASSERT_EQUALS(results[target_var].count(D), 1);

// 	logger().debug("END TEST: %s", __FUNCTION__);
// }

void BackwardChainerUTest::test_bc_deduction_2()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	_as.clear();

	_eval.eval("(load-from-path \"tests/rule-engine/bc-deduction-config.scm\")");
	_eval.eval("(load-from-path \"tests/rule-engine/bc-transitive-closure.scm\")");
	randGen().seed(0);

	// load 1 deduction rule
	Handle top_rbs = _as.get_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);
	Handle target = _eval.eval_h("(Inheritance"
	                             "   (Concept \"A\")"
	                             "   (Concept \"D\"))");

	BackwardChainer bc(_as, top_rbs, target);
	bc.get_config().set_maximum_iterations(10);
	bc.do_chain();

	TS_ASSERT_DELTA(target->getTruthValue()->getMean(), 1, 1e-10);
	TS_ASSERT_DELTA(target->getTruthValue()->getConfidence(), 1, 1e-10);

	logger().debug("END TEST: %s", __FUNCTION__);
}

// void BackwardChainerUTest::test_impossible_bc()
// {
// 	logger().debug("BEGIN TEST: %s", __FUNCTION__);

// 	_as.clear();

// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-modus-ponens-config.scm\")");
// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-criminal.scm\")");
// 	randGen().seed(0);

// 	// load modus ponens rule
// 	Handle top_rbs = _as.get_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);
// 	BackwardChainer bc(_as, top_rbs);

// 	Handle target_var = _eval.eval_h("(VariableNode \"$who\")");
// 	Handle target =
// 	    _eval.eval_h("(InheritanceLink"
// 	                 "   (VariableNode \"$who\")"
// 	                 "   (ConceptNode \"criminal\"))");
// 	Handle soln = _eval.eval_h("(ConceptNode \"West\")");

// 	// should NOT be possible to find the solution without deduction rule
// 	bc.set_target(target);
// 	bc.get_config().set_maximum_iterations(1000);
// 	bc.do_chain();

// 	HandleMultimap results = bc.get_chaining_result();

// 	TSM_ASSERT("Incorrect number of solution found!",
// 	           results[target_var].size() == 1);
// 	TSM_ASSERT("Getting impossible solution!",
// 	           results[target_var].count(soln) == 0);

// 	logger().debug("END TEST: %s", __FUNCTION__);
// }

// void BackwardChainerUTest::test_bc_modus_ponens_deduction()
// {
// 	logger().debug("BEGIN TEST: %s", __FUNCTION__);

// 	_as.clear();

// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-config.scm\")");
// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-criminal.scm\")");
// 	randGen().seed(500);

// 	// load modus ponens & deduction rules
// 	Handle top_rbs = _as.get_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);
// 	BackwardChainer bc(_as, top_rbs);

// 	Handle target_var = _eval.eval_h("(VariableNode \"$who\")");
// 	Handle target =
// 		_eval.eval_h("(InheritanceLink"
// 		             "   (VariableNode \"$who\")"
// 		             "   (ConceptNode \"criminal\"))");
// 	Handle soln = _eval.eval_h("(ConceptNode \"West\")");

// 	bc.set_target(target);
// 	bc.get_config().set_maximum_iterations(1000);
// 	bc.do_chain();

// 	HandleMultimap results = bc.get_chaining_result();

// 	TSM_ASSERT("Incorrect number of solution found!",
// 	           results[target_var].size() == 2);
// 	TSM_ASSERT("Getting incorrect solution!",
// 	           results[target_var].count(soln) == 1);

// 	logger().debug("END TEST: %s", __FUNCTION__);
// }

// void BackwardChainerUTest::test_tvq_bc()
// {
// 	logger().debug("BEGIN TEST: %s", __FUNCTION__);

// 	_as.clear();

// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-modus-ponens-config.scm\")");
// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-animals.scm\")");
// 	randGen().seed(500);

// 	// load modus ponens
// 	Handle top_rbs = _as.get_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);
// 	BackwardChainer bc(_as, top_rbs);

// 	Handle target =
// 	    _eval.eval_h("(InheritanceLink (stv 0.0 0.0)"
// 	                 "   (ConceptNode \"Fritz\")"
// 	                 "   (ConceptNode \"green\"))");

// 	bc.set_target(target);
// 	bc.get_config().set_maximum_iterations(300);
// 	bc.do_chain();

// 	TSM_ASSERT("Incorrect strength after BC!",
// 	           target->getTruthValue()->getMean() > 0.9f);
// 	TSM_ASSERT("Incorrect confidence after BC!",
// 	           target->getTruthValue()->getConfidence() > 0.9f);

// 	logger().debug("END TEST: %s", __FUNCTION__);
// }

// void BackwardChainerUTest::test_tvq_impossible_bc()
// {
// 	logger().debug("BEGIN TEST: %s", __FUNCTION__);

// 	// This is kind of crazy, but ... but deleting the forced garbage
// 	// collection below causes the NEXT unit test to fail!  I don't
// 	// understand what's at the root of this bug. Some weird
// 	// indeterminism?
// 	_eval.eval("(gc)");
// 	_as.clear();

// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-modus-ponens-config.scm\")");
// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-animals.scm\")");
// 	randGen().seed(0);

// 	// load modus ponens
// 	Handle top_rbs = _as.add_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);
// 	BackwardChainer bc(_as, top_rbs);

// 	// negative test, BC should not modify the TV of this impossible target
// 	Handle target = _eval.eval_h("(InheritanceLink (stv 0.0 0.0)"
// 	                             "   (ConceptNode \"RandomName\")"
// 	                             "   (ConceptNode \"green\"))");

// 	// this is not the target, but the inference path should still actually
// 	// modify the TV
// 	Handle hidden = _eval.eval_h("(InheritanceLink (stv 0.0 0.0)"
// 	                             "   (ConceptNode \"Fritz\")"
// 	                             "   (ConceptNode \"Frog\"))");

// 	bc.set_target(target);
// 	bc.get_config().set_maximum_iterations(300);
// 	bc.do_chain();

// 	TSM_ASSERT("Incorrect strength of target after BC!",
// 	           target->getTruthValue()->getMean() < 0.1f);
// 	TSM_ASSERT("Incorrect confidence of target after BC!",
// 	           target->getTruthValue()->getConfidence() < 0.1f);
// 	TSM_ASSERT("Incorrect strength of sub-target after BC!",
// 	           hidden->getTruthValue()->getMean() > 0.9f);
// 	TSM_ASSERT("Incorrect confidence of sub-target after BC!",
// 	           hidden->getTruthValue()->getConfidence() > 0.9f);

// 	logger().debug("END TEST: %s", __FUNCTION__);
// }

// void BackwardChainerUTest::test_focus_set()
// {
// 	logger().debug("BEGIN TEST: %s", __FUNCTION__);

// 	_as.clear();

// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-modus-ponens-config.scm\")");
// 	_eval.eval("(load-from-path \"tests/rule-engine/bc-animals.scm\")");
// 	randGen().seed(0);

// 	// load 1 modus ponens rule
// 	Handle top_rbs = _as.get_node(CONCEPT_NODE, UREConfigReader::top_rbs_name);
// 	BackwardChainer bc(_as, top_rbs);

// 	Handle target_var = _eval.eval_h("(VariableNode \"$what\")");
// 	Handle target =
// 	        _eval.eval_h("(InheritanceLink"
// 	                     "   (VariableNode \"$what\")"
// 	                     "   (ConceptNode \"green\"))");
// 	Handle focus_set =
// 	        _eval.eval_h("(SetLink"
// 	                     " (InheritanceLink"
// 	                     "   (ConceptNode \"tree\")"
// 	                     "   (ConceptNode \"plant\"))"
// 	                     " (ImplicationLink (stv 1.0 1.0)"
// 	                     "   (InheritanceLink"
// 	                     "     (VariableNode \"$P\")"
// 	                     "     (ConceptNode \"plant\")"
// 	                     "   )"
// 	                     "   (InheritanceLink"
// 	                     "     (VariableNode \"$P\")"
// 	                     "     (ConceptNode \"green\")"
// 	                     "   )"
// 	                     " )"
// 	                     ")");
// 	Handle soln1 = _eval.eval_h("(ConceptNode \"tree\")");

// 	// should not be able to find this solution outside the focus set
// 	Handle soln2 = _eval.eval_h("(ConceptNode \"Fritz\")");

// 	bc.set_target(target, focus_set);
// 	bc.get_config().set_maximum_iterations(300);
// 	bc.do_chain();

// 	HandleMultimap results = bc.get_chaining_result();

// 	TS_ASSERT_EQUALS(results[target_var].size(), 2);
// 	TS_ASSERT_EQUALS(results[target_var].count(soln1), 1);
// 	TS_ASSERT_EQUALS(results[target_var].count(soln2), 0);

// 	logger().debug("END TEST: %s", __FUNCTION__);
// }

// /**
//  * Test the following pattern using the BackwardChainerPMCB
//  *
//  * (AndLink
//  *   (InheritanceLink
//  *     (ConceptNode "A")
//  *     (VariableNode "$X")
//  *   )
//  *   (InheritanceLink
//  *     (VariableNode "$X")
//  *     (VariableNode "$Y")
//  *   )
//  *   (NotLink
//  *     (IdenticalLink
//  *       (ConceptNode "A")
//  *       (VariableNode "$Y")
//  *     )
//  *   )
//  * )
//  *
//  * on the the following data:
//  *
//  * (InheritanceLink
//  *  (ConceptNode "A")
//  *   (ConceptNode "B")
//  * )/
// *
//  * (InheritanceLink
//  *   (ConceptNode "A")
//  *   (VariableNode "$X")
//  * )
//  *
//  * (InheritanceLink
//  *   (ConceptNode "B")
//  *   (ConceptNode "C")
//  * )
//  *
//  */
// void BackwardChainerUTest::test_virtual_no_grnd()
// {
// 	logger().debug("BEGIN TEST: %s", __FUNCTION__);

// 	_as.clear();

// 	// Define the pattern to match against.
// 	Handle
// 		A = an(CONCEPT_NODE, "A"),
// 		B = an(CONCEPT_NODE, "B"),
// 		C = an(CONCEPT_NODE, "C"),
// 		X = an(VARIABLE_NODE, "$X"),
// 		Y = an(VARIABLE_NODE, "$Y"),
// 		AX = al(INHERITANCE_LINK, A, X),
// 		XY = al(INHERITANCE_LINK, X, Y),
// 		NotIdAY = al(NOT_LINK, al(IDENTICAL_LINK, A, Y)),
// 		AB = al(INHERITANCE_LINK, A, B),
// 		BC = al(INHERITANCE_LINK, B, C),
// 		Concept = an(TYPE_NODE, "ConceptNode"),
// 		vardecl = al(VARIABLE_LIST,
// 		             al(TYPED_VARIABLE_LINK, X, Concept),
// 		             al(TYPED_VARIABLE_LINK, Y, Concept)),
// 		body = al(AND_LINK, AX, XY, NotIdAY),
// 		pattern = al(PATTERN_LINK, vardecl, body);

// 	PatternLinkPtr sl(PatternLinkCast(pattern));
// 	BackwardChainerPMCB pmcb(&_as, VariableListCast(vardecl), true);
// 	sl->satisfy(pmcb);

// 	const HandleMapSeq& var_solns = pmcb.get_var_list();
// 	const HandleMapSeq& pred_solns = pmcb.get_pred_list();

// 	TS_ASSERT_EQUALS(var_solns.size(), 1);
// 	TS_ASSERT_EQUALS(var_solns.front().size(), 2);
// 	TS_ASSERT_EQUALS(var_solns.front().at(X), B);
// 	TS_ASSERT_EQUALS(var_solns.front().at(Y), C);

// 	TS_ASSERT_EQUALS(pred_solns.size(), 1);
// 	TS_ASSERT_EQUALS(pred_solns.front().size(), 2);
// 	TS_ASSERT_EQUALS(pred_solns.front().at(AX), AB);
// 	TS_ASSERT_EQUALS(pred_solns.front().at(XY), BC);

// 	logger().debug("END TEST: %s", __FUNCTION__);
// }

#undef al
#undef an
