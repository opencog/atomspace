/*
 * ForwardChainer.cxxtest
 *
 *  Created on: Sep 2, 2014
 *      Author: misgana
 */
#include <boost/range/algorithm/find.hpp>

#include <opencog/util/Config.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/load-file.h>
#include <opencog/guile/SchemeEval.h>

#include <opencog/rule-engine/forwardchainer/ForwardChainer.h>
#include <opencog/rule-engine/forwardchainer/ForwardChainerCallBack.h>


using namespace opencog;

class ForwardChainerUTest: public CxxTest::TestSuite {
private:
	AtomSpace as_;
	SchemeEval eval_;
	ForwardChainer * fc_;

public:
	ForwardChainerUTest() : eval_(&as_)
	{
#undef DEBUG
		logger().setLevel(Logger::DEBUG);

		// Disable the AF mechanism during testing!
		as_.set_attentional_focus_boundary(AttentionValue::MINSTI);
		config().set("SCM_PRELOAD",
		             "opencog/atomspace/core_types.scm, "
		             "opencog/scm/utilities.scm, "
		             "opencog/scm/av-tv.scm");
		load_scm_files_from_config(as_);

		// add the following so that utilities.scm and av-tv.scm are
		// correctly loaded from crisp-deduction.scm
		eval_.eval("(add-to-load-path \"" PROJECT_SOURCE_DIR "/opencog/scm\")");

		// Load utilities.scm and rule-engine-utils.scm. Apparently
		// the modules' functions are not loaded
		eval_.eval("(load-from-path \"utilities.scm\")");
		eval_.eval("(load-from-path \"rule-engine-utils.scm\")");

		// Load the simple deduction example to test it
		eval_.eval("(load-from-path \"" PROJECT_SOURCE_DIR
		           "/examples/rule-engine/crisp-deduction.scm\")");

		// Get the ConceptNode corresponding to the rule-based system
		// to test
		Handle rbs = as_.get_node(CONCEPT_NODE, "crisp-deduction-rule-base");
		fc_ = new ForwardChainer(as_, rbs);
	}
	void test_do_chain();
};

void ForwardChainerUTest::test_do_chain()
{
	// Test simple deduction
	//
	// InheritanceLink A B
	// InheritanceLink B C
	// |-
	// InheritanceLink A C
	Handle A = eval_.eval_h("(PredicateNode \"A\" (stv 1 1))"),
		B = eval_.eval_h("(PredicateNode \"B\" (stv 1 1))"),
		C = eval_.eval_h("(PredicateNode \"C\" (stv 1 1))"),
		AB = eval_.eval_h("(ImplicationLink (stv 1 1)"
		                  "    (PredicateNode \"A\")"
		                  "    (PredicateNode \"B\"))"),
		BC = eval_.eval_h("(ImplicationLink (stv 1 1)"
		                  "    (PredicateNode \"B\")"
		                  "    (PredicateNode \"C\"))");

	// Run forward chainer
	ForwardChainerCallBack dfc(&as_);
	fc_->do_chain(dfc, AB);

	// Collect the results
	HandleSeq results = fc_->get_chaining_result();
	std::cout << "\ndo_chain results:" << std::endl;
	for (Handle h : results)
		std::cout << h->toString() << std::endl;

	// Check that AC is in the results
	Handle AC = as_.add_link(IMPLICATION_LINK, A, C);
	TS_ASSERT_DIFFERS(find(results.begin(), results.end(), AC), results.end());
}
