/**
 * tests/atomspace/UnifyUTest.cxxtest
 *
 * Copyright (C) 2016 OpenCog Foundation
 * All Rights Reserved
 * Author: Nil Geisweiller
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/util/Logger.h>

#include <opencog/atomutils/Unify.h>
#include <opencog/atoms/base/Context.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>

#include <cxxtest/TestSuite.h>

using namespace opencog;

#define al _as.add_link
#define an _as.add_node

class UnifyUTest :  public CxxTest::TestSuite
{
private:
	AtomSpace _as;
	SchemeEval _eval;
	Handle X, Y, Z, W, V, A, B, AB, XB, AY, XY, AZ, AW, AV,
		AndAA, AndAB, AndAY, AndXB, AndXY,
		AndAABB, AndXYAB, AndAAABBB, AndXXYYAB, AndAAAABBBB, AndXXXYYYAB,
		AndAAAAABBBBB, AndXXXXYYYYAB,
		CT, PT, IT, CPT,
		X_vardecl, X_cyclic_vardecl, Y_vardecl, Z_vardecl, W_vardecl, V_vardecl,
		XY_vardecl;
	Context::VariablesStack X_varstack;

public:
	UnifyUTest() : _eval(&_as)
	{
		logger().set_level(Logger::DEBUG);
		logger().set_print_to_stdout_flag(true);
		logger().set_timestamp_flag(false);

		X = an(VARIABLE_NODE, "$X");
		Y = an(VARIABLE_NODE, "$Y");
		Z = an(VARIABLE_NODE, "$Z");
		W = an(VARIABLE_NODE, "$W");
		V = an(VARIABLE_NODE, "$V");
		A = an(CONCEPT_NODE, "A");
		B = an(CONCEPT_NODE, "B");
		AB = al(INHERITANCE_LINK, A, B);
		XB = al(INHERITANCE_LINK, X, B);
		AY = al(INHERITANCE_LINK, A, Y);
		XY = al(INHERITANCE_LINK, X, Y);
		AZ = al(INHERITANCE_LINK, A, Z);
		AW = al(INHERITANCE_LINK, A, W);
		AV = al(INHERITANCE_LINK, A, V);
		AndAA = al(AND_LINK, A, A);
		AndAB = al(AND_LINK, A, B);
		AndAY = al(AND_LINK, A, Y);
		AndXB = al(AND_LINK, X, B);
		AndXY = al(AND_LINK, X, Y);
		AndAABB = al(AND_LINK, {A, A, B, B});
		AndXYAB = al(AND_LINK, {X, Y, A, B});
		AndAAABBB = al(AND_LINK, {A, A, A, B, B, B});
		AndXXYYAB = al(AND_LINK, {X, X, Y, Y, A, B});
		AndAAAABBBB = al(AND_LINK, {A, A, A, A, B, B, B, B});
		AndXXXYYYAB = al(AND_LINK, {X, X, X, Y, Y, Y, A, B});
		AndAAAAABBBBB = al(AND_LINK, {A, A, A, A, A, B, B, B, B, B});
		AndXXXXYYYYAB = al(AND_LINK, {X, X, X, X, Y, Y, Y, Y, A, B});
		CT = an(TYPE_NODE, "ConceptNode");
		PT = an(TYPE_NODE, "PredicateNode");
		IT = an(TYPE_NODE, "InheritanceLink");
		CPT = al(TYPE_CHOICE, CT, PT);
		X_vardecl = al(TYPED_VARIABLE_LINK, X, CT);
		X_cyclic_vardecl = al(TYPED_VARIABLE_LINK, X, IT);
		Y_vardecl = al(TYPED_VARIABLE_LINK, Y, CT);
		Z_vardecl = al(TYPED_VARIABLE_LINK, Z, CT);
		W_vardecl = al(TYPED_VARIABLE_LINK, W, PT);
		V_vardecl = al(TYPED_VARIABLE_LINK, V, CPT);
		XY_vardecl = al(VARIABLE_LIST,
		                al(TYPED_VARIABLE_LINK, X, CT),
		                al(TYPED_VARIABLE_LINK, Y, CT));

		Handle X_varlist = al(VARIABLE_LIST, X_vardecl);
		Variables X_CT_variables = VariableListCast(X_varlist)->get_variables();
		X_varstack.push_back(X_CT_variables);
	}

	void setUp();

	// type (TODO: should be moved elsewhere once the unification type
	// routines are moved elsewhere)
	void test_type_intersection();

	void test_join_1();
	void test_join_2();
	void test_join_3();

	void test_unify_without_var_1();
	void test_unify_without_var_2();

	void test_unify_basic_1();
	void test_unify_basic_2();
	void test_unify_basic_3();
	void test_unify_basic_4();
	void test_unify_basic_5();
	void test_unify_basic_6();
	void test_unify_basic_7();
	void test_unify_basic_8();

	// Variable declaration
	void test_unify_vardecl_1();
	void test_unify_vardecl_2();
	void test_unify_vardecl_3();
	void test_unify_vardecl_4();
	void test_unify_vardecl_5();

	// // Cyclic dependence
	// TODO: is it really needed?
	// void test_unify_cyclic_dependence_1();

	// // Type union
	// TODO: for that we need to support more powerful type
	// void test_unify_type_union_1();

	// Unordered link
	void test_unify_unordered_1();
	void test_unify_unordered_2();
	void test_unify_unordered_3();
	void test_unify_unordered_4();
	void test_unify_unordered_5();
	void test_unify_unordered_6();
	void test_unify_unordered_7();
	void test_unify_unordered_8();

	void test_unify_alpha_equivalence();

	void test_substitute();
	
	// Various complex unify queries
	void test_unify_complex_1();
	void test_unify_complex_2();
	void test_unify_complex_3();
	void test_unify_complex_4();
	void test_unify_complex_5();
	void test_unify_complex_6();
	void test_unify_complex_7();
};

void UnifyUTest::setUp(void)
{
}

void UnifyUTest::test_type_intersection()
{
	Handle lhs =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");
	Handle rhs =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Unify unify(lhs, rhs);
	Handle result = unify.type_intersection(lhs, rhs),
		expected = rhs;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_join_1()
{
	Unify unify(A, B);          // dummy unify construction to test join
	Unify::Block pb1{X, A};
	Unify::SolutionSet s1 = Unify::SolutionSet({{{pb1, A}}});
	Unify::Block pb2{X, B};
	Unify::SolutionSet s2 = Unify::SolutionSet({{{pb2, B}}}),
		result = unify.join(s1, s2),
		expected = Unify::SolutionSet(false);

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_join_2()
{
	Handle P = _eval.eval_h("(VariableNode \"$P\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_implicant =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	std::cout << "C = " << oc_to_string(C);
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	Unify unify(P, quoted_implicant); // dummy unify construction to test join
	Unify::Block pb1{P, implicant};
	Unify::SolutionSet s1 = Unify::SolutionSet({{{pb1, implicant}}});
	Unify::Block pb2{P, quoted_implicant};
	Unify::SolutionSet s2 = Unify::SolutionSet({{{pb2, quoted_implicant}}});
	Unify::SolutionSet result = unify.join(s1, s2);
	Unify::Block pb1_expected{P, implicant, quoted_implicant};
	Unify::Block pb2_expected{TyVs, Cimplicant_vardecl};
	Unify::Block pb3_expected{A1, Cimplicant_body};
	Unify::SolutionSet expected =
		Unify::SolutionSet({{{pb1_expected, implicant},
					         {pb2_expected, implicant_vardecl},
					         {pb3_expected, implicant_body}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

// Same as test_join_2 but using A2 as well. See test_complex_1
void UnifyUTest::test_join_3()
{
	Handle P = _eval.eval_h("(VariableNode \"$P\")");
	Handle Q = _eval.eval_h("(VariableNode \"$Q\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_LA1 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");

	Handle quoted_LA2 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A2\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	// dummy unify construction to test join
	Unify unify(al(AND_LINK, P, Q), al(AND_LINK, quoted_LA1, quoted_LA2));

	Unify::SolutionSet
		s1 = Unify::SolutionSet({{{{P, implicant}, implicant}}}),
		s2 = Unify::SolutionSet(
		           {{{{P, quoted_LA1}, quoted_LA1},
					 {{Q, quoted_LA2}, quoted_LA2}},
		            {{{Q, quoted_LA1}, quoted_LA1},
					 {{P, quoted_LA2}, quoted_LA2}}}),
		result = unify.join(s1, s2),
		expected = Unify::SolutionSet({{{{P, implicant, quoted_LA2},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             implicant_vardecl},
						                {{A2, Cimplicant_body},
								         implicant_body},
						                {{Q, quoted_LA1},
								         quoted_LA1}},
				                       {{{P, implicant, quoted_LA1},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             implicant_vardecl},
						                {{A1, Cimplicant_body},
								         implicant_body},
						                {{Q, quoted_LA2},
								         quoted_LA2}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_without_var_1()
{
	Unify unify(AB, A);
	Unify::SolutionSet result = unify(),
        expected(false);

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	// On top of that make sure that the solution is empty as it is
	// how failing is represented
	TS_ASSERT(result.empty());
}

void UnifyUTest::test_unify_without_var_2()
{
	Unify unify(AB, AB);
	Unify::SolutionSet result = unify(),
		expected(true);

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	// On top of that make sure that the solution is not empty as it
	// is how success is represented
	TS_ASSERT(not result.empty());
}

void UnifyUTest::test_unify_basic_1()
{
	Unify unify(X, A);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_2()
{
	Unify unify(A, X);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_3()
{
	Unify unify(X, AB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, AB}, AB}}});
	
	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_4()
{
	Unify unify(XB, AY);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}}});
	
	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_5()
{
	Unify unify(XY, AY);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_6()
{
	// This one is supposed to fail
	Unify unify(A, B);
	Unify::SolutionSet result = unify();

	std::cout << "result = " << oc_to_string(result) << std::endl;

	TS_ASSERT(not result.is_satisfiable());
}

void UnifyUTest::test_unify_basic_7()
{
	// This one is supposed to fail
	Unify unify(XB, B);
	Unify::SolutionSet result = unify();

	TS_ASSERT(not result.is_satisfiable());
}

void UnifyUTest::test_unify_basic_8()
{
	Unify unify(XY, AZ);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, Z}, Y}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_1()
{
	Unify unify(XY, AY, XY_vardecl, Y_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_2()
{
	Unify unify(XY, AY, XY_vardecl, Y_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_3()
{
	Unify unify(XB, AY, X_vardecl, Y_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}}});

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_4()
{
	Unify unify(XY, AZ, XY_vardecl, Z_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, Z}, Y}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_5()
{
	// This one is supposed to fail as the types of Y and W have empty
	// intersection.
	Unify unify(XY, AW, XY_vardecl, W_vardecl);
	Unify::SolutionSet result = unify();

	std::cout << "result = " << oc_to_string(result) << std::endl;

	TS_ASSERT(not result.is_satisfiable());
}

// void UnifyUTest::test_unify_cyclic_dependence_1()
// {
// 	// This one is supposed to fail as X cannot be an Inheritance link
// 	// and a ConceptNode as specified by its type declaration.
// 	Unify::SolutionSet result = Unify()(XY, X, XY_vardecl, X_cyclic_vardecl);

// 	std::cout << "result = " << oc_to_string(result) << std::endl;

// 	TS_ASSERT(not result.is_satisfiable());
// }

// void UnifyUTest::test_unify_type_union_1()
// {
// 	Unify::SolutionSet result = Unify()(XY, AV, XY_vardecl, V_vardecl),
// 		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, V}, Y}}});

// 	std::cout << "result = " << oc_to_string(result) << std::endl;
// 	std::cout << "expected = " << oc_to_string(expected) << std::endl;

// 	TS_ASSERT_EQUALS(result, expected);
// }

void UnifyUTest::test_unify_unordered_1()
{
	Unify unify(AndAA, AndAB);
	Unify::SolutionSet result = unify();

	std::cout << "result = " << oc_to_string(result) << std::endl;

	TS_ASSERT(not result.is_satisfiable());
}

void UnifyUTest::test_unify_unordered_2()
{
	Unify unify(AndAB, AndAY, Handle::UNDEFINED, Y_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{Y, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_3()
{
	Unify unify(AndAY, AndXB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_4()
{
	Unify unify(AndAB, AndXY, Handle::UNDEFINED, XY_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;
}

void UnifyUTest::test_unify_unordered_5()
{
	Unify unify(AndAABB, AndXYAB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_6()
{
	Unify unify(AndAAABBB, AndXXYYAB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_7()
{
	Unify unify(AndAAAABBBB, AndXXXYYYAB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_8()
{
	Unify unify(AndAAAAABBBBB, AndXXXXYYYYAB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_alpha_equivalence()
{
	Handle lhs =
		_eval.eval_h("(ExistsLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"?MEMBER\")"
		             "    (TypeChoice"
		             "      (TypeNode \"ConceptNode\")"
		             "      (TypeNode \"SchemaNode\")"
		             "      (TypeNode \"PredicateNode\")"
		             "    )"
		             "  )"
		             "  (MemberLink"
		             "    (VariableNode \"?MEMBER\")"
		             "    (ConceptNode \"Org1-1\")"
		             "  )"
		             ")");

	Handle rhs =
        _eval.eval_h("(ExistsLink"
                     "  (TypedVariableLink"
                     "    (VariableNode \"?OBJ\")"
                     "    (TypeChoice"
                     "      (TypeNode \"ConceptNode\")"
                     "      (TypeNode \"SchemaNode\")"
                     "      (TypeNode \"PredicateNode\")"
                     "    )"
                     "  )"
                     "  (MemberLink"
                     "    (VariableNode \"?OBJ\")"
                     "    (VariableNode \"?COLL-6c74a409\")"
                     "  )"
                     ")");

	Handle lhs_vardecl;

	Handle rhs_vardecl =
        _eval.eval_h("(TypedVariableLink"
                     "  (VariableNode \"?COLL-6c74a409\")"
                     "  (TypeChoice"
                     "    (TypeNode \"ConceptNode\")"
                     "    (TypeNode \"SchemaNode\")"
                     "    (TypeNode \"PredicateNode\")"
                     "  )"
                     ")");

	Handle MEMBER = an(VARIABLE_NODE, "?MEMBER");
	Handle OBJ = an(VARIABLE_NODE, "?OBJ");
	Handle COLL = an(VARIABLE_NODE, "?COLL-6c74a409");
	Handle Org1 = an(CONCEPT_NODE, "Org1-1");
	Context C1(Quotation(), {MEMBER}, false);
	Context C2(Quotation(), {OBJ}, false);
	Unify::CHandle C1Org1(Org1, C1), C2COLL(COLL, C2);

	Unify unify(lhs, rhs, lhs_vardecl, rhs_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{C1Org1, C2COLL}, Org1}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_substitute()
{
	// Test simple BindLink
	Handle X = an(VARIABLE_NODE, "$X"),
		Y = an(VARIABLE_NODE, "$Y"),
		CT = an(TYPE_NODE, "ConceptNode"),
		Y_vardecl = al(TYPED_VARIABLE_LINK, Y, CT),
		hbl = al(BIND_LINK, al(AND_LINK, X), al(OR_LINK, X)),
		expected = al(BIND_LINK, Y_vardecl,
		              al(AND_LINK, Y), al(OR_LINK, Y));

	BindLinkPtr bl(BindLinkCast(hbl));

	Handle result = _as.add_atom(Unify::substitute(bl, {{X, Y}}, Y_vardecl));

	std::cout << "result = " << oc_to_string(result);
	std::cout << "expected = " << oc_to_string(expected);

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_1()
{
	Handle lhs =
		_eval.eval_h("(ImplicationLink"
		             "  (LambdaLink"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$X\")"
		             "      (TypeNode \"ConceptNode\"))"
		             "    (EvaluationLink"
		             "      (PredicateNode \"take\")"
		             "      (ListLink"
		             "        (VariableNode \"$X\")"
		             "        (ConceptNode \"treatment-1\"))))"
		             "  (AndLink"
		             "    (QuoteLink"
		             "      (LambdaLink"
		             "        (UnquoteLink"
		             "          (VariableNode \"$TyVs\"))"
		             "        (UnquoteLink"
		             "          (VariableNode \"$A1\"))))"
		             "    (QuoteLink"
		             "      (LambdaLink"
		             "        (UnquoteLink"
		             "          (VariableNode \"$TyVs\"))"
		             "        (UnquoteLink"
		             "          (VariableNode \"$A2\"))))))");
	Handle rhs =
		_eval.eval_h("(ImplicationLink"
		             "   (VariableNode \"$P\")"
		             "   (And"
		             "      (VariableNode \"$P\")"
		             "      (VariableNode \"$Q\")))");
	Handle lhs_vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$TyVs\")"
		             "    (TypeChoice"
		             "      (TypeNode \"TypedVariableLink\")"
		             "      (TypeNode \"VariableNode\")"
		             "      (TypeNode \"VariableList\")))"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$A1\")"
		             "    (TypeNode \"EvaluationLink\"))"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$A2\")"
		             "    (TypeNode \"EvaluationLink\")))");
	Handle rhs_vardecl =
		_eval.eval_h("(VariableList"
		             "   (TypedVariableLink"
		             "      (VariableNode \"$P\")"
		             "      (TypeChoice"
		             "         (TypeNode \"PredicateNode\")"
		             "         (TypeNode \"LambdaLink\")))"
		             "   (TypedVariableLink"
		             "      (VariableNode \"$Q\")"
		             "      (TypeChoice"
		             "         (TypeNode \"PredicateNode\")"
		             "         (TypeNode \"LambdaLink\")))))");

	Handle P = _eval.eval_h("(VariableNode \"$P\")");
	Handle Q = _eval.eval_h("(VariableNode \"$Q\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_LA1 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");

	Handle quoted_LA2 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A2\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Variables X_vars = ScopeLinkCast(implicant)->get_variables();
	Context::VariablesStack varstack({X_vars});
	Context C(Quotation(), {X}, true, varstack);
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	Unify unify(lhs, rhs, lhs_vardecl, rhs_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{P, implicant, quoted_LA2},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             implicant_vardecl},
						                {{A2, Cimplicant_body},
								         implicant_body},
						                {{Q, quoted_LA1},
								         quoted_LA1}},
				                       {{{P, implicant, quoted_LA1},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             implicant_vardecl},
						                {{A1, Cimplicant_body},
								         implicant_body},
						                {{Q, quoted_LA2},
								         quoted_LA2}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	Handle A1_vardecl = _eval.eval_h("(TypedVariableLink"
	                                 "  (VariableNode \"$A1\")"
	                                 "  (TypeNode \"EvaluationLink\"))");

	Handle A2_vardecl = _eval.eval_h("(TypedVariableLink"
	                                 "  (VariableNode \"$A2\")"
	                                 "  (TypeNode \"EvaluationLink\"))");

	Handle consumed_LA1 =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (VariableNode \"$A1\"))");

	Handle consumed_LA2 =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (VariableNode \"$A2\"))");

	Unify::TypedSubstitutions ts_result =
		unify.typed_substitutions(result, lhs);
	Unify::TypedSubstitutions ts_expected =
		Unify::TypedSubstitutions{{{{P, implicant},
		                            {TyVs, Cimplicant_vardecl},
		                            {A2, Cimplicant_body},
		                            {Q, consumed_LA1}},
		                           A1_vardecl},
		                          {{{P, implicant},
		                            {TyVs, Cimplicant_vardecl},
		                            {A1, Cimplicant_body},
		                            {Q, consumed_LA2}},
		                           A2_vardecl}};

	std::cout << "ts_result = " << oc_to_string(ts_result) << std::endl;
	std::cout << "ts_expected = " << oc_to_string(ts_expected) << std::endl;

	TS_ASSERT(tss_content_eq(ts_result, ts_expected));
}

void UnifyUTest::test_unify_complex_2()
{
	Handle lhs =
		_eval.eval_h("(ImplicationScopeLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (VariableNode \"$P-55ebe96e\")"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"compound-A\"))))");

	Handle rhs =
		_eval.eval_h("(ImplicationScopeLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (AndLink"
		             "    (EvaluationLink"
		             "      (PredicateNode \"contain\")"
		             "      (ListLink"
		             "        (VariableNode \"$Y-6f50cc6a\")"
		             "        (ConceptNode \"compound-A\")))"
		             "    (EvaluationLink"
		             "      (PredicateNode \"take\")"
		             "      (ListLink"
		             "        (VariableNode \"$X\")"
		             "        (VariableNode \"$Y-6f50cc6a\"))))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"compound-A\"))))");

	Handle lhs_vardecl =
		_eval.eval_h("(VariableNode \"$P-55ebe96e\")");

	Handle rhs_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$Y-6f50cc6a\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle P = _eval.eval_h("(VariableNode \"$P-55ebe96e\")");

	Handle conjunction =
		_eval.eval_h("(AndLink"
		             "  (EvaluationLink"
		             "    (PredicateNode \"contain\")"
		             "    (ListLink"
		             "      (VariableNode \"$Y-6f50cc6a\")"
		             "      (ConceptNode \"compound-A\")))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (VariableNode \"$Y-6f50cc6a\"))))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle CP(P, C);
	Unify::CHandle Cconjunction(conjunction, C);

	Unify unify(lhs, rhs, lhs_vardecl, rhs_vardecl);
	Unify::SolutionSet result = unify();
	Unify::Block pb_expected{CP, Cconjunction};
	Unify::Partition partition_expected{{pb_expected, conjunction}};
	Unify::SolutionSet expected = Unify::SolutionSet({partition_expected});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	Handle ts_vardecl = _eval.eval_h("(TypedVariableLink"
	                                 "  (VariableNode \"$Y-6f50cc6a\")"
	                                 "  (TypeNode \"ConceptNode\"))");

	Unify::TypedSubstitutions tss_result =
		unify.typed_substitutions(result, lhs);
	Unify::HandleCHandleMap hchm_expected =
		Unify::HandleCHandleMap{{P, Cconjunction}};
	Unify::TypedSubstitution ts_expected =
		Unify::TypedSubstitution{hchm_expected, ts_vardecl};
	Unify::TypedSubstitutions tss_expected =
		Unify::TypedSubstitutions{ts_expected};

	std::cout << "tss_result = " << oc_to_string(tss_result) << std::endl;
	std::cout << "tss_expected = " << oc_to_string(tss_expected) << std::endl;

	TS_ASSERT(tss_content_eq(tss_result, tss_expected));
}

void UnifyUTest::test_unify_complex_3()
{
	Handle lhs =
		_eval.eval_h("(ImplicationLink"
		             "  (QuoteLink"
		             "    (LambdaLink"
		             "      (UnquoteLink"
		             "        (VariableNode \"$TyVs-3753c5dc\"))"
		             "      (UnquoteLink"
		             "        (VariableNode \"$Q-79152fc8\"))))"
		             "  (LambdaLink"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$X\")"
		             "      (TypeNode \"ConceptNode\"))"
		             "    (EvaluationLink"
		             "      (PredicateNode \"take\")"
		             "      (ListLink"
		             "        (VariableNode \"$X\")"
		             "        (ConceptNode \"compound-A\")))))");

	Handle rhs =
		_eval.eval_h("(ImplicationLink"
		             "  (QuoteLink"
		             "    (LambdaLink"
		             "      (UnquoteLink"
		             "        (VariableNode \"$TyVs-7b18f3dc\"))"
		             "      (UnquoteLink"
		             "        (VariableNode \"$P-60bdbde3\"))))"
		             "  (QuoteLink"
		             "    (LambdaLink"
		             "      (UnquoteLink"
		             "        (VariableNode \"$TyVs-7b18f3dc\"))"
		             "      (UnquoteLink"
		             "        (VariableNode \"$Q-344be2a0\")))))");

	Handle lhs_vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$TyVs-3753c5dc\")"
		             "    (TypeChoice"
		             "      (TypeNode \"TypedVariableLink\")"
		             "      (TypeNode \"VariableList\")))"
		             "  (VariableNode \"$Q-79152fc8\"))");

	Handle rhs_vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$TyVs-7b18f3dc\")"
		             "    (TypeChoice"
		             "      (TypeNode \"TypedVariableLink\")"
		             "      (TypeNode \"VariableList\")))"
		             "  (VariableNode \"$P-60bdbde3\")"
		             "  (VariableNode \"$Q-344be2a0\"))");

	Handle TyVs1 = _eval.eval_h("(VariableNode \"$TyVs-3753c5dc\")");
	Handle TyVs2 = _eval.eval_h("(VariableNode \"$TyVs-7b18f3dc\")");
	Handle Q1 = _eval.eval_h("(VariableNode \"$Q-79152fc8\")");
	Handle Q2 = _eval.eval_h("(VariableNode \"$Q-344be2a0\")");
	Handle P =_eval.eval_h("(VariableNode \"$P-60bdbde3\")");

	Handle vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"compound-A\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle Cvardecl(vardecl, C), Cimplicant_body(implicant_body, C);

	Unify unify(lhs, rhs, lhs_vardecl, rhs_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{TyVs1, TyVs2, Cvardecl}, vardecl},
				                        {{Q1, P}, Q1},
				                        {{Q2, Cimplicant_body}, implicant_body}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_4()
{
	// Very similar to test_unify_complex_1() but for some reason doesn't work.
	Handle target = _eval.eval_h(
		"(ImplicationLink"
		"  (LambdaLink"
		"    (TypedVariableLink"
		"      (VariableNode \"$X\")"
		"      (TypeNode \"ConceptNode\")"
		"    )"
		"    (EvaluationLink"
		"      (PredicateNode \"take\")"
		"      (ListLink"
		"        (VariableNode \"$X\")"
		"        (ConceptNode \"treatment-1\")"
		"      )"
		"    )"
		"  )"
		"  (AndLink"
		"    (QuoteLink"
		"      (LambdaLink"
		"        (UnquoteLink"
		"          (VariableNode \"$TyVs-5476a9b9\")"
		"        )"
		"        (UnquoteLink"
		"          (VariableNode \"$A1-7235efc6\")"
		"        )"
		"      )"
		"    )"
		"    (QuoteLink"
		"      (LambdaLink"
		"        (UnquoteLink"
		"          (VariableNode \"$TyVs-5476a9b9\")"
		"        )"
		"        (UnquoteLink"
		"          (VariableNode \"$A2-1ac8e4a2\")"
		"        )"
		"      )"
		"    )"
		"  )"
		")"
		);
	Handle alpha_pat = _eval.eval_h(
		"(ImplicationLink"
		"  (VariableNode \"$P-10ea3e30\")"
		"  (AndLink"
		"    (VariableNode \"$P-10ea3e30\")"
		"    (VariableNode \"$Q-78f01c2d\")"
		"  )"
		")"
		);
	Handle vardecl = _eval.eval_h(
		"(VariableList"
		"  (TypedVariableLink"
		"    (VariableNode \"$TyVs-5476a9b9\")"
		"    (TypeChoice"
		"      (TypeNode \"TypedVariableLink\")"
		"      (TypeNode \"VariableNode\")"
		"      (TypeNode \"VariableList\")"
		"    )"
		"  )"
		"  (TypedVariableLink"
		"    (VariableNode \"$A1-7235efc6\")"
		"    (TypeNode \"EvaluationLink\")"
		"  )"
		"  (TypedVariableLink"
		"    (VariableNode \"$A2-1ac8e4a2\")"
		"    (TypeNode \"EvaluationLink\")"
		"  )"
		")"
		);
	Handle alpha_vardecl = _eval.eval_h(
		"(VariableList"
		"  (TypedVariableLink"
		"    (VariableNode \"$P-10ea3e30\")"
		"    (TypeChoice"
		"      (TypeNode \"LambdaLink\")"
		"      (TypeNode \"PredicateNode\")"
		"    )"
		"  )"
		"  (TypedVariableLink"
		"    (VariableNode \"$Q-78f01c2d\")"
		"    (TypeChoice"
		"      (TypeNode \"LambdaLink\")"
		"      (TypeNode \"PredicateNode\")"
		"    )"
		"  )"
		")"
		);

	Handle P = _eval.eval_h("(VariableNode \"$P-10ea3e30\")");
	Handle Q = _eval.eval_h("(VariableNode \"$Q-78f01c2d\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs-5476a9b9\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1-7235efc6\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2-1ac8e4a2\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_LA1 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs-5476a9b9\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1-7235efc6\"))))");

	Handle quoted_LA2 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs-5476a9b9\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A2-1ac8e4a2\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{P, implicant, quoted_LA2},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             implicant_vardecl},
						                {{A2, Cimplicant_body},
								         implicant_body},
						                {{Q, quoted_LA1},
								         quoted_LA1}},
				                       {{{P, implicant, quoted_LA1},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             implicant_vardecl},
						                {{A1, Cimplicant_body},
								         implicant_body},
						                {{Q, quoted_LA2},
								         quoted_LA2}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_5()
{
	Handle target =
        _eval.eval_h("(LambdaLink"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$X\")"
                     "    (TypeNode \"ConceptNode\")"
                     "  )"
                     "  (VariableNode \"$Q-496643b4\")"
                     ")");

	Handle alpha_pat =
        _eval.eval_h("(QuoteLink"
                     "  (LambdaLink"
                     "    (UnquoteLink"
                     "      (VariableNode \"$TyVs-3e93b595\")"
                     "    )"
                     "    (UnquoteLink"
                     "      (VariableNode \"$A2-76df4103\")"
                     "    )"
                     "  )"
                     ")");

	Handle vardecl =
        _eval.eval_h("(VariableNode \"$Q-496643b4\")");

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$TyVs-3e93b595\")"
                     "    (TypeChoice"
                     "      (TypeNode \"TypedVariableLink\")"
                     "      (TypeNode \"VariableNode\")"
                     "      (TypeNode \"VariableList\")"
                     "    )"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$A2-76df4103\")"
                     "    (TypeNode \"EvaluationLink\")"
                     "  )"
                     ")");

	Handle Q = _eval.eval_h("(VariableNode \"$Q-496643b4\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs-3e93b595\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2-76df4103\")");

	Handle lambda_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle take_treatment_1 =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle CQ(Q, C),
        Clambda_vardecl(lambda_vardecl, C),
		Ctake_treatment_1(take_treatment_1, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{CQ, A2}, A2},
						                {{TyVs, Clambda_vardecl},
                                         lambda_vardecl}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_6()
{
	Handle target =
        _eval.eval_h("(ImplicationLink"
                     "  (AndLink"
                     "    (LambdaLink"
                     "      (TypedVariableLink"
                     "        (VariableNode \"$X\")"
                     "        (TypeNode \"ConceptNode\")"
                     "      )"
                     "      (EvaluationLink"
                     "        (PredicateNode \"take\")"
                     "        (ListLink"
                     "          (VariableNode \"$X\")"
                     "          (ConceptNode \"treatment-1\")"
                     "        )"
                     "      )"
                     "    )"
                     "    (LambdaLink"
                     "      (TypedVariableLink"
                     "        (VariableNode \"$X\")"
                     "        (TypeNode \"ConceptNode\")"
                     "      )"
                     "      (VariableNode \"$Q-496643b4\")"
                     "    )"
                     "  )"
                     "  (LambdaLink"
                     "    (TypedVariableLink"
                     "      (VariableNode \"$X\")"
                     "      (TypeNode \"ConceptNode\")"
                     "    )"
                     "    (AndLink"
                     "      (VariableNode \"$Q-496643b4\")"
                     "      (EvaluationLink"
                     "        (PredicateNode \"take\")"
                     "        (ListLink"
                     "          (VariableNode \"$X\")"
                     "          (ConceptNode \"treatment-1\")"
                     "        )"
                     "      )"
                     "    )"
                     "  )"
                     ")");

	Handle alpha_pat =
        _eval.eval_h("(ImplicationLink"
                     "  (AndLink"
                     "    (QuoteLink"
                     "      (LambdaLink"
                     "        (UnquoteLink"
                     "          (VariableNode \"$TyVs-3e93b595\")"
                     "        )"
                     "        (UnquoteLink"
                     "          (VariableNode \"$A1-4fd556f2\")"
                     "        )"
                     "      )"
                     "    )"
                     "    (QuoteLink"
                     "      (LambdaLink"
                     "        (UnquoteLink"
                     "          (VariableNode \"$TyVs-3e93b595\")"
                     "        )"
                     "        (UnquoteLink"
                     "          (VariableNode \"$A2-76df4103\")"
                     "        )"
                     "      )"
                     "    )"
                     "  )"
                     "  (QuoteLink"
                     "    (LambdaLink"
                     "      (UnquoteLink"
                     "        (VariableNode \"$TyVs-3e93b595\")"
                     "      )"
                     "      (UnquoteLink"
                     "        (AndLink"
                     "          (VariableNode \"$A1-4fd556f2\")"
                     "          (VariableNode \"$A2-76df4103\")"
                     "        )"
                     "      )"
                     "    )"
                     "  )"
                     ")");

	Handle vardecl =
        _eval.eval_h("(VariableNode \"$Q-496643b4\")");

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$TyVs-3e93b595\")"
                     "    (TypeChoice"
                     "      (TypeNode \"TypedVariableLink\")"
                     "      (TypeNode \"VariableNode\")"
                     "      (TypeNode \"VariableList\")"
                     "    )"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$A1-4fd556f2\")"
                     "    (TypeNode \"EvaluationLink\")"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$A2-76df4103\")"
                     "    (TypeNode \"EvaluationLink\")"
                     "  )"
                     ")");

	Handle Q = _eval.eval_h("(VariableNode \"$Q-496643b4\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs-3e93b595\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1-4fd556f2\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2-76df4103\")");

	Handle lambda_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle take_treatment_1 =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle CQ(Q, C),
        Clambda_vardecl(lambda_vardecl, C),
		Ctake_treatment_1(take_treatment_1, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{CQ, A1}, A1},
						                {{TyVs, Clambda_vardecl},
						 	             lambda_vardecl},
						                {{A2, Ctake_treatment_1},
                                         take_treatment_1}},
				                       {{{CQ, A1, A2, Ctake_treatment_1},
							             take_treatment_1},
						                {{TyVs, Clambda_vardecl},
								         lambda_vardecl}},
                                       {{{CQ, A2}, A2},
						                {{TyVs, Clambda_vardecl},
						 	             lambda_vardecl},
						                {{A1, Ctake_treatment_1},
                                         take_treatment_1}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_7()
{
	Handle target =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\")"
		             "  )"
		             "  (EvaluationLink"
		             "    (PredicateNode \"contain\")"
		             "    (ListLink"
		             "      (ConceptNode \"treatment-1\")"
		             "      (ConceptNode \"compound-A\")"
		             "    )"
		             "  )"
		             ")");

	Handle alpha_pat =
        _eval.eval_h("(QuoteLink"
                     "  (LambdaLink"
                     "    (UnquoteLink"
                     "      (VariableNode \"$V-6c74a409\")"
                     "    )"
                     "    (UnquoteLink"
                     "      (VariableNode \"$B-6266d6f2\")"
                     "    )"
                     "  )"
                     ")");

	Handle vardecl;

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$V-6c74a409\")"
                     "    (TypeChoice"
                     "      (TypeNode \"TypedVariableLink\")"
                     "      (TypeNode \"VariableNode\")"
                     "      (TypeNode \"VariableList\")"
                     "    )"
                     "  )"
                     "  (VariableNode \"$B-6266d6f2\")"
                     ")");

	Handle V = _eval.eval_h("(VariableNode \"$V-6c74a409\")");
	Handle B = _eval.eval_h("(VariableNode \"$B-6266d6f2\")");
	Handle X_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\")"
		             ")");
	Handle body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"contain\")"
		             "  (ListLink"
		             "    (ConceptNode \"treatment-1\")"
		             "    (ConceptNode \"compound-A\")"
		             "  )"
		             ")");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle CX_vardecl(X_vardecl, C), Cbody(body, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{V, CX_vardecl}, X_vardecl},
					                    {{B, Cbody}, body}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	Handle ts_vardecl = al(VARIABLE_LIST);

	Unify::TypedSubstitutions ts_result =
		unify.typed_substitutions(result, target);
	Unify::TypedSubstitutions ts_expected =
		Unify::TypedSubstitutions{{{{V, CX_vardecl},
		                            {B, Cbody}},
		                           ts_vardecl}};

	std::cout << "ts_result = " << oc_to_string(ts_result) << std::endl;
	std::cout << "ts_expected = " << oc_to_string(ts_expected) << std::endl;

	TS_ASSERT(tss_content_eq(ts_result, ts_expected));
}

#undef al
#undef an
