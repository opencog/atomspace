/**
 * tests/unify/UnifyUTest.cxxtest
 *
 * Copyright (C) 2016 OpenCog Foundation
 * All Rights Reserved
 * Author: Nil Geisweiller
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/util/Logger.h>

#include <opencog/atoms/core/Context.h>
#include <opencog/unify/Unify.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>

#include <cxxtest/TestSuite.h>

using namespace opencog;

#define al _as.add_link
#define an _as.add_node

class UnifyUTest :  public CxxTest::TestSuite
{
private:
	AtomSpace _as;
	SchemeEval _eval;
	Handle X, Y, Z, W, V, A, B, AB, XB, AY, XY, AZ, AW, AV,
		AndAA, AndAB, AndAY, AndXB, AndXY,
		AndAABB, AndXYAB, AndAAABBB, AndXXYYAB, AndAAAABBBB, AndXXXYYYAB,
		AndAAAAABBBBB, AndXXXXYYYYAB,
		CT, PT, IT, CPT,
		X_vardecl, X_cyclic_vardecl, Y_vardecl, Z_vardecl, W_vardecl, V_vardecl,
		XY_vardecl;
	Context::VariablesStack X_varstack;

public:
	UnifyUTest() : _eval(&_as)
	{
		logger().set_level(Logger::DEBUG);
		logger().set_print_to_stdout_flag(true);
		logger().set_timestamp_flag(false);

		X = an(VARIABLE_NODE, "$X");
		Y = an(VARIABLE_NODE, "$Y");
		Z = an(VARIABLE_NODE, "$Z");
		W = an(VARIABLE_NODE, "$W");
		V = an(VARIABLE_NODE, "$V");
		A = an(CONCEPT_NODE, "A");
		B = an(CONCEPT_NODE, "B");
		AB = al(INHERITANCE_LINK, A, B);
		XB = al(INHERITANCE_LINK, X, B);
		AY = al(INHERITANCE_LINK, A, Y);
		XY = al(INHERITANCE_LINK, X, Y);
		AZ = al(INHERITANCE_LINK, A, Z);
		AW = al(INHERITANCE_LINK, A, W);
		AV = al(INHERITANCE_LINK, A, V);
		AndAA = al(AND_LINK, A, A);
		AndAB = al(AND_LINK, A, B);
		AndAY = al(AND_LINK, A, Y);
		AndXB = al(AND_LINK, X, B);
		AndXY = al(AND_LINK, X, Y);
		AndAABB = al(AND_LINK, {A, A, B, B});
		AndXYAB = al(AND_LINK, {X, Y, A, B});
		AndAAABBB = al(AND_LINK, {A, A, A, B, B, B});
		AndXXYYAB = al(AND_LINK, {X, X, Y, Y, A, B});
		AndAAAABBBB = al(AND_LINK, {A, A, A, A, B, B, B, B});
		AndXXXYYYAB = al(AND_LINK, {X, X, X, Y, Y, Y, A, B});
		AndAAAAABBBBB = al(AND_LINK, {A, A, A, A, A, B, B, B, B, B});
		AndXXXXYYYYAB = al(AND_LINK, {X, X, X, X, Y, Y, Y, Y, A, B});
		CT = an(TYPE_NODE, "ConceptNode");
		PT = an(TYPE_NODE, "PredicateNode");
		IT = an(TYPE_NODE, "InheritanceLink");
		CPT = al(TYPE_CHOICE, CT, PT);
		X_vardecl = al(TYPED_VARIABLE_LINK, X, CT);
		X_cyclic_vardecl = al(TYPED_VARIABLE_LINK, X, IT);
		Y_vardecl = al(TYPED_VARIABLE_LINK, Y, CT);
		Z_vardecl = al(TYPED_VARIABLE_LINK, Z, CT);
		W_vardecl = al(TYPED_VARIABLE_LINK, W, PT);
		V_vardecl = al(TYPED_VARIABLE_LINK, V, CPT);
		XY_vardecl = al(VARIABLE_LIST,
		                al(TYPED_VARIABLE_LINK, X, CT),
		                al(TYPED_VARIABLE_LINK, Y, CT));

		Handle X_varlist = al(VARIABLE_LIST, X_vardecl);
		Variables X_CT_variables = VariableListCast(X_varlist)->get_variables();
		X_varstack.push_back(X_CT_variables);
	}

	void setUp();

	// type (TODO: should be moved elsewhere once the unification type
	// routines are moved elsewhere)
	void test_type_intersection();

	void test_join_1();
	void test_join_2();
	void test_join_3();

	void test_unify_without_var_1();
	void test_unify_without_var_2();

	void test_unify_basic_1();
	void test_unify_basic_2();
	void test_unify_basic_3();
	void test_unify_basic_4();
	void test_unify_basic_5();
	void test_unify_basic_6();
	void test_unify_basic_7();
	void test_unify_basic_8();

	// Variable declaration
	void test_unify_vardecl_1();
	void test_unify_vardecl_2();
	void test_unify_vardecl_3();
	void test_unify_vardecl_4();
	void test_unify_vardecl_5();

	// // Cyclic dependence
	// TODO: is it really needed?
	// void test_unify_cyclic_dependence_1();

	// // Type union
	// TODO: for that we need to support more powerful type
	// void test_unify_type_union_1();

	// Unordered link
	void test_unify_unordered_1();
	void test_unify_unordered_2();
	void test_unify_unordered_3();
	void test_unify_unordered_4();
	void test_unify_unordered_5();
	void test_unify_unordered_6();
	void test_unify_unordered_7();
	void test_unify_unordered_8();

	void test_unify_alpha_equivalence();

	void test_substitute();
	
	// Various complex unify queries
	void test_unify_complex_1();
	void test_unify_complex_2();
	void test_unify_complex_3();
	void test_unify_complex_4();
	void test_unify_complex_5();
	void test_unify_complex_6();
	void test_unify_complex_7();
	void test_unify_complex_8();
	void test_unify_complex_9();
	void test_unify_complex_10();
	void test_unify_complex_11();
	void test_unify_complex_12();
};

void UnifyUTest::setUp(void)
{
}

void UnifyUTest::test_type_intersection()
{
	Handle lhs =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");
	Handle rhs =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Unify unify(lhs, rhs);
	Unify::CHandle result = unify.type_intersection(lhs, rhs),
		expected = rhs;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_join_1()
{
	Unify unify(A, B);          // dummy unify construction to test join
	Unify::Block pb1{X, A};
	Unify::SolutionSet s1 = Unify::SolutionSet({{{pb1, A}}});
	Unify::Block pb2{X, B};
	Unify::SolutionSet s2 = Unify::SolutionSet({{{pb2, B}}}),
		result = unify.join(s1, s2),
		expected = Unify::SolutionSet(false);

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_join_2()
{
	Handle P = _eval.eval_h("(VariableNode \"$P\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_implicant =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	std::cout << "C = " << oc_to_string(C);
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	Unify unify(P, quoted_implicant); // dummy unify construction to test join
	Unify::Block pb1{P, implicant};
	Unify::SolutionSet s1 = Unify::SolutionSet({{{pb1, implicant}}});
	Unify::Block pb2{P, quoted_implicant};
	Unify::SolutionSet s2 = Unify::SolutionSet({{{pb2, quoted_implicant}}});
	Unify::SolutionSet result = unify.join(s1, s2);
	Unify::Block pb1_expected{P, implicant, quoted_implicant};
	Unify::Block pb2_expected{TyVs, Cimplicant_vardecl};
	Unify::Block pb3_expected{A1, Cimplicant_body};
	Unify::SolutionSet expected =
		Unify::SolutionSet({{{pb1_expected, implicant},
					         {pb2_expected, Cimplicant_vardecl},
					         {pb3_expected, Cimplicant_body}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

// Same as test_join_2 but using A2 as well. See test_complex_1
void UnifyUTest::test_join_3()
{
	Handle P = _eval.eval_h("(VariableNode \"$P\")");
	Handle Q = _eval.eval_h("(VariableNode \"$Q\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_LA1 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");

	Handle quoted_LA2 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A2\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	// dummy unify construction to test join
	Unify unify(al(AND_LINK, P, Q), al(AND_LINK, quoted_LA1, quoted_LA2));

	Unify::SolutionSet
		s1 = Unify::SolutionSet({{{{P, implicant}, implicant}}}),
		s2 = Unify::SolutionSet(
		           {{{{P, quoted_LA1}, quoted_LA1},
					 {{Q, quoted_LA2}, quoted_LA2}},
		            {{{Q, quoted_LA1}, quoted_LA1},
					 {{P, quoted_LA2}, quoted_LA2}}}),
		result = unify.join(s1, s2),
		expected = Unify::SolutionSet({{{{P, implicant, quoted_LA2},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             Cimplicant_vardecl},
						                {{A2, Cimplicant_body},
								         Cimplicant_body},
						                {{Q, quoted_LA1},
								         quoted_LA1}},
				                       {{{P, implicant, quoted_LA1},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             Cimplicant_vardecl},
						                {{A1, Cimplicant_body},
								         Cimplicant_body},
						                {{Q, quoted_LA2},
								         quoted_LA2}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_without_var_1()
{
	Unify unify(AB, A);
	Unify::SolutionSet result = unify(),
        expected(false);

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	// On top of that make sure that the solution is empty as it is
	// how failing is represented
	TS_ASSERT(result.empty());
}

void UnifyUTest::test_unify_without_var_2()
{
	Unify unify(AB, AB);
	Unify::SolutionSet result = unify(),
		expected(true);

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	// On top of that make sure that the solution is not empty as it
	// is how success is represented
	TS_ASSERT(not result.empty());
}

void UnifyUTest::test_unify_basic_1()
{
	Unify unify(X, A);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_2()
{
	Unify unify(A, X);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_3()
{
	Unify unify(X, AB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, AB}, AB}}});
	
	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_4()
{
	Unify unify(XB, AY);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}}});
	
	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_5()
{
	Unify unify(XY, AY);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_6()
{
	// This one is supposed to fail
	Unify unify(A, B);
	Unify::SolutionSet result = unify();

	std::cout << "result = " << oc_to_string(result) << std::endl;

	TS_ASSERT(not result.is_satisfiable());
}

void UnifyUTest::test_unify_basic_7()
{
	// This one is supposed to fail
	Unify unify(XB, B);
	Unify::SolutionSet result = unify();

	TS_ASSERT(not result.is_satisfiable());
}

void UnifyUTest::test_unify_basic_8()
{
	Unify unify(XY, AZ);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, Z}, Y}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_1()
{
	Unify unify(XY, AY, XY_vardecl, Y_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_2()
{
	Unify unify(XY, AY, XY_vardecl, Y_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_3()
{
	Unify unify(XB, AY, X_vardecl, Y_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}}});

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_4()
{
	Unify unify(XY, AZ, XY_vardecl, Z_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, Z}, Y}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_5()
{
	// This one is supposed to fail as the types of Y and W have empty
	// intersection.
	Unify unify(XY, AW, XY_vardecl, W_vardecl);
	Unify::SolutionSet result = unify();

	std::cout << "result = " << oc_to_string(result) << std::endl;

	TS_ASSERT(not result.is_satisfiable());
}

// void UnifyUTest::test_unify_cyclic_dependence_1()
// {
// 	// This one is supposed to fail as X cannot be an Inheritance link
// 	// and a ConceptNode as specified by its type declaration.
// 	Unify::SolutionSet result = Unify()(XY, X, XY_vardecl, X_cyclic_vardecl);

// 	std::cout << "result = " << oc_to_string(result) << std::endl;

// 	TS_ASSERT(not result.is_satisfiable());
// }

// void UnifyUTest::test_unify_type_union_1()
// {
// 	Unify::SolutionSet result = Unify()(XY, AV, XY_vardecl, V_vardecl),
// 		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, V}, Y}}});

// 	std::cout << "result = " << oc_to_string(result) << std::endl;
// 	std::cout << "expected = " << oc_to_string(expected) << std::endl;

// 	TS_ASSERT_EQUALS(result, expected);
// }

void UnifyUTest::test_unify_unordered_1()
{
	Unify unify(AndAA, AndAB);
	Unify::SolutionSet result = unify();

	std::cout << "result = " << oc_to_string(result) << std::endl;

	TS_ASSERT(not result.is_satisfiable());
}

void UnifyUTest::test_unify_unordered_2()
{
	Unify unify(AndAB, AndAY, Handle::UNDEFINED, Y_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{Y, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_3()
{
	Unify unify(AndAY, AndXB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_4()
{
	Unify unify(AndAB, AndXY, Handle::UNDEFINED, XY_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;
}

void UnifyUTest::test_unify_unordered_5()
{
	Unify unify(AndAABB, AndXYAB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_6()
{
	Unify unify(AndAAABBB, AndXXYYAB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_7()
{
	Unify unify(AndAAAABBBB, AndXXXYYYAB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_8()
{
	Unify unify(AndAAAAABBBBB, AndXXXXYYYYAB);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_alpha_equivalence()
{
	Handle lhs =
		_eval.eval_h("(ExistsLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"?MEMBER\")"
		             "    (TypeChoice"
		             "      (TypeNode \"ConceptNode\")"
		             "      (TypeNode \"SchemaNode\")"
		             "      (TypeNode \"PredicateNode\")"
		             "    )"
		             "  )"
		             "  (MemberLink"
		             "    (VariableNode \"?MEMBER\")"
		             "    (ConceptNode \"Org1-1\")"
		             "  )"
		             ")");

	Handle rhs =
        _eval.eval_h("(ExistsLink"
                     "  (TypedVariableLink"
                     "    (VariableNode \"?OBJ\")"
                     "    (TypeChoice"
                     "      (TypeNode \"ConceptNode\")"
                     "      (TypeNode \"SchemaNode\")"
                     "      (TypeNode \"PredicateNode\")"
                     "    )"
                     "  )"
                     "  (MemberLink"
                     "    (VariableNode \"?OBJ\")"
                     "    (VariableNode \"?COLL-6c74a409\")"
                     "  )"
                     ")");

	Handle lhs_vardecl;

	Handle rhs_vardecl =
        _eval.eval_h("(TypedVariableLink"
                     "  (VariableNode \"?COLL-6c74a409\")"
                     "  (TypeChoice"
                     "    (TypeNode \"ConceptNode\")"
                     "    (TypeNode \"SchemaNode\")"
                     "    (TypeNode \"PredicateNode\")"
                     "  )"
                     ")");

	Handle MEMBER = an(VARIABLE_NODE, "?MEMBER");
	Handle OBJ = an(VARIABLE_NODE, "?OBJ");
	Handle COLL = an(VARIABLE_NODE, "?COLL-6c74a409");
	Handle Org1 = an(CONCEPT_NODE, "Org1-1");
	Context C1(Quotation(), {MEMBER}, false);
	Context C2(Quotation(), {OBJ}, false);
	Unify::CHandle C1Org1(Org1, C1), C2COLL(COLL, C2);

	Unify unify(lhs, rhs, lhs_vardecl, rhs_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{C1Org1, C2COLL}, C1Org1}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_substitute()
{
	// Test simple BindLink
	Handle X = an(VARIABLE_NODE, "$X"),
		Y = an(VARIABLE_NODE, "$Y"),
		CT = an(TYPE_NODE, "ConceptNode"),
		Y_vardecl = al(TYPED_VARIABLE_LINK, Y, CT),
		hbl = al(BIND_LINK, al(AND_LINK, X), al(OR_LINK, X)),
		expected = al(BIND_LINK, Y_vardecl,
		              al(AND_LINK, Y), al(OR_LINK, Y));

	BindLinkPtr bl(BindLinkCast(hbl));

	Handle result = _as.add_atom(Unify::substitute(bl, {{X, Y}}, Y_vardecl));

	std::cout << "result = " << oc_to_string(result);
	std::cout << "expected = " << oc_to_string(expected);

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_1()
{
	Handle lhs =
		_eval.eval_h("(ImplicationLink"
		             "  (LambdaLink"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$X\")"
		             "      (TypeNode \"ConceptNode\"))"
		             "    (EvaluationLink"
		             "      (PredicateNode \"take\")"
		             "      (ListLink"
		             "        (VariableNode \"$X\")"
		             "        (ConceptNode \"treatment-1\"))))"
		             "  (AndLink"
		             "    (QuoteLink"
		             "      (LambdaLink"
		             "        (UnquoteLink"
		             "          (VariableNode \"$TyVs\"))"
		             "        (UnquoteLink"
		             "          (VariableNode \"$A1\"))))"
		             "    (QuoteLink"
		             "      (LambdaLink"
		             "        (UnquoteLink"
		             "          (VariableNode \"$TyVs\"))"
		             "        (UnquoteLink"
		             "          (VariableNode \"$A2\"))))))");
	Handle rhs =
		_eval.eval_h("(ImplicationLink"
		             "   (VariableNode \"$P\")"
		             "   (And"
		             "      (VariableNode \"$P\")"
		             "      (VariableNode \"$Q\")))");
	Handle lhs_vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$TyVs\")"
		             "    (TypeChoice"
		             "      (TypeNode \"TypedVariableLink\")"
		             "      (TypeNode \"VariableNode\")"
		             "      (TypeNode \"VariableList\")))"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$A1\")"
		             "    (TypeNode \"EvaluationLink\"))"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$A2\")"
		             "    (TypeNode \"EvaluationLink\")))");
	Handle rhs_vardecl =
		_eval.eval_h("(VariableList"
		             "   (TypedVariableLink"
		             "      (VariableNode \"$P\")"
		             "      (TypeChoice"
		             "         (TypeNode \"PredicateNode\")"
		             "         (TypeNode \"LambdaLink\")))"
		             "   (TypedVariableLink"
		             "      (VariableNode \"$Q\")"
		             "      (TypeChoice"
		             "         (TypeNode \"PredicateNode\")"
		             "         (TypeNode \"LambdaLink\")))))");

	Handle P = _eval.eval_h("(VariableNode \"$P\")");
	Handle Q = _eval.eval_h("(VariableNode \"$Q\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_LA1 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");

	Handle quoted_LA2 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A2\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Variables X_vars = ScopeLinkCast(implicant)->get_variables();
	Context::VariablesStack varstack({X_vars});
	Context C(Quotation(), {X}, true, varstack);
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	Unify unify(lhs, rhs, lhs_vardecl, rhs_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{P, implicant, quoted_LA2},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             Cimplicant_vardecl},
						                {{A2, Cimplicant_body},
								         Cimplicant_body},
						                {{Q, quoted_LA1},
								         quoted_LA1}},
				                       {{{P, implicant, quoted_LA1},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             Cimplicant_vardecl},
						                {{A1, Cimplicant_body},
								         Cimplicant_body},
						                {{Q, quoted_LA2},
								         quoted_LA2}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	Handle A1_vardecl = _eval.eval_h("(TypedVariableLink"
	                                 "  (VariableNode \"$A1\")"
	                                 "  (TypeNode \"EvaluationLink\"))");

	Handle A2_vardecl = _eval.eval_h("(TypedVariableLink"
	                                 "  (VariableNode \"$A2\")"
	                                 "  (TypeNode \"EvaluationLink\"))");

	Handle consumed_LA1 =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (VariableNode \"$A1\"))");

	Handle consumed_LA2 =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (VariableNode \"$A2\"))");

	Unify::TypedSubstitutions ts_result =
		unify.typed_substitutions(result, lhs);
	Unify::TypedSubstitutions ts_expected =
		Unify::TypedSubstitutions{{{{P, implicant},
		                            {TyVs, Cimplicant_vardecl},
		                            {A2, Cimplicant_body},
		                            {Q, consumed_LA1}},
		                           A1_vardecl},
		                          {{{P, implicant},
		                            {TyVs, Cimplicant_vardecl},
		                            {A1, Cimplicant_body},
		                            {Q, consumed_LA2}},
		                           A2_vardecl}};

	std::cout << "ts_result = " << oc_to_string(ts_result) << std::endl;
	std::cout << "ts_expected = " << oc_to_string(ts_expected) << std::endl;

	TS_ASSERT(tss_content_eq(ts_result, ts_expected));
}

void UnifyUTest::test_unify_complex_2()
{
	Handle lhs =
		_eval.eval_h("(ImplicationScopeLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (VariableNode \"$P-55ebe96e\")"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"compound-A\"))))");

	Handle rhs =
		_eval.eval_h("(ImplicationScopeLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (AndLink"
		             "    (EvaluationLink"
		             "      (PredicateNode \"contain\")"
		             "      (ListLink"
		             "        (VariableNode \"$Y-6f50cc6a\")"
		             "        (ConceptNode \"compound-A\")))"
		             "    (EvaluationLink"
		             "      (PredicateNode \"take\")"
		             "      (ListLink"
		             "        (VariableNode \"$X\")"
		             "        (VariableNode \"$Y-6f50cc6a\"))))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"compound-A\"))))");

	Handle lhs_vardecl =
		_eval.eval_h("(VariableNode \"$P-55ebe96e\")");

	Handle rhs_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$Y-6f50cc6a\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle P = _eval.eval_h("(VariableNode \"$P-55ebe96e\")");

	Handle conjunction =
		_eval.eval_h("(AndLink"
		             "  (EvaluationLink"
		             "    (PredicateNode \"contain\")"
		             "    (ListLink"
		             "      (VariableNode \"$Y-6f50cc6a\")"
		             "      (ConceptNode \"compound-A\")))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (VariableNode \"$Y-6f50cc6a\"))))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle CP(P, C);
	Unify::CHandle Cconjunction(conjunction, C);

	Unify unify(lhs, rhs, lhs_vardecl, rhs_vardecl);
	Unify::SolutionSet result = unify();
	Unify::Block pb_expected{CP, Cconjunction};
	Unify::Partition partition_expected{{pb_expected, Cconjunction}};
	Unify::SolutionSet expected = Unify::SolutionSet({partition_expected});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	Handle ts_vardecl = _eval.eval_h("(TypedVariableLink"
	                                 "  (VariableNode \"$Y-6f50cc6a\")"
	                                 "  (TypeNode \"ConceptNode\"))");

	Unify::TypedSubstitutions tss_result =
		unify.typed_substitutions(result, lhs);
	Unify::HandleCHandleMap hchm_expected =
		Unify::HandleCHandleMap{{P, Cconjunction}};
	Unify::TypedSubstitution ts_expected =
		Unify::TypedSubstitution{hchm_expected, ts_vardecl};
	Unify::TypedSubstitutions tss_expected =
		Unify::TypedSubstitutions{ts_expected};

	std::cout << "tss_result = " << oc_to_string(tss_result) << std::endl;
	std::cout << "tss_expected = " << oc_to_string(tss_expected) << std::endl;

	TS_ASSERT(tss_content_eq(tss_result, tss_expected));
}

void UnifyUTest::test_unify_complex_3()
{
	Handle lhs =
		_eval.eval_h("(ImplicationLink"
		             "  (QuoteLink"
		             "    (LambdaLink"
		             "      (UnquoteLink"
		             "        (VariableNode \"$TyVs-3753c5dc\"))"
		             "      (UnquoteLink"
		             "        (VariableNode \"$Q-79152fc8\"))))"
		             "  (LambdaLink"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$X\")"
		             "      (TypeNode \"ConceptNode\"))"
		             "    (EvaluationLink"
		             "      (PredicateNode \"take\")"
		             "      (ListLink"
		             "        (VariableNode \"$X\")"
		             "        (ConceptNode \"compound-A\")))))");

	Handle rhs =
		_eval.eval_h("(ImplicationLink"
		             "  (QuoteLink"
		             "    (LambdaLink"
		             "      (UnquoteLink"
		             "        (VariableNode \"$TyVs-7b18f3dc\"))"
		             "      (UnquoteLink"
		             "        (VariableNode \"$P-60bdbde3\"))))"
		             "  (QuoteLink"
		             "    (LambdaLink"
		             "      (UnquoteLink"
		             "        (VariableNode \"$TyVs-7b18f3dc\"))"
		             "      (UnquoteLink"
		             "        (VariableNode \"$Q-344be2a0\")))))");

	Handle lhs_vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$TyVs-3753c5dc\")"
		             "    (TypeChoice"
		             "      (TypeNode \"TypedVariableLink\")"
		             "      (TypeNode \"VariableList\")))"
		             "  (VariableNode \"$Q-79152fc8\"))");

	Handle rhs_vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$TyVs-7b18f3dc\")"
		             "    (TypeChoice"
		             "      (TypeNode \"TypedVariableLink\")"
		             "      (TypeNode \"VariableList\")))"
		             "  (VariableNode \"$P-60bdbde3\")"
		             "  (VariableNode \"$Q-344be2a0\"))");

	Handle TyVs1 = _eval.eval_h("(VariableNode \"$TyVs-3753c5dc\")");
	Handle TyVs2 = _eval.eval_h("(VariableNode \"$TyVs-7b18f3dc\")");
	Handle Q1 = _eval.eval_h("(VariableNode \"$Q-79152fc8\")");
	Handle Q2 = _eval.eval_h("(VariableNode \"$Q-344be2a0\")");
	Handle P =_eval.eval_h("(VariableNode \"$P-60bdbde3\")");

	Handle vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"compound-A\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle Cvardecl(vardecl, C), Cimplicant_body(implicant_body, C);

	Unify unify(lhs, rhs, lhs_vardecl, rhs_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{TyVs1, TyVs2, Cvardecl}, Cvardecl},
				                        {{Q1, P}, Q1},
				                        {{Q2, Cimplicant_body}, Cimplicant_body}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_4()
{
	// Very similar to test_unify_complex_1() but for some reason doesn't work.
	Handle target = _eval.eval_h(
		"(ImplicationLink"
		"  (LambdaLink"
		"    (TypedVariableLink"
		"      (VariableNode \"$X\")"
		"      (TypeNode \"ConceptNode\")"
		"    )"
		"    (EvaluationLink"
		"      (PredicateNode \"take\")"
		"      (ListLink"
		"        (VariableNode \"$X\")"
		"        (ConceptNode \"treatment-1\")"
		"      )"
		"    )"
		"  )"
		"  (AndLink"
		"    (QuoteLink"
		"      (LambdaLink"
		"        (UnquoteLink"
		"          (VariableNode \"$TyVs-5476a9b9\")"
		"        )"
		"        (UnquoteLink"
		"          (VariableNode \"$A1-7235efc6\")"
		"        )"
		"      )"
		"    )"
		"    (QuoteLink"
		"      (LambdaLink"
		"        (UnquoteLink"
		"          (VariableNode \"$TyVs-5476a9b9\")"
		"        )"
		"        (UnquoteLink"
		"          (VariableNode \"$A2-1ac8e4a2\")"
		"        )"
		"      )"
		"    )"
		"  )"
		")"
		);
	Handle alpha_pat = _eval.eval_h(
		"(ImplicationLink"
		"  (VariableNode \"$P-10ea3e30\")"
		"  (AndLink"
		"    (VariableNode \"$P-10ea3e30\")"
		"    (VariableNode \"$Q-78f01c2d\")"
		"  )"
		")"
		);
	Handle vardecl = _eval.eval_h(
		"(VariableList"
		"  (TypedVariableLink"
		"    (VariableNode \"$TyVs-5476a9b9\")"
		"    (TypeChoice"
		"      (TypeNode \"TypedVariableLink\")"
		"      (TypeNode \"VariableNode\")"
		"      (TypeNode \"VariableList\")"
		"    )"
		"  )"
		"  (TypedVariableLink"
		"    (VariableNode \"$A1-7235efc6\")"
		"    (TypeNode \"EvaluationLink\")"
		"  )"
		"  (TypedVariableLink"
		"    (VariableNode \"$A2-1ac8e4a2\")"
		"    (TypeNode \"EvaluationLink\")"
		"  )"
		")"
		);
	Handle alpha_vardecl = _eval.eval_h(
		"(VariableList"
		"  (TypedVariableLink"
		"    (VariableNode \"$P-10ea3e30\")"
		"    (TypeChoice"
		"      (TypeNode \"LambdaLink\")"
		"      (TypeNode \"PredicateNode\")"
		"    )"
		"  )"
		"  (TypedVariableLink"
		"    (VariableNode \"$Q-78f01c2d\")"
		"    (TypeChoice"
		"      (TypeNode \"LambdaLink\")"
		"      (TypeNode \"PredicateNode\")"
		"    )"
		"  )"
		")"
		);

	Handle P = _eval.eval_h("(VariableNode \"$P-10ea3e30\")");
	Handle Q = _eval.eval_h("(VariableNode \"$Q-78f01c2d\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs-5476a9b9\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1-7235efc6\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2-1ac8e4a2\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_LA1 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs-5476a9b9\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1-7235efc6\"))))");

	Handle quoted_LA2 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs-5476a9b9\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A2-1ac8e4a2\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{P, implicant, quoted_LA2},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             Cimplicant_vardecl},
						                {{A2, Cimplicant_body},
								         Cimplicant_body},
						                {{Q, quoted_LA1},
								         quoted_LA1}},
				                       {{{P, implicant, quoted_LA1},
						 	             implicant},
						                {{TyVs, Cimplicant_vardecl},
						 	             Cimplicant_vardecl},
						                {{A1, Cimplicant_body},
								         Cimplicant_body},
						                {{Q, quoted_LA2},
								         quoted_LA2}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_5()
{
	Handle target =
        _eval.eval_h("(LambdaLink"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$X\")"
                     "    (TypeNode \"ConceptNode\")"
                     "  )"
                     "  (VariableNode \"$Q-496643b4\")"
                     ")");

	Handle alpha_pat =
        _eval.eval_h("(QuoteLink"
                     "  (LambdaLink"
                     "    (UnquoteLink"
                     "      (VariableNode \"$TyVs-3e93b595\")"
                     "    )"
                     "    (UnquoteLink"
                     "      (VariableNode \"$A2-76df4103\")"
                     "    )"
                     "  )"
                     ")");

	Handle vardecl =
        _eval.eval_h("(VariableNode \"$Q-496643b4\")");

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$TyVs-3e93b595\")"
                     "    (TypeChoice"
                     "      (TypeNode \"TypedVariableLink\")"
                     "      (TypeNode \"VariableNode\")"
                     "      (TypeNode \"VariableList\")"
                     "    )"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$A2-76df4103\")"
                     "    (TypeNode \"EvaluationLink\")"
                     "  )"
                     ")");

	Handle Q = _eval.eval_h("(VariableNode \"$Q-496643b4\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs-3e93b595\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2-76df4103\")");

	Handle lambda_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle take_treatment_1 =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle CQ(Q, C),
        Clambda_vardecl(lambda_vardecl, C),
		Ctake_treatment_1(take_treatment_1, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{CQ, A2}, A2},
						                {{TyVs, Clambda_vardecl},
                                         Clambda_vardecl}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_6()
{
	Handle target =
        _eval.eval_h("(ImplicationLink"
                     "  (AndLink"
                     "    (LambdaLink"
                     "      (TypedVariableLink"
                     "        (VariableNode \"$X\")"
                     "        (TypeNode \"ConceptNode\")"
                     "      )"
                     "      (EvaluationLink"
                     "        (PredicateNode \"take\")"
                     "        (ListLink"
                     "          (VariableNode \"$X\")"
                     "          (ConceptNode \"treatment-1\")"
                     "        )"
                     "      )"
                     "    )"
                     "    (LambdaLink"
                     "      (TypedVariableLink"
                     "        (VariableNode \"$X\")"
                     "        (TypeNode \"ConceptNode\")"
                     "      )"
                     "      (VariableNode \"$Q-496643b4\")"
                     "    )"
                     "  )"
                     "  (LambdaLink"
                     "    (TypedVariableLink"
                     "      (VariableNode \"$X\")"
                     "      (TypeNode \"ConceptNode\")"
                     "    )"
                     "    (AndLink"
                     "      (VariableNode \"$Q-496643b4\")"
                     "      (EvaluationLink"
                     "        (PredicateNode \"take\")"
                     "        (ListLink"
                     "          (VariableNode \"$X\")"
                     "          (ConceptNode \"treatment-1\")"
                     "        )"
                     "      )"
                     "    )"
                     "  )"
                     ")");

	Handle alpha_pat =
        _eval.eval_h("(ImplicationLink"
                     "  (AndLink"
                     "    (QuoteLink"
                     "      (LambdaLink"
                     "        (UnquoteLink"
                     "          (VariableNode \"$TyVs-3e93b595\")"
                     "        )"
                     "        (UnquoteLink"
                     "          (VariableNode \"$A1-4fd556f2\")"
                     "        )"
                     "      )"
                     "    )"
                     "    (QuoteLink"
                     "      (LambdaLink"
                     "        (UnquoteLink"
                     "          (VariableNode \"$TyVs-3e93b595\")"
                     "        )"
                     "        (UnquoteLink"
                     "          (VariableNode \"$A2-76df4103\")"
                     "        )"
                     "      )"
                     "    )"
                     "  )"
                     "  (QuoteLink"
                     "    (LambdaLink"
                     "      (UnquoteLink"
                     "        (VariableNode \"$TyVs-3e93b595\")"
                     "      )"
                     "      (UnquoteLink"
                     "        (AndLink"
                     "          (VariableNode \"$A1-4fd556f2\")"
                     "          (VariableNode \"$A2-76df4103\")"
                     "        )"
                     "      )"
                     "    )"
                     "  )"
                     ")");

	Handle vardecl =
        _eval.eval_h("(VariableNode \"$Q-496643b4\")");

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$TyVs-3e93b595\")"
                     "    (TypeChoice"
                     "      (TypeNode \"TypedVariableLink\")"
                     "      (TypeNode \"VariableNode\")"
                     "      (TypeNode \"VariableList\")"
                     "    )"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$A1-4fd556f2\")"
                     "    (TypeNode \"EvaluationLink\")"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$A2-76df4103\")"
                     "    (TypeNode \"EvaluationLink\")"
                     "  )"
                     ")");

	Handle Q = _eval.eval_h("(VariableNode \"$Q-496643b4\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs-3e93b595\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1-4fd556f2\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2-76df4103\")");

	Handle lambda_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle take_treatment_1 =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle CQ(Q, C),
        Clambda_vardecl(lambda_vardecl, C),
		Ctake_treatment_1(take_treatment_1, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{CQ, A1}, A1},
						                {{TyVs, Clambda_vardecl},
						 	             Clambda_vardecl},
						                {{A2, Ctake_treatment_1},
                                         Ctake_treatment_1}},
				                       {{{CQ, A1, A2, Ctake_treatment_1},
							             Ctake_treatment_1},
						                {{TyVs, Clambda_vardecl},
								         Clambda_vardecl}},
                                       {{{CQ, A2}, A2},
						                {{TyVs, Clambda_vardecl},
						 	             Clambda_vardecl},
						                {{A1, Ctake_treatment_1},
                                         Ctake_treatment_1}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_7()
{
	Handle target =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\")"
		             "  )"
		             "  (EvaluationLink"
		             "    (PredicateNode \"contain\")"
		             "    (ListLink"
		             "      (ConceptNode \"treatment-1\")"
		             "      (ConceptNode \"compound-A\")"
		             "    )"
		             "  )"
		             ")");

	Handle alpha_pat =
        _eval.eval_h("(QuoteLink"
                     "  (LambdaLink"
                     "    (UnquoteLink"
                     "      (VariableNode \"$V-6c74a409\")"
                     "    )"
                     "    (UnquoteLink"
                     "      (VariableNode \"$B-6266d6f2\")"
                     "    )"
                     "  )"
                     ")");

	Handle vardecl;

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$V-6c74a409\")"
                     "    (TypeChoice"
                     "      (TypeNode \"TypedVariableLink\")"
                     "      (TypeNode \"VariableNode\")"
                     "      (TypeNode \"VariableList\")"
                     "    )"
                     "  )"
                     "  (VariableNode \"$B-6266d6f2\")"
                     ")");

	Handle V = _eval.eval_h("(VariableNode \"$V-6c74a409\")");
	Handle B = _eval.eval_h("(VariableNode \"$B-6266d6f2\")");
	Handle X_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\")"
		             ")");
	Handle body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"contain\")"
		             "  (ListLink"
		             "    (ConceptNode \"treatment-1\")"
		             "    (ConceptNode \"compound-A\")"
		             "  )"
		             ")");

	Context C(Quotation(), {X}, true, X_varstack);
	Unify::CHandle CX_vardecl(X_vardecl, C), Cbody(body, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{V, CX_vardecl}, CX_vardecl},
					                    {{B, Cbody}, Cbody}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	Handle ts_vardecl = al(VARIABLE_LIST);

	Unify::TypedSubstitutions ts_result =
		unify.typed_substitutions(result, target);
	Unify::TypedSubstitutions ts_expected =
		Unify::TypedSubstitutions{{{{V, CX_vardecl},
		                            {B, Cbody}},
		                           ts_vardecl}};

	std::cout << "ts_result = " << oc_to_string(ts_result) << std::endl;
	std::cout << "ts_expected = " << oc_to_string(ts_expected) << std::endl;

	TS_ASSERT(tss_content_eq(ts_result, ts_expected));
}

void UnifyUTest::test_unify_complex_8()
{
	Handle target =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$x\")"
		             "    )"
		             "    (UnquoteLink"
		             "      (VariableNode \"$g\")"
		             "    )"
		             "  )"
		             ")");

	Handle alpha_pat =
		_eval.eval_h("(LambdaLink"
		             "  (VariableNode \"$X\")"
		             "  (VariableNode \"$X\")"
		             ")");

	Handle vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$x\")"
		             "    (TypeNode \"VariableNode\")"
		             "  )"
		             "  (VariableNode \"$g\")"
		             ")");

	Handle alpha_vardecl;

	Handle x_var = _eval.eval_h("(VariableNode \"$x\")");
	Handle g_var = _eval.eval_h("(VariableNode \"$g\")");
	Handle X = _eval.eval_h("(VariableNode \"$X\")");

	Context C(Quotation(), {X}, true, {Variables{X}});
	Unify::CHandle CX(X, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{x_var, g_var, CX}, CX}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_9()
{
	Handle target =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"minsup\")"
		             "  (ListLink"
		             "    (QuoteLink"
		             "      (LambdaLink"
		             "        (UnquoteLink"
		             "          (VariableNode \"$x\")"
		             "        )"
		             "        (UnquoteLink"
		             "          (VariableNode \"$g\")"
		             "        )"
		             "      )"
		             "    )"
		             "    (ConceptNode \"texts\")"
		             "    (NumberNode \"2.000000\")"
		             "  )"
		             ")");

	Handle alpha_pat =
        _eval.eval_h("(EvaluationLink"
                     "  (PredicateNode \"minsup\")"
                     "  (ListLink"
                     "    (LambdaLink"
                     "      (VariableNode \"$X\")"
                     "      (VariableNode \"$X\")"
                     "    )"
                     "    (VariableNode \"$texts\")"
                     "    (VariableNode \"$ms\")"
                     "  )"
                     ")");

	Handle vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$x\")"
                     "    (TypeNode \"VariableNode\")"
                     "  )"
                     "  (VariableNode \"$g\")"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$f\")"
                     "    (TypeNode \"LambdaLink\")"
                     "  )"
                     ")");

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$texts\")"
                     "    (TypeNode \"ConceptNode\")"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$ms\")"
                     "    (TypeNode \"NumberNode\")"
                     "  )"
                     ")");

	Handle x_var = _eval.eval_h("(VariableNode \"$x\")");
	Handle f_var = _eval.eval_h("(VariableNode \"$f\")");
	Handle g_var = _eval.eval_h("(VariableNode \"$g\")");
	Handle texts_var = _eval.eval_h("(VariableNode \"$texts\")");
	Handle ms_var = _eval.eval_h("(VariableNode \"$ms\")");
	Handle X = _eval.eval_h("(VariableNode \"$X\")");
	Handle texts = _eval.eval_h("(ConceptNode \"texts\")");
	Handle ms = _eval.eval_h("(NumberNode \"2.0\")");

	Context C(Quotation(), {X}, true, {Variables{X}});
	Unify::CHandle CX(X, C);

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{x_var, g_var, CX}, CX},
					                    {{texts_var, texts}, texts},
					                    {{ms_var, ms}, ms}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_10()
{
	Handle target =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"minsup\")"
		             "  (ListLink"
		             "    (QuoteLink"
		             "      (PutLink"
		             "        (LambdaLink"
		             "          (VariableNode \"$top-arg\")"
		             "          (VariableNode \"$top-arg\")"
		             "        )"
		             "        (UnquoteLink"
		             "          (VariableNode \"$patvar\")"
		             "        )"
		             "      )"
		             "    )"
		             "    (ConceptNode \"texts\")"
		             "    (NumberNode \"2\")"
		             "  )"
		             ")");

	Handle alpha_pat =
        _eval.eval_h("(EvaluationLink"
                     "  (PredicateNode \"minsup\")"
                     "  (ListLink"
                     "    (QuoteLink"
                     "      (PutLink"
                     "        (UnquoteLink"
                     "          (VariableNode \"$g\")"
                     "        )"
                     "        (UnquoteLink"
                     "          (VariableNode \"$f\")"
                     "        )"
                     "      )"
                     "    )"
                     "    (VariableNode \"$texts\")"
                     "    (VariableNode \"$ms\")"
                     "  )"
                     ")");

	Handle vardecl =
        _eval.eval_h("(VariableNode \"$patvar\")");

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$g\")"
                     "    (TypeChoice"
                     "      (TypeNode \"LambdaLink\")"
                     "      (TypeNode \"PutLink\")"
                     "    )"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$texts\")"
                     "    (TypeNode \"ConceptNode\")"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$ms\")"
                     "    (TypeNode \"NumberNode\")"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$f\")"
                     "    (TypeChoice"
                     "      (TypeNode \"LambdaLink\")"
                     "      (TypeNode \"ConceptNode\")"
                     "    )"
                     "  )"
                     ")");

	Handle g_var = _eval.eval_h("(VariableNode \"$g\")");
	Handle top = _eval.eval_h("(LambdaLink"
	                          "  (VariableNode \"$top-arg\")"
	                          "  (VariableNode \"$top-arg\"))");
	Unify::CHandle Ctop(top, Quotation(1));
	Handle pat_var = _eval.eval_h("(VariableNode \"$patvar\")");
	Handle f_var = _eval.eval_h("(VariableNode \"$f\")");
	Handle texts_var = _eval.eval_h("(VariableNode \"$texts\")");
	Handle texts = _eval.eval_h("(ConceptNode \"texts\")");
	Handle ms_var = _eval.eval_h("(VariableNode \"$ms\")");
	Handle ms = _eval.eval_h("(NumberNode \"2\")");

	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{g_var, Ctop}, Ctop},
					                    {{pat_var, f_var}, f_var},
					                    {{texts_var, texts}, texts},
					                    {{ms_var, ms}, ms}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	Handle ts_vardecl = _eval.eval_h("(TypedVariableLink"
	                                 "  (VariableNode \"$f\")"
	                                 "  (TypeChoice"
	                                 "    (TypeNode \"ConceptNode\")"
	                                 "    (TypeNode \"LambdaLink\")"
	                                 "  )"
	                                 ")");

	Unify::TypedSubstitutions ts_result =
		unify.typed_substitutions(result, target);
	Unify::TypedSubstitutions ts_expected =
		Unify::TypedSubstitutions{{{{texts_var, texts},
		                            {g_var, Ctop},
		                            {f_var, f_var},
		                            {ms_var, ms},
		                            {pat_var, f_var}},
		                           ts_vardecl}};

	std::cout << "ts_result = " << oc_to_string(ts_result) << std::endl;
	std::cout << "ts_expected = " << oc_to_string(ts_expected) << std::endl;

	TS_ASSERT(tss_content_eq(ts_result, ts_expected));
}

/**
 * Test unification and substitution on a complex hypergraph
 */
void UnifyUTest::test_unify_complex_11()
{
	// Hypergraph to substitute after unification
	Handle bl =
		_eval.eval_h("(BindLink"
		             "  (VariableList"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$g\")"
		             "      (TypeChoice"
		             "        (TypeNode \"LambdaLink\")"
		             "        (TypeNode \"PutLink\")"
		             "      )"
		             "    )"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$texts\")"
		             "      (TypeNode \"ConceptNode\")"
		             "    )"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$ms\")"
		             "      (TypeNode \"NumberNode\")"
		             "    )"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$f\")"
		             "      (TypeChoice"
		             "        (TypeNode \"LambdaLink\")"
		             "        (TypeNode \"PutLink\")"
		             "        (TypeNode \"ConceptNode\")"
		             "      )"
		             "    )"
		             "  )"
		             "  (AndLink"
		             "    (VariableNode \"$f\")"
		             "    (EvaluationLink"
		             "      (PredicateNode \"minsup\")"
		             "      (ListLink"
		             "        (VariableNode \"$g\")"
		             "        (VariableNode \"$texts\")"
		             "        (VariableNode \"$ms\")"
		             "      )"
		             "    )"
		             "    (EvaluationLink"
		             "      (GroundedPredicateNode \"scm: absolutely-true\")"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (VariableNode \"$g\")"
		             "          (VariableNode \"$texts\")"
		             "          (VariableNode \"$ms\")"
		             "        )"
		             "      )"
		             "    )"
		             "    (EvaluationLink"
		             "      (GroundedPredicateNode \"scm: has-arity\")"
		             "      (ListLink"
		             "        (VariableNode \"$g\")"
		             "        (NumberNode \"2\")"
		             "      )"
		             "    )"
		             "  )"
		             "  (ExecutionOutputLink"
		             "    (GroundedSchemaNode \"scm: specialization-formula\")"
		             "    (ListLink"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (QuoteLink"
		             "            (PutLink"
		             "              (UnquoteLink"
		             "                (VariableNode \"$g\")"
		             "              )"
		             "              (UnquoteLink"
		             "                (ListLink"
		             "                  (VariableNode \"$spe-arg-0\")"
		             "                  (VariableNode \"$f\")"
		             "                )"
		             "              )"
		             "            )"
		             "          )"
		             "          (VariableNode \"$texts\")"
		             "          (VariableNode \"$ms\")"
		             "        )"
		             "      )"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (VariableNode \"$g\")"
		             "          (VariableNode \"$texts\")"
		             "          (VariableNode \"$ms\")"
		             "        )"
		             "      )"
		             "      (VariableNode \"$f\")"
		             "    )"
		             "  )"
		             ")");

	// Sub-element of bl to unify with
	Handle target =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"minsup\")"
		             "  (ListLink"
		             "    (QuoteLink"
		             "      (PutLink"
		             "        (PutLink"
		             "          (LambdaLink"
		             "            (VariableNode \"$top-arg\")"
		             "            (VariableNode \"$top-arg\")"
		             "          )"
		             "          (UnquoteLink"
		             "            (VariableNode \"$shapat-0\")"
		             "          )"
		             "        )"
		             "        (UnquoteLink"
		             "          (VariableNode \"$shapat-1\")"
		             "        )"
		             "      )"
		             "    )"
		             "    (ConceptNode \"texts\")"
		             "    (NumberNode \"2\")"
		             "  )"
		             ")");

	Handle alpha_pat =
        _eval.eval_h("(EvaluationLink"
                     "  (PredicateNode \"minsup\")"
                     "  (ListLink"
                     "    (QuoteLink"
                     "      (PutLink"
                     "        (UnquoteLink"
                     "          (VariableNode \"$g\")"
                     "        )"
                     "        (UnquoteLink"
                     "          (ListLink"
                     "            (VariableNode \"$spe-arg-0\")"
                     "            (VariableNode \"$f\")"
                     "          )"
                     "        )"
                     "      )"
                     "    )"
                     "    (VariableNode \"$texts\")"
                     "    (VariableNode \"$ms\")"
                     "  )"
                     ")");

	Handle vardecl =
        _eval.eval_h("(VariableList"
                     "  (VariableNode \"$shapat-1\")"
                     "  (VariableNode \"$shapat-0\")"
                     ")");

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$g\")"
                     "    (TypeChoice"
                     "      (TypeNode \"LambdaLink\")"
                     "      (TypeNode \"PutLink\")"
                     "    )"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$texts\")"
                     "    (TypeNode \"ConceptNode\")"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$ms\")"
                     "    (TypeNode \"NumberNode\")"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$f\")"
                     "    (TypeChoice"
                     "      (TypeNode \"LambdaLink\")"
                     "      (TypeNode \"PutLink\")"
                     "      (TypeNode \"ConceptNode\")"
                     "    )"
                     "  )"
                     ")");

	Handle shapat1_var = _eval.eval_h("(VariableNode \"$shapat-1\")");
	Handle spef_list = _eval.eval_h("(ListLink"
	                                "  (VariableNode \"$spe-arg-0\")"
	                                "  (VariableNode \"$f\"))");
	Handle ms_var = _eval.eval_h("(VariableNode \"$ms\")");
	Handle ms = _eval.eval_h("(NumberNode \"2\")");
	Handle texts_var = _eval.eval_h("(VariableNode \"$texts\")");
	Handle texts = _eval.eval_h("(ConceptNode \"texts\")");
	Handle g_var = _eval.eval_h("(VariableNode \"$g\")");
	Handle put_top = _eval.eval_h("(PutLink"
	                              "  (LambdaLink"
	                              "    (VariableNode \"$top-arg\")"
	                              "    (VariableNode \"$top-arg\"))"
	                              "  (UnquoteLink"
	                              "    (VariableNode \"$shapat-0\")))");
	Unify::CHandle Cput_top(put_top, Quotation(1));

	// Test unification
	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{shapat1_var, spef_list}, spef_list},
					                    {{ms_var, ms}, ms},
					                    {{texts_var, texts}, texts},
					                    {{g_var, Cput_top}, Cput_top}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	// Test substitution structure construction
	Handle ts_vardecl = _eval.eval_h("(VariableList"
	                                 "  (VariableNode \"$shapat-0\")"
	                                 "  (TypedVariableLink"
	                                 "    (VariableNode \"$f\")"
	                                 "    (TypeChoice"
	                                 "      (TypeNode \"ConceptNode\")"
	                                 "      (TypeNode \"LambdaLink\")"
	                                 "      (TypeNode \"PutLink\"))))");

	Unify::TypedSubstitutions ts_result =
		unify.typed_substitutions(result, target);
	Unify::TypedSubstitutions ts_expected =
		Unify::TypedSubstitutions{{{{shapat1_var, spef_list},
		                            {ms_var, ms},
		                            {g_var, Cput_top},
		                            {texts_var, texts}},
		                           ts_vardecl}};

	std::cout << "ts_result = " << oc_to_string(ts_result) << std::endl;
	std::cout << "ts_expected = " << oc_to_string(ts_expected) << std::endl;

	TS_ASSERT(tss_content_eq(ts_result, ts_expected));

	// Test substitution itself
	BindLinkPtr blptr = BindLinkCast(bl);
	Handle sub_result = Unify::substitute(blptr, *ts_result.begin());
	Handle sub_expected =
		_eval.eval_h("(BindLink"
		             "  (VariableList"
		             "    (VariableNode \"$shapat-0\")"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$f\")"
		             "      (TypeChoice"
		             "        (TypeNode \"LambdaLink\")"
		             "        (TypeNode \"PutLink\")"
		             "        (TypeNode \"ConceptNode\")"
		             "      )"
		             "    )"
		             "  )"
		             "  (AndLink"
		             "    (VariableNode \"$f\")"
		             "    (EvaluationLink"
		             "      (PredicateNode \"minsup\")"
		             "      (ListLink"
		             "        (QuoteLink"
		             "          (PutLink"
		             "            (LambdaLink"
		             "              (VariableNode \"$top-arg\")"
		             "              (VariableNode \"$top-arg\")"
		             "            )"
		             "            (UnquoteLink"
		             "              (VariableNode \"$shapat-0\")"
		             "            )"
		             "          )"
		             "        )"
		             "        (ConceptNode \"texts\")"
		             "        (NumberNode \"2\")"
		             "      )"
		             "    )"
		             "    (EvaluationLink"
		             "      (GroundedPredicateNode \"scm: absolutely-true\")"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (QuoteLink"
		             "            (PutLink"
		             "              (LambdaLink"
		             "                (VariableNode \"$top-arg\")"
		             "                (VariableNode \"$top-arg\")"
		             "              )"
		             "              (UnquoteLink"
		             "                (VariableNode \"$shapat-0\")"
		             "              )"
		             "            )"
		             "          )"
		             "          (ConceptNode \"texts\")"
		             "          (NumberNode \"2\")"
		             "        )"
		             "      )"
		             "    )"
		             "    (EvaluationLink"
		             "      (GroundedPredicateNode \"scm: has-arity\")"
		             "      (ListLink"
		             "        (QuoteLink"
		             "          (PutLink"
		             "            (LambdaLink"
		             "              (VariableNode \"$top-arg\")"
		             "              (VariableNode \"$top-arg\")"
		             "            )"
		             "            (UnquoteLink"
		             "              (VariableNode \"$shapat-0\")"
		             "            )"
		             "          )"
		             "        )"
		             "        (NumberNode \"2\")"
		             "      )"
		             "    )"
		             "  )"
		             "  (ExecutionOutputLink"
		             "    (GroundedSchemaNode \"scm: specialization-formula\")"
		             "    (ListLink"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (QuoteLink"
		             "            (PutLink"
		             "              (PutLink"
		             "                (LambdaLink"
		             "                  (VariableNode \"$top-arg\")"
		             "                  (VariableNode \"$top-arg\")"
		             "                )"
		             "                (UnquoteLink"
		             "                  (VariableNode \"$shapat-0\")"
		             "                )"
		             "              )"
		             "              (UnquoteLink"
		             "                (ListLink"
		             "                  (VariableNode \"$spe-arg-0\")"
		             "                  (VariableNode \"$f\")"
		             "                )"
		             "              )"
		             "            )"
		             "          )"
		             "          (ConceptNode \"texts\")"
		             "          (NumberNode \"2\")"
		             "        )"
		             "      )"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (QuoteLink"
		             "            (PutLink"
		             "              (LambdaLink"
		             "                (VariableNode \"$top-arg\")"
		             "                (VariableNode \"$top-arg\")"
		             "              )"
		             "              (UnquoteLink"
		             "                (VariableNode \"$shapat-0\")"
		             "              )"
		             "            )"
		             "          )"
		             "          (ConceptNode \"texts\")"
		             "          (NumberNode \"2\")"
		             "        )"
		             "      )"
		             "      (VariableNode \"$f\")"
		             "    )"
		             "  )"
		             ")");

	std::cout << "sub_result = " << oc_to_string(sub_result) << std::endl;
	std::cout << "sub_expected = " << oc_to_string(sub_expected) << std::endl;

	TS_ASSERT(content_eq(sub_result, sub_expected));
}

/**
 * Test unification and substitution on a complex hypergraph
 */
void UnifyUTest::test_unify_complex_12()
{
	// Hypergraph to substitute after unification
	Handle bl =
		_eval.eval_h("(BindLink"
		             "  (VariableList"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$g\")"
		             "      (TypeChoice"
		             "        (TypeNode \"LambdaLink\")"
		             "        (TypeNode \"PutLink\")"
		             "      )"
		             "    )"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$texts\")"
		             "      (TypeNode \"ConceptNode\")"
		             "    )"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$ms\")"
		             "      (TypeNode \"NumberNode\")"
		             "    )"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$f\")"
		             "      (TypeNode \"LambdaLink\")"
		             "    )"
		             "  )"
		             "  (AndLink"
		             "    (VariableNode \"$f\")"
		             "    (EvaluationLink"
		             "      (PredicateNode \"minsup\")"
		             "      (ListLink"
		             "        (VariableNode \"$g\")"
		             "        (VariableNode \"$texts\")"
		             "        (VariableNode \"$ms\")"
		             "      )"
		             "    )"
		             "    (EvaluationLink"
		             "      (GroundedPredicateNode \"scm: absolutely-true\")"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (VariableNode \"$g\")"
		             "          (VariableNode \"$texts\")"
		             "          (VariableNode \"$ms\")"
		             "        )"
		             "      )"
		             "    )"
		             "    (EvaluationLink"
		             "      (GroundedPredicateNode \"scm: has-arity\")"
		             "      (ListLink"
		             "        (VariableNode \"$g\")"
		             "        (NumberNode \"3\")"
		             "      )"
		             "    )"
		             "  )"
		             "  (ExecutionOutputLink"
		             "    (GroundedSchemaNode \"scm: composition-formula\")"
		             "    (ListLink"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (QuoteLink"
		             "            (PutLink"
		             "              (UnquoteLink"
		             "                (VariableNode \"$g\")"
		             "              )"
		             "              (UnquoteLink"
		             "                (ListLink"
		             "                  (VariableNode \"$spe-arg-0\")"
		             "                  (VariableNode \"$spe-arg-1\")"
		             "                  (VariableNode \"$f\")"
		             "                )"
		             "              )"
		             "            )"
		             "          )"
		             "          (VariableNode \"$texts\")"
		             "          (VariableNode \"$ms\")"
		             "        )"
		             "      )"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (VariableNode \"$g\")"
		             "          (VariableNode \"$texts\")"
		             "          (VariableNode \"$ms\")"
		             "        )"
		             "      )"
		             "      (VariableNode \"$f\")"
		             "    )"
		             "  )"
		             ")");

	// Sub-element of bl to unify with
	Handle target =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"minsup\")"
		             "  (ListLink"
		             "    (QuoteLink"
		             "      (PutLink"
		             "        (LambdaLink"
		             "          (VariableNode \"$top-arg\")"
		             "          (VariableNode \"$top-arg\")"
		             "        )"
		             "        (UnquoteLink"
		             "          (VariableNode \"$shapat-0\")"
		             "        )"
		             "      )"
		             "    )"
		             "    (ConceptNode \"texts\")"
		             "    (NumberNode \"2\")"
		             "  )"
		             ")");

	Handle alpha_pat =
        _eval.eval_h("(EvaluationLink"
                     "  (PredicateNode \"minsup\")"
                     "  (ListLink"
                     "    (QuoteLink"
                     "      (PutLink"
                     "        (UnquoteLink"
                     "          (VariableNode \"$g\")"
                     "        )"
                     "        (UnquoteLink"
                     "          (ListLink"
                     "            (VariableNode \"$spe-arg-0\")"
                     "            (VariableNode \"$spe-arg-1\")"
                     "            (VariableNode \"$f\")"
                     "          )"
                     "        )"
                     "      )"
                     "    )"
                     "    (VariableNode \"$texts\")"
                     "    (VariableNode \"$ms\")"
                     "  )"
                     ")");

	Handle vardecl =
        _eval.eval_h("(VariableNode \"$shapat-0\")");

	Handle alpha_vardecl =
        _eval.eval_h("(VariableList"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$g\")"
                     "    (TypeChoice"
                     "      (TypeNode \"LambdaLink\")"
                     "      (TypeNode \"PutLink\")"
                     "    )"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$texts\")"
                     "    (TypeNode \"ConceptNode\")"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$ms\")"
                     "    (TypeNode \"NumberNode\")"
                     "  )"
                     "  (TypedVariableLink"
                     "    (VariableNode \"$f\")"
                     "    (TypeNode \"LambdaLink\")"
                     "  )"
                     ")");

	Handle shapat0_var = _eval.eval_h("(VariableNode \"$shapat-0\")");
	Handle spef_list = _eval.eval_h("(ListLink"
	                                "  (VariableNode \"$spe-arg-0\")"
	                                "  (VariableNode \"$spe-arg-1\")"
	                                "  (VariableNode \"$f\"))");
	Handle ms_var = _eval.eval_h("(VariableNode \"$ms\")");
	Handle ms = _eval.eval_h("(NumberNode \"2\")");
	Handle texts_var = _eval.eval_h("(VariableNode \"$texts\")");
	Handle texts = _eval.eval_h("(ConceptNode \"texts\")");
	Handle g_var = _eval.eval_h("(VariableNode \"$g\")");
	Handle top = _eval.eval_h("(LambdaLink"
	                          "  (VariableNode \"$top-arg\")"
	                          "  (VariableNode \"$top-arg\"))");
	Unify::CHandle Ctop(top, Quotation(1));

	// Test unification
	Unify unify(target, alpha_pat, vardecl, alpha_vardecl);
	Unify::SolutionSet result = unify(),
		expected = Unify::SolutionSet({{{{ms_var, ms}, ms},
					                    {{texts_var, texts}, texts},
					                    {{g_var, Ctop}, Ctop},
						                {{shapat0_var, spef_list}, spef_list}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	// Test substitution structure construction
	Handle ts_vardecl = _eval.eval_h("(TypedVariableLink"
	                                 "  (VariableNode \"$f\")"
	                                 "  (TypeNode \"LambdaLink\"))");

	Unify::TypedSubstitutions ts_result =
		unify.typed_substitutions(result, target);
	Unify::TypedSubstitutions ts_expected =
		Unify::TypedSubstitutions{{{{ms_var, ms},
		                            {g_var, Ctop},
		                            {texts_var, texts},
		                            {shapat0_var, spef_list}},
		                           ts_vardecl}};

	std::cout << "ts_result = " << oc_to_string(ts_result) << std::endl;
	std::cout << "ts_expected = " << oc_to_string(ts_expected) << std::endl;

	TS_ASSERT(tss_content_eq(ts_result, ts_expected));

	// Test substitution itself
	BindLinkPtr blptr = BindLinkCast(bl);
	Handle sub_result = Unify::substitute(blptr, *ts_result.begin());
	Handle sub_expected =
		_eval.eval_h("(BindLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$f\")"
		             "    (TypeNode \"LambdaLink\")"
		             "  )"
		             "  (AndLink"
		             "    (VariableNode \"$f\")"
		             "    (EvaluationLink"
		             "      (GroundedPredicateNode \"scm: has-arity\")"
		             "      (ListLink"
		             "        (LambdaLink"
		             "          (VariableNode \"$top-arg\")"
		             "          (VariableNode \"$top-arg\")"
		             "        )"
		             "        (NumberNode \"3\")"
		             "      )"
		             "    )"
		             "    (EvaluationLink"
		             "      (PredicateNode \"minsup\")"
		             "      (ListLink"
		             "        (LambdaLink"
		             "          (VariableNode \"$top-arg\")"
		             "          (VariableNode \"$top-arg\")"
		             "        )"
		             "        (ConceptNode \"texts\")"
		             "        (NumberNode \"2\")"
		             "      )"
		             "    )"
		             "    (EvaluationLink"
		             "      (GroundedPredicateNode \"scm: absolutely-true\")"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (LambdaLink"
		             "            (VariableNode \"$top-arg\")"
		             "            (VariableNode \"$top-arg\")"
		             "          )"
		             "          (ConceptNode \"texts\")"
		             "          (NumberNode \"2\")"
		             "        )"
		             "      )"
		             "    )"
		             "  )"
		             "  (ExecutionOutputLink"
		             "    (GroundedSchemaNode \"scm: composition-formula\")"
		             "    (ListLink"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (QuoteLink"
		             "            (PutLink"
		             "              (LambdaLink"
		             "                (VariableNode \"$top-arg\")"
		             "                (VariableNode \"$top-arg\")"
		             "              )"
		             "              (UnquoteLink"
		             "                (ListLink"
		             "                  (VariableNode \"$spe-arg-0\")"
		             "                  (VariableNode \"$spe-arg-1\")"
		             "                  (VariableNode \"$f\")"
		             "                )"
		             "              )"
		             "            )"
		             "          )"
		             "          (ConceptNode \"texts\")"
		             "          (NumberNode \"2\")"
		             "        )"
		             "      )"
		             "      (EvaluationLink"
		             "        (PredicateNode \"minsup\")"
		             "        (ListLink"
		             "          (LambdaLink"
		             "            (VariableNode \"$top-arg\")"
		             "            (VariableNode \"$top-arg\")"
		             "          )"
		             "          (ConceptNode \"texts\")"
		             "          (NumberNode \"2\")"
		             "        )"
		             "      )"
		             "      (VariableNode \"$f\")"
		             "    )"
		             "  )"
		             ")");

	std::cout << "sub_result = " << oc_to_string(sub_result) << std::endl;
	std::cout << "sub_expected = " << oc_to_string(sub_expected) << std::endl;

	TS_ASSERT(content_eq(sub_result, sub_expected));
}

#undef al
#undef an
