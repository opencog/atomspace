#
# Test chemistry atom types - copied from examples/type-system/demo-types
#
# This builds a C++ library and Scheme/Python modules for testing
# custom atom type definitions with custom short names.
#

# --------------------------------------------------------------
# Part One: Build the various language wrappers.
#
# The `chem_types.script` file defines the types; the other three
# file are c++ files that are autogenerated in the build directory.
OPENCOG_GEN_CXX_ATOMTYPES(chem_types.script
	chem_types.h
	chem_types.definitions
	chem_types.inheritance)

# As above, but the guile scheme bindings are generated.
OPENCOG_GEN_SCM_ATOMTYPES(chem_types.script chem_types.scm)

IF (HAVE_CYTHON)
	# Same, for Python.
	OPENCOG_GEN_PYTHON_ATOMTYPES(chem_types.script chem_types.pyx)
ENDIF ()

# A "phony" target, which can be used in other places to guarantee
# that the bindings are built before any code that uses the bindings.
IF (HAVE_CYTHON)
	SET(CHEM_TYPES_PYX chem_types.pyx)
ENDIF (HAVE_CYTHON)

ADD_CUSTOM_TARGET(test_chem_atom_types
	DEPENDS chem_types.h chem_types.scm ${CHEM_TYPES_PYX}
)

# --------------------------------------------------------------
# Part Two: Build the C++ library
#
# The chem_types.h file is written to the build directory
INCLUDE_DIRECTORIES(${CMAKE_BINARY_DIR})

# This will build the `libtest-chem-types.so` shared library
# containing all the needed machinery to make things work.
ADD_LIBRARY (test-chem-types SHARED
	chem_types.h
	ChemTypes.cc
	Carbon14Node.cc
)

# Without this, parallel make will race and attempt to build the
# shared library before the needed generated files are created!
ADD_DEPENDENCIES(test-chem-types test_chem_atom_types)

# Add linking targets for the library.
TARGET_LINK_LIBRARIES(test-chem-types
	atom_types
	atombase
	atomspace
)

# --------------------------------------------------------------
# Part Three: Build the scheme module
#
DECLARE_GUILE_CONFIG_TARGET(TEST_CHEMODEMO_CONFIG
	"opencog test-chemodemo-config" "CHEM_TEST")

ADD_GUILE_EXTENSION(TEST_CHEMODEMO_CONFIG
	test-chem-types "opencog-ext-path-test-chemodemo")

WRITE_GUILE_CONFIG(
	${GUILE_BIN_DIR}/opencog/test-chemodemo-config.scm
	TEST_CHEMODEMO_CONFIG TRUE
)

# Define the guile module. The module (opencog test-demo-types) requires
# the file to be at opencog/test-demo-types.scm
ADD_GUILE_MODULE (FILES
	test-demo-types.scm
	MODULE_DESTINATION "${GUILE_SITE_DIR}/opencog/test-demo-types"
)

# Copy the generated chem_types.scm so it can be found.
# The ADD_GUILE_MODULE should have done this, but the
# ALL target that does this copying is not built for unit
# tests, which explicitly say 'EXCLUDE_FROM_ALL'.
ADD_CUSTOM_COMMAND(TARGET test-chem-types POST_BUILD
	COMMAND ${CMAKE_COMMAND} -E copy
		${CMAKE_CURRENT_SOURCE_DIR}/test-demo-types.scm
		${GUILE_BIN_DIR}/opencog/test-demo-types.scm
	COMMAND ${CMAKE_COMMAND} -E copy
		${CMAKE_CURRENT_BINARY_DIR}/chem_types.scm
		${GUILE_BIN_DIR}/opencog/test-demo-types/chem_types.scm
)

# --------------------------------------------------------------
# Part Four: Build the Python module

IF (HAVE_CYTHON)
# Specify the location of the Python.h header file
INCLUDE_DIRECTORIES(
	${Python3_INCLUDE_DIRS}
)

# The main python module is defined in chempydemo.pyx
# It depends on the autogenerated chem_types.pyx file.
CYTHON_ADD_MODULE_PYX(test_chempydemo
	chem_types.pyx
)

# The shared library will be called libtest_chempydemo.so
# The cpp file is generated by the CYTHON_ADD_MODULE_PYX above.
ADD_LIBRARY(test_chempydemo SHARED
	test_chempydemo.cpp
)

# Tell Cython-generated code to use C linkage for extern declarations
# since chem_types_init is declared with extern "C" in the source.
TARGET_COMPILE_DEFINITIONS(test_chempydemo PRIVATE
	CYTHON_EXTERN_C=extern\ \"C\"
)

# Use --no-as-needed to force linking test-chem-types even though the symbol
# is only referenced via cython extern, not direct C++ code
TARGET_LINK_LIBRARIES(test_chempydemo
	-Wl,--no-as-needed
	test-chem-types
	-Wl,--as-needed
	atomspace
	${Python3_LIBRARIES}
)

# ... except python doesn't like modules called `libfoo.so` It wants
# to find it's modules in `foo.so` instead.  So this causes CMake to
# rename the shared object to a name that python likes.
SET_TARGET_PROPERTIES(test_chempydemo PROPERTIES
	PREFIX ""
	OUTPUT_NAME test_chempydemo)

ADD_DEPENDENCIES(tests test_chempydemo)

ENDIF (HAVE_CYTHON)
