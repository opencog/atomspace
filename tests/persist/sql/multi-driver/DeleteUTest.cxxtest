/*
 * tests/persist/sql/multi-driver/DeleteUTest.cxxtest
 *
 * Test deletion from backing store.  Assumes PersistUTest is passing.
 *
 * If this test is failing for you, then be sure to read the README in
 * this directory, and also ../../opencong/persist/README, and then
 * create and configure the SQL database as described there. Next,
 * edit ../../lib/test-opencog.conf to add the database credentials
 * (the username and passwd).
 *
 * Copyright (C) 2008, 2009, 2013, 2017 Linas Vepstas <linasvepstas@gmail.com>
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <cstdio>

#include <opencog/atoms/atom_types/atom_types.h>
#include <opencog/atoms/base/Atom.h>
#include <opencog/atoms/base/Link.h>
#include <opencog/atoms/base/Node.h>
#include <opencog/atoms/truthvalue/SimpleTruthValue.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/persist/sql/multi-driver/SQLAtomStorage.h>

#include <opencog/util/Logger.h>
#include <opencog/util/Config.h>

#include "mkuri.h"

using namespace opencog;

class DeleteUTest :  public CxxTest::TestSuite
{
    private:
        AtomSpace *_as;
        std::string uri;
        const char * dbname;
        const char * username;
        const char * passwd;

        NodePtr n1[10];
        NodePtr n2[10];
        NodePtr n3[10];
        NodePtr n4[10];
        LinkPtr l[10];
        LinkPtr l2[10];
        LinkPtr l3[10];
        Handle h1[10];
        Handle h2[10];
        Handle h3[10];
        Handle h4[10];
        Handle hl[10];
        Handle hl2[10];
        Handle hl3[10];

    public:

        DeleteUTest(void);
        ~DeleteUTest()
        {
            // erase the log file if no assertions failed
            if (!CxxTest::TestTracker::tracker().suiteFailed())
                std::remove(logger().get_filename().c_str());
        }

        void setUp(void);
        void tearDown(void);
        void kill_data(void);

        void friendlyFailMessage()
        {
            TS_FAIL("The DeleteUTest failed.\n"
                "This is probably because you do not have SQL installed\n"
                "or configured the way that OpenCog expects.\n\n"
                "SQL persistence is optional for OpenCog, so if you don't\n"
                "want it or need it, just ignore this test failure.\n"
                "Otherwise, please be sure to read opencong/persist/sql/README,\n"
                "and create/configure the SQL database as described there.\n"
                "Next, edit lib/atomspace-test.conf appropriately, so as\n"
                "to indicate the location of your database. If this is\n"
                "done correctly, then this test will pass.\n");
            exit(1);
        }

        void add_to_space(int, AtomSpace *, std::string id);
        void fetch_space(int, StorageNodePtr);
        void check_space(int, AtomSpace *, std::string dbgmsg);
        void check_remove(int, AtomSpace *, std::string dbgmsg);
        void check_empty(int, AtomSpace *);
        void extract_links(int, AtomSpace *);
        void delete_links(int, StorageNodePtr);
        void extract_nodes(int, AtomSpace *);
        void delete_nodes(int, StorageNodePtr);
        void atomCompare(AtomPtr, AtomPtr, std::string);
        void tvMiscompare(AtomPtr, AtomPtr, std::string);

        void do_test_remove(void);
        void test_odbc_remove(void);
        void test_pq_remove(void);

        void do_test_recurse(void);
        void test_odbc_recurse(void);
        void test_pq_recurse(void);
};

DeleteUTest:: DeleteUTest(void)
{
    try
    {
        config().load("atomspace-test.conf");
    }
    catch (RuntimeException &e)
    {
        std::cerr << e.get_message() << std::endl;
    }
    logger().set_level(Logger::DEBUG);
    logger().set_print_to_stdout_flag(true);

    try {
        // Get the database logins & etc from the config file.
        dbname = config().get("TEST_DB_NAME", "opencog_test").c_str();
        username = config().get("TEST_DB_USERNAME", "opencog_tester").c_str();
        passwd = config().get("TEST_DB_PASSWD", "cheese").c_str();
    }
    catch (InvalidParamException &e)
    {
        friendlyFailMessage();
    }
}

/*
 * This is called once before each test, for each test (!!)
 */
void DeleteUTest::setUp(void)
{
    _as = new AtomSpace();
}

void DeleteUTest::tearDown(void)
{
    delete _as;

    kill_data();
}

// ============================================================

void DeleteUTest::kill_data(void)
{
#if HAVE_ODBC_STORAGE
    if ("" == uri) uri = mkuri("odbc", dbname, username, passwd);
#endif
#if HAVE_PGSQL_STORAGE
    if ("" == uri) uri = mkuri("postgres", dbname, username, passwd);
#endif
    SQLAtomStorage* astore = new SQLAtomStorage(uri);
    astore->open();
    if (!astore->connected())
    {
        logger().info("setUp: SQLAtomStorage cannot connect to database");
        friendlyFailMessage();
        exit(1);
    }
    logger().info("Delete data in \"%s\" as \"%s\" passwd \"%s\"", dbname, username, passwd);

    // Trash the contents of the database.
    astore->kill_data();

    // Destructor also logs out of database (avoid warning in DB log file)
    delete astore;
}

// ============================================================

void DeleteUTest::atomCompare(AtomPtr a, AtomPtr b, std::string where)
{
    printf("Check %s expect %s\n", where.c_str(), a->to_string().c_str());
    TSM_ASSERT("No atom found", b != nullptr);

    if (nullptr == b) return;

    TSM_ASSERT_EQUALS("Type mismatch", a->get_type(), b->get_type());

    NodePtr na(NodeCast(a));
    NodePtr nb(NodeCast(b));
    if (na and nb)
    {
        TSM_ASSERT_EQUALS("Name mismatch", na->get_name(), nb->get_name());
    }

    LinkPtr la(LinkCast(a));
    LinkPtr lb(LinkCast(b));
    if (la and lb)
    {
        TSM_ASSERT_EQUALS("Arity mismatch", la->get_arity(), lb->get_arity());
        if (*la != *lb)
        {
            printf("Mismatching la = %s\n", la->to_string().c_str());
            printf("Mismatching lb = %s\n", lb->to_string().c_str());
            TSM_ASSERT_EQUALS("Link mis-match", la, lb);
        }
    }

    TruthValuePtr ta = a->getTruthValue();
    TruthValuePtr tb = b->getTruthValue();
    if (ta or tb)
    {
        TSM_ASSERT("Missing truth value", ta);
        TSM_ASSERT("Missing truth value", tb);
        if (ta and tb)
        {
            TSM_ASSERT("Truth value miscompare", (*ta)==(*tb));

            if (not ((*ta) == (*tb)))
            {
                fprintf(stderr, "Error, truth value miscompare, "
                    "ma=%f mb=%f ca=%f cb=%f\n",
                    ta->get_mean(), tb->get_mean(), ta->get_count(), tb->get_count());
            }
        }
    }
}

// Passes only if the TV's are different!
void DeleteUTest::tvMiscompare(AtomPtr a, AtomPtr b, std::string where)
{
    if (nullptr == a or nullptr == b) return;

    TruthValuePtr ta = a->getTruthValue();
    TruthValuePtr tb = b->getTruthValue();
    if (ta and tb)
    {
        TSM_ASSERT("Truth value should not match!", (*ta)!=(*tb));
    }
    if (nullptr==ta and nullptr==tb)
    {
        TSM_ASSERT("Truth value null!!", false);
    }
}

// ============================================================

void DeleteUTest::add_to_space(int idx, AtomSpace *as, std::string id)
{
    // Create an atom ...
    TruthValuePtr stv(SimpleTruthValue::createTV(0.11, 100+idx));
    h1[idx] = as->add_node(SCHEMA_NODE, id + "fromNode");
    h1[idx]->setTruthValue(stv);
    n1[idx] = NodeCast(h1[idx]);

    TruthValuePtr stv2(SimpleTruthValue::createTV(0.22, 200+idx));
    h2[idx] = as->add_node(SCHEMA_NODE, id + "toNode");
    h2[idx]->setTruthValue(stv2);
    n2[idx] = NodeCast(h2[idx]);

    TruthValuePtr stv3(SimpleTruthValue::createTV(0.33, 300+idx));
    h3[idx] = as->add_node(SCHEMA_NODE, id + "third wheel");
    h3[idx]->setTruthValue(stv3);
    n3[idx] = NodeCast(h3[idx]);

    // The NumberNode will go through the AtomTable clone factory
    // and should thus elicit any errors in clone uuid handling.
    char buf[40]; sprintf(buf, "%f", idx+0.14159265358979);
    h4[idx] = as->add_node(NUMBER_NODE, buf);
    TruthValuePtr stv4(SimpleTruthValue::createTV(0.44, 400+idx));
    h4[idx]->setTruthValue(stv4);
    n4[idx] = NodeCast(h4[idx]);

    HandleSeq hvec;
    hvec.push_back(h1[idx]);
    hvec.push_back(h2[idx]);
    hvec.push_back(h3[idx]);
    hvec.push_back(h4[idx]);

    // Note that SetLink is an unordered link.
    TruthValuePtr stv5(SimpleTruthValue::createTV(0.55, 500+idx));
    hl[idx] = as->add_link(SET_LINK, std::move(hvec));
    hl[idx]->setTruthValue(stv5);
    l[idx] = LinkCast(hl[idx]);

    TruthValuePtr stv6(SimpleTruthValue::createTV(0.66, 600+idx));
    hl2[idx] = as->add_link(LIST_LINK, hl[idx], h2[idx]);
    hl2[idx]->setTruthValue(stv6);
    l2[idx] = LinkCast(hl2[idx]);

    TruthValuePtr stv7(SimpleTruthValue::createTV(0.77, 700+idx));
    hl3[idx] = as->add_link(EVALUATION_LINK, h1[idx], hl2[idx], h3[idx]);
    hl3[idx]->setTruthValue(stv7);
    l3[idx] = LinkCast(hl3[idx]);
}

void DeleteUTest::fetch_space(int idx, StorageNodePtr space)
{
    AtomPtr ab1 = createNode(n1[idx]->get_type(), n1[idx]->get_name());
    Handle hb1(ab1->get_handle());
    space->fetch_atom(hb1);

    AtomPtr ab2 = createNode(n2[idx]->get_type(), n2[idx]->get_name());
    Handle hb2(ab2->get_handle());
    space->fetch_atom(hb2);

    AtomPtr ab3 = createNode(n3[idx]->get_type(), n3[idx]->get_name());
    Handle hb3(ab3->get_handle());
    space->fetch_atom(hb3);

    AtomPtr ab4 = createNode(n4[idx]->get_type(), n4[idx]->get_name());
    Handle hb4(ab4->get_handle());
    space->fetch_atom(hb4);

    HandleSeq hvec;
    hvec.push_back(hb1);
    hvec.push_back(hb2);
    hvec.push_back(hb3);
    hvec.push_back(hb4);

    AtomPtr alb = createLink(hvec, hl[idx]->get_type());
    Handle hlb(alb->get_handle());
    space->fetch_atom(hlb);

    HandleSeq hv2({hlb, hb2});
    AtomPtr alb2 = createLink(hv2, hl2[idx]->get_type());
    Handle hlb2(alb2->get_handle());
    space->fetch_atom(hlb2);

    HandleSeq hv3({hb1, hlb2, hb3});
    AtomPtr alb3 = createLink(hv3, hl3[idx]->get_type());
    Handle hlb3(alb3->get_handle());
    space->fetch_atom(hlb3);
    space->barrier();
}

void DeleteUTest::check_space(int idx, AtomSpace *space, std::string dbgmsg)
{
    Handle hb1 = space->get_handle(n1[idx]->get_type(), n1[idx]->get_name());
    atomCompare(h1[idx], hb1, dbgmsg + "-hb1");

    Handle hb2 = space->get_handle(n2[idx]->get_type(), n2[idx]->get_name());
    atomCompare(h2[idx], hb2, dbgmsg + "-hb2");

    Handle hb3 = space->get_handle(n3[idx]->get_type(), n3[idx]->get_name());
    atomCompare(h3[idx], hb3, dbgmsg + "-hb3");

    Handle hb4 = space->get_handle(n4[idx]->get_type(), n4[idx]->get_name());
    atomCompare(h4[idx], hb4, dbgmsg + "-hb4");

    HandleSeq hvec;
    hvec.push_back(hb1);
    hvec.push_back(hb2);
    hvec.push_back(hb3);
    hvec.push_back(hb4);

    Handle hlb = space->get_handle(hl[idx]->get_type(), hvec);
    atomCompare(hl[idx], hlb, dbgmsg + "-hlinkb");

    HandleSeq hv2({hlb, hb2});
    Handle hlb2 = space->get_handle(hl2[idx]->get_type(), hv2);
    atomCompare(hl2[idx], hlb2, dbgmsg + "-hlinkb2");

    HandleSeq hv3({hb1, hlb2, hb3});
    Handle hlb3 = space->get_handle(hl3[idx]->get_type(), hv3);
    atomCompare(hl3[idx], hlb3, dbgmsg + "-hlinkb3");
}

void DeleteUTest::check_remove(int idx, AtomSpace *space, std::string dbgmsg)
{
    Handle hb1 = space->get_handle(n1[idx]->get_type(), n1[idx]->get_name());
    Handle hb2 = space->get_handle(n2[idx]->get_type(), n2[idx]->get_name());
    Handle hb3 = space->get_handle(n3[idx]->get_type(), n3[idx]->get_name());
    Handle hb4 = space->get_handle(n4[idx]->get_type(), n4[idx]->get_name());

    HandleSeq hvec;
    hvec.push_back(hb1);
    hvec.push_back(hb2);
    hvec.push_back(hb3);
    hvec.push_back(hb4);

    Handle hlb = space->get_handle(hl[idx]->get_type(), hvec);
    tvMiscompare(hl[idx], hlb, dbgmsg + "-hlinkb");

    HandleSeq hv2({hlb, hb2});
    Handle hlb2 = space->get_handle(hl2[idx]->get_type(), hv2);
    tvMiscompare(hl2[idx], hlb2, dbgmsg + "-hlinkb2");

    HandleSeq hv3({hb1, hlb2, hb3});
    Handle hlb3 = space->get_handle(hl3[idx]->get_type(), hv3);
    tvMiscompare(hl3[idx], hlb3, dbgmsg + "-hlinkb3");
}

void DeleteUTest::check_empty(int idx, AtomSpace *space)
{
    Handle hb1 = space->get_handle(n1[idx]->get_type(), n1[idx]->get_name());
    TSM_ASSERT("Should not find this atom", hb1 == Handle::UNDEFINED);

    Handle hb2 = space->get_handle(n2[idx]->get_type(), n2[idx]->get_name());
    TSM_ASSERT("Should not find this atom", hb2 == Handle::UNDEFINED);

    Handle hb3 = space->get_handle(n3[idx]->get_type(), n3[idx]->get_name());
    TSM_ASSERT("Should not find this atom", hb3 == Handle::UNDEFINED);

    Handle hb4 = space->get_handle(n4[idx]->get_type(), n4[idx]->get_name());
    TSM_ASSERT("Should not find this atom", hb4 == Handle::UNDEFINED);

    HandleSeq hvec;
    hvec.push_back(h1[idx]);
    hvec.push_back(h2[idx]);
    hvec.push_back(h3[idx]);
    hvec.push_back(h4[idx]);

    Handle hlb = space->get_handle(hl[idx]->get_type(), hvec);
    TSM_ASSERT("Should not find this atom", hlb == Handle::UNDEFINED);
}

// This removes from atomspace, but not from storage.
void DeleteUTest::extract_links(int idx, AtomSpace *as)
{
	as->extract_atom(hl3[idx]);
	as->extract_atom(hl2[idx]);
	as->extract_atom(hl[idx]);
}

// This should delete all the links from storage (and also
// the AtomSpace)
void DeleteUTest::delete_links(int idx, StorageNodePtr store)
{
	store->remove_atom(hl3[idx]);
	store->barrier();
	store->remove_atom(hl2[idx]);
	store->barrier();
	store->remove_atom(hl[idx]);
	store->barrier();
}

// This removes all the links, and one node, from atomspace,
// but not from storage.
void DeleteUTest::extract_nodes(int idx, AtomSpace *as)
{
	as->extract_atom(h1[idx], true);
}

// This should delete all the links and one node from storage.
void DeleteUTest::delete_nodes(int idx, StorageNodePtr store)
{
	store->remove_atom(h3[idx], true);
	store->barrier();
}

// ============================================================

void DeleteUTest::test_odbc_remove(void)
{
#ifdef HAVE_ODBC_STORAGE
    uri = mkuri("odbc", dbname, username, passwd);
    do_test_remove();
#endif
}

void DeleteUTest::test_pq_remove(void)
{
#ifdef HAVE_PGSQL_STORAGE
    uri = mkuri("postgres", dbname, username, passwd);
    do_test_remove();
#endif
}

void DeleteUTest::do_test_remove(void)
{
    logger().debug("BEGIN TEST: %s", __FUNCTION__);

    kill_data();

    Handle hsn = _as->add_node(POSTGRES_STORAGE_NODE, std::string(uri));
    StorageNodePtr store = StorageNodeCast(hsn);

    try {
        store->open();
    }
    catch (RuntimeException &e)
    {
        logger().info("setUp: SQL cannot connect to database");
        friendlyFailMessage();
        exit(1);
    };

    int idx = 0;
    add_to_space(idx++, _as, "AA-aa-wow ");
    add_to_space(idx++, _as, "BB-bb-wow ");
    add_to_space(idx++, _as, "CC-cc-wow ");
    add_to_space(idx++, _as, "DD-dd-wow ");
    add_to_space(idx++, _as, "EE-ee-wow ");

    /* Make sure UTF-8 works fine. */
    add_to_space(idx++, _as, "Попытка выбраться вызвала слабый стон ");
    add_to_space(idx++, _as, "はにがうりだそうであってるのかはち ");
    add_to_space(idx++, _as, "係拉丁字母");

    /* Verify that the atoms were added */
    int i;
    for (i=0; i<idx; i++)
        check_space(i, _as, "verify-add");

    /* Push all atoms out to storage */
    store->store_atomspace();

    printf("Initial Atomspace size=%lu expect=%d\n", _as->get_size(), 7*idx+1);
    TSM_ASSERT("Initial unexpected atomspace size",
          ((unsigned)(7*idx+1)) == _as->get_size());
    /* Delete some atoms with non-empty incoming sets.
     * This should result in thier being removed from the atomspace,
     * but NOT fom the backend!
     */
    store->barrier();

    for (i=0; i<idx; i++)
        extract_links(i, _as);

    printf("Atomspace size=%lu expect=%d\n", _as->get_size(), 4*idx+1);
    TSM_ASSERT("Post-extract unexpected atomspace size",
        ((unsigned)(4*idx+1)) == _as->get_size());

    /* Verify that the atoms can still be fetched from storage. */
    for (i=0; i<idx; i++) {
        fetch_space(i, store);
        check_space(i, _as, "verify-fetch");
    }

    /* This time, kill them in the backend too.  */
    for (i=0; i<idx; i++)
        delete_links(i, store);

    // Plus-one for PredicateNode "*-TruthValueKey-*"
    printf("Post-remove size=%lu expect=%d\n", _as->get_size(), 4*idx+2);
    TSM_ASSERT_EQUALS("Post-remove unexpected atomspace size",
		((unsigned)(4*idx+2)), _as->get_size());

    /* Verify that the atoms are really gone from storage. */
    for (i=0; i<idx; i++) {
        fetch_space(i, store);
        check_remove(i, _as, "verify-gone");
    }

    printf("Post-referesh size=%lu expect=%d\n", _as->get_size(), 7*idx+2);
    TSM_ASSERT_EQUALS("Post-refetch unexpected atomspace size",
		((unsigned)(7*idx+2)), _as->get_size());

    /* Kill data for good */
    _as->clear();
    TSM_ASSERT("Non-empty atomspace", 0 == _as->get_size());
    kill_data();

    /* Verify that the atoms are no longer being found. */
    for (i=0; i<idx; i++)
        check_empty(i, _as);

    /* Orderly shutdown avoids warning in Postgres log file. */
    store->close();

    logger().debug("END TEST: %s", __FUNCTION__);
}

// ============================================================

void DeleteUTest::test_odbc_recurse(void)
{
#ifdef HAVE_ODBC_STORAGE
    uri = mkuri("odbc", dbname, username, passwd);
    do_test_recurse();
#endif
}

void DeleteUTest::test_pq_recurse(void)
{
#ifdef HAVE_PGSQL_STORAGE
    uri = mkuri("postgres", dbname, username, passwd);
    do_test_recurse();
#endif
}

void DeleteUTest::do_test_recurse(void)
{
    logger().debug("BEGIN TEST: %s", __FUNCTION__);

    Handle hsn = _as->add_node(POSTGRES_STORAGE_NODE, std::string(uri));
    StorageNodePtr store = StorageNodeCast(hsn);

    try {
        store->open();
    }
    catch (RuntimeException &e)
    {
        logger().info("setUp: SQL cannot connect to database");
        friendlyFailMessage();
        exit(1);
    };

    kill_data();

    int idx = 0;
    add_to_space(idx++, _as, "AA-aa-wow ");
    add_to_space(idx++, _as, "BB-bb-wow ");
    add_to_space(idx++, _as, "CC-cc-wow ");
    add_to_space(idx++, _as, "DD-dd-wow ");
    add_to_space(idx++, _as, "EE-ee-wow ");

    /* Make sure UTF-8 works fine. */
    add_to_space(idx++, _as, "Попытка выбраться вызвала слабый стон ");
    add_to_space(idx++, _as, "はにがうりだそうであってるのかはち ");
    add_to_space(idx++, _as, "係拉丁字母");

    /* Verify that the atoms were added */
    int i;
    for (i=0; i<idx; i++)
        check_space(i, _as, "verify-add");

    /* Push all atoms out to the SQL DB */
    store->store_atomspace();

    /* Perform recursive extract of some nodes.
     * This should result in thier being removed from the atomspace,
     * but NOT fom the backend!
     */
    store->barrier();

    int zap = 4;
    for (i=0; i<zap; i++)
        extract_nodes(i, _as);

    // Plus-one for PredicateNode "*-TruthValueKey-*"
    // Plus-one for PostgresStorageNode
    size_t expsz = 7*(idx-zap) + 3*zap + 1;
    printf("Atomspace size=%lu expect=%lu\n",
         _as->get_size(), expsz);
    TSM_ASSERT("Unexpected atomspace size", expsz == _as->get_size());

    /* Verify that the atoms can still be fetched from storage. */
    for (i=0; i<idx; i++) {
        fetch_space(i, store);
        check_space(i, _as, "verify-fetch");
    }

    /* This time, kill them in the backend too.  */
    for (i=0; i<zap; i++)
        delete_nodes(i, store);

    // Plus-one for PredicateNode "*-TruthValueKey-*"
    expsz += 1;
    printf("Post-remove size=%lu expect=%lu\n",
         _as->get_size(), expsz);
    TSM_ASSERT("Unexpected atomspace size", expsz == _as->get_size());

    store->barrier();

    /* Verify that the atoms are really gone from storage. */
    for (i=0; i<idx; i++) {
        fetch_space(i, store);
    }

    printf("Post-refetch size=%lu expect=%d\n",
         _as->get_size(), 7*idx+2);
    TSM_ASSERT("Unexpected atomspace size",
         ((unsigned) 7*idx+2) == _as->get_size());

    /* Check that the removed atoms really got zapped. */
    for (i=0; i<zap; i++) {
        check_remove(i, _as, "verify-zapped");
    }

    /* However, others should still be there. */
    for (i=zap; i<idx; i++) {
        check_space(i, _as, "verify-zap");
    }

    /* Kill data for good */
    _as->clear();
    TSM_ASSERT("Non-empty atomspace", 0 == _as->get_size());
    kill_data();

    /* Verify that the atoms are no longer being found. */
    for (i=0; i<idx; i++)
        check_empty(i, _as);

    /* Orderly shutdown avoids warning in Postgres log file. */
    store->close();

    logger().debug("END TEST: %s", __FUNCTION__);
}

/* ============================= END OF FILE ================= */
